var documenterSearchIndex = {"docs":
[{"location":"data_io/structs/#datastructs","page":"Data structure details","title":"Data structure details","text":"","category":"section"},{"location":"data_io/structs/","page":"Data structure details","title":"Data structure details","text":"We're incorporating structs as part of modernizing TASOPT from Fortran. Note that as we represent more parts of an aircraft as structs, these may change and will hopefully become a natural and intuitive data structure. ","category":"page"},{"location":"data_io/structs/#Primary-structs","page":"Data structure details","title":"Primary structs","text":"","category":"section"},{"location":"data_io/structs/","page":"Data structure details","title":"Data structure details","text":"Here are the main structs that comprise an aircraft object.","category":"page"},{"location":"data_io/structs/#TASOPT.aircraft","page":"Data structure details","title":"TASOPT.aircraft","text":"aircraft\n\nA type representing a TASOPT aircraft model including, geometric, aerodynamic, propulsion system parameters. It is designed to hold information related to the aircraft's name, description, as well as different sets of parameters used for analysis and optimization.\n\nOverloads Base.summary to print a summary of the aircraft model.\n\nFields:\n\nname::String : Aircraft name (eg: \"Boeing 777\")      \ndescription::String : A brief description of the aircraft\noptions::TASOPT.Options : Configuration options for the aircraft\nparg::AbstractArray{Float64} : Geometry parameters                   \nparm::AbstractArray{Float64} : Mission parameters                    \npara::AbstractArray{Float64} : Aero parameters                       \npare::AbstractArray{Float64} : Engine parameters \nfuse_tank::fuselage_tank: fuselage fuel tank object\nfuselage::Fuselage: fuselage fuel tank object\nwing::Wing: wing object\nhtail::Tail: horizontal tail object\nvtail::Tail: vertical tail object\nengine::Engine: engine object\nlanding_gear::LandingGear: landing gear object\nfuselage::Fuselage : Fuselage layout, data, and parameters\nfuse_tank::fuselage_tank : Fuselage tank data and parameters (when applicable)\nwing::Wing : Wing data and parameters\nhtail::Tail : Horizontal tail data and parameters\nvtail::Tail : Vertical tail data and parameters\nengine::Engine : Engine models, data, and parameters\n\nThe indices for accessing specific data in the par arrays are defined in /src/data_structs/index.inc.  Refer to the sample input file (/example/defaults/default_input.toml and read_input.jl) for usage. Refer to the docs for a summary of the main structs.\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.Options","page":"Data structure details","title":"TASOPT.Options","text":"mutable struct Options\n\nField of an aircraft containing configuration-level design choices.\n\nopt_fuel::String: Fuel type (e.g., Jet-A, LH2)\nifuel::Integer: Fuel option index (non-driving; determined and used by gas calcs)\nhas_centerbox_fuel::Bool: Indicates presence of centerbox fuel tank, can only be true if haswingfuel is true\nhas_wing_fuel::Bool: Indicates presence of wing fuel tanks\nhas_fuselage_fuel::Bool: Indicates presence of fuselage fuel tanks (non-driving; set by fuse_tank inputs)\nopt_engine_location::String: Engine location (\"wing\", \"fuselage\")\nopt_prop_sys_arch::String: Propulsion system architecture (e.g., \"tf\" for turbofan, \"te\" for turboelectric), performance and weight models set in ac.Engine\nis_doubledecker::Bool: Indicates if the aircraft has a double-decker fuselage configuration\nopt_move_wing::String: Move wingbox selection for longitudinal stability analysis. \"fixed\" = static wing position ,\"fixedCLh\" move wing to get CLh=\"CLhspec\" in cruise, \"minstatic_margin\" = move wing to get min static margin = \"SMmin\"\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.structures.Fuselage","page":"Data structure details","title":"TASOPT.structures.Fuselage","text":"mutable struct Fuselage\n\nFuselage Structure:     Divided into 5 modules     1. General Properties     2. Internal Structure     3. External Loads     4. Fuselage Layout     5. Misc Properties\n\nweight::Float64: Fuselage Weight [N]\nvolume::Float64: Fuselage Volume [m^3]\nmoment::Float64: Fuselage Weight [Nm^3]\nlayout::TASOPT.structures.FuselageLayout: Fuselage Layout\ncabin::TASOPT.structures.Cabin: Cabin Properties\nmaterial::StructuralAlloy: Fuselage Material\nskin::TASOPT.structures.StructuralMember: Structural Members\nshell::TASOPT.structures.StructuralMember\ncone::TASOPT.structures.StructuralMember\nfloor::TASOPT.structures.StructuralMember: Internal Members\ninsulation::TASOPT.structures.Weight\nwindow::TASOPT.structures.Weight\nfloor_W_per_area::Float64\ninsulation_W_per_area::Float64\nwindow_W_per_length::Float64\nbendingmaterial_h::TASOPT.structures.StructuralMember: Bending Material\nbendingmaterial_v::TASOPT.structures.StructuralMember\nAPU::TASOPT.structures.Weight: External Weights\nseat::TASOPT.structures.Weight\nadded_payload::TASOPT.structures.Weight\nHPE_sys::TASOPT.structures.Weight\nfixed::TASOPT.structures.Weight\nn_decks::Int64: Number of decks in fuselage\nweight_frac_stringers::Float64: Fuselage Weight fraction of stringers\nweight_frac_frame::Float64: Fuselage Weight fraction of frame\nweight_frac_skin_addl::Float64: Fuselage Weight fraction of additional weights on skin\nratio_young_mod_fuse_bending::Float64: Fuselage Shell Modulus Ratio Ebend/Eskin\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.fuselage_tank","page":"Data structure details","title":"TASOPT.fuselage_tank","text":"mutable struct fuselage_tank\n\nFuselage tank component. Usually for Hydrogen aircraft\n\nfueltype::String: Fuel type name\ntank_count::Int64: Fuel tank count\nplacement::String: Fuel tank location\nsizes_insulation::Bool: Flag for insulation sizing\nWfuelintank::Float64: Weight of fuel in one tank (N)\nclearance_fuse::Float64\nt_insul::Vector{Float64}: Vector with insulation layer thickness (m)\nmaterial_insul::Vector{ThermalInsulator}: Vector with insulation materials\niinsuldes::Vector{Int64}: Vector with insulation layer design indices\ninner_material::StructuralAlloy: Inner vessel material\nouter_material::StructuralAlloy: Outer vessel material\nARtank::Float64: Tank head aspect ratio\ntheta_inner::Float64: Angular location of inner vessel stiffeners\ntheta_outer::Vector{Float64}: Vector with angular location of outer vessel stiffeners\nNinterm::Float64: Number of intermediate stiffeners in outer vessel\npvent::Float64: Venting pressure (Pa)\npinitial::Float64: Fill pressure (Pa)\npmin::Float64: Minimum allowable tank pressure (Pa)\nt_hold_orig::Float64: Departure hold time (s)\nt_hold_dest::Float64: Arrival hold time (s)\nTSLtank::Float64: Sea-level temperature used to design tank (K)\nrhofuel::Float64: Liquid fuel density (kg/m^3)\nTfuel::Float64: Liquid fuel temperature in tank (K)\nrhofuelgas::Float64: Gas fuel density (kg/m^3)\nhvap::Float64: Fuel specific enthalpy of vaporization (J/kg)\nboiloff_rate::Float64: Percentage tank boiloff rate at start of cruise (%/h)\nftankadd::Float64: Vessel additional mass fraction\new::Float64: Vessel weld efficiency\nullage_frac::Float64: Minimum ullage fraction\nqfac::Float64: Heat leakage factor\npfac::Float64: Pressure rise factor\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.structures.Wing","page":"Data structure details","title":"TASOPT.structures.Wing","text":"mutable struct Wing{air<:TASOPT.aerodynamics.airfoil} <: TASOPT.structures.AbstractWing\n\nThe Wing structure is composed of 6 sub-structures as follow and are visualized here.\n\nGeneral Properties\nWing Layout\nMaterial\nWing Sections\nStrut\nWeight Fractions\n\nSee structures.WingSection, structures.WingLayout or structures.WingCrossSection for more detail.\n\nweight::Float64: Wing Weight [N]\ndxW::Float64: Aircraft pitching moment contribution from the weight distribution of the wing [Nm]\nlayout::TASOPT.structures.WingLayout: Wing Layout\nmaterial::StructuralAlloy: Wing Material\nairsection::TASOPT.aerodynamics.airfoil: Airfoil data\ninboard::TASOPT.structures.WingSection: Inboard Wing Section (at wing root)\noutboard::TASOPT.structures.WingSection: Outboard Wing Section (at strut attachment point)\nfuse_lift_carryover::Float64: Fuselage lift carryover factor\ntip_lift_loss::Float64: Tip lift roll-off factor\nmean_aero_chord::Float64: Mean Aerodynamic Chord\nhas_strut::Bool: Wing Strut\nstrut::TASOPT.structures.Strut\nweight_frac_flap::Float64: Wing flap weight fraction\nweight_frac_slat::Float64: Wing slats weight fraction\nweight_frac_ailerons::Float64: Wing ailerons weight fraction\nweight_frac_leading_trailing_edge::Float64: Wing leadingtrailingedge weight fraction\nweight_frac_ribs::Float64: Wing ribs weight fraction\nweight_frac_spoilers::Float64: Wing spoilers weight fraction\nweight_frac_attachments::Float64: Wing attachments weight fraction\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.structures.Tail","page":"Data structure details","title":"TASOPT.structures.Tail","text":"mutable struct Tail <: TASOPT.structures.AbstractWing\n\nTail\n\nlayout::TASOPT.structures.WingLayout: Tail Layout\noutboard::TASOPT.structures.WingSection: Tail Sections\ninboard::TASOPT.structures.WingSection\nhas_strut::Bool: Tail Strut\nstrut::TASOPT.structures.Strut\ntip_lift_loss::Float64: Tip lift roll-off factor\ndxW::Float64: Aircraft pitching moment contribution from the weight distribution of the strut [N m]\nweight::Float64: Tail Weight [N]\nweight_fraction_added::Float64: Tail Added Weight Fraction\nCL_max::Float64: Tail Max CL\nvolume::Float64: Tail Volume [m^3]\nopt_sizing::String: Tail Sizing assumption selection - different for HTail vs VTail\ndownwash_factor::Float64: Tail Downwash factor dε/dα\nCL_max_fwd_CG::Float64: Tail max fwd CG (only used if optsizing == \"CLmaxfwdCG\" for HTail)\nSM_min::Float64: Tail Minimum static margin\nCL_CLmax::Float64: Max Tail down load. Tail download param at max load case\nntails::Float64: Number of Tails\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.engine.Engine","page":"Data structure details","title":"TASOPT.engine.Engine","text":"mutable struct Engine{M<:TASOPT.engine.AbstractModel}\n\nEngine and models\n\nmodel::TASOPT.engine.AbstractModel\ndata::TASOPT.engine.AbstractData: Engine data storage\nheat_exchangers::Array{TASOPT.engine.HX_struct}: Heat exchanger parameters and data\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#Subordinate-structs","page":"Data structure details","title":"Subordinate structs","text":"","category":"section"},{"location":"data_io/structs/","page":"Data structure details","title":"Data structure details","text":"The above structs are in turn partially composed of subordinate structs, including some to represent materials, geometric layouts, and airfoil aerodynamic performance. ","category":"page"},{"location":"data_io/structs/","page":"Data structure details","title":"Data structure details","text":"Users shouldn't need to mess with these, but a few for reference:","category":"page"},{"location":"data_io/structs/#TASOPT.structures.FuselageLayout","page":"Data structure details","title":"TASOPT.structures.FuselageLayout","text":"mutable struct FuselageLayout <: TASOPT.structures.AbstractLayout\n\nFuselage Layout Structure: Contains dimensions, heights, etc. to design a fuselage\n\ncross_section::TASOPT.structures.AbstractCrossSection: Cross section definition\nthickness_webs::Float64: Thickness of webs\nx_nose::Float64: X position of nose [m]\nx_pressure_shell_fwd::Float64: X position of pressure shell forward [m]\nx_pressure_shell_aft::Float64: X position of pressure shell aft [m]\nx_start_cylinder::Float64: X position of cylinder start [m]\nx_end_cylinder::Float64: X position of cylinder end [m]\nx_cone_end::Float64: X position of fuselage cone end [m]\nx_end::Float64: X position of fuselage end [m]\ntaper_tailcone::Float64: Tailcone taper (lambdac) [m]\nfloor_depth::Float64: Floor depth (depth of floor beams) [m]\nnose_radius::Float64: Nose Radius [m]\ntail_radius::Float64: Tail Radius [m]\nopt_tapers_to::String: Taper fuselage to \"point\" or \"edge\"\nl_cabin_cylinder::Float64: Length of cylindrical portion of cabin that contains payload [m]\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.structures.Cabin","page":"Data structure details","title":"TASOPT.structures.Cabin","text":"mutable struct Cabin <: TASOPT.structures.AbstractCabin\n\nCabin Layout Structure: Contains seating dimensions and quantities to design a cabin layout\n\nexit_limit::Int64: Maximum number of passengers\nseat_pitch::Float64: Longitudinal seat pitch [m]\nseat_width::Float64: Transverse seat width [m]\nseat_height::Float64: Seat height [m]\naisle_halfwidth::Float64: Aisle half-width [m]\nfloor_distance::Float64: Distance between double decker floors [m]\nmin_top_cabin_height::Float64: Top cabin minimum height [m]\ncabin_width_main::Float64: Main cabin width [m]\ncabin_width_top::Float64: Top cabin width [m]\nseats_abreast_main::Int64: Number of seats abreast in main cabin\nseats_abreast_top::Int64: Number of seats abreast in top cabin\nfloor_angle_main::Float64: Floor angle of main cabin [rad]\nfloor_angle_top::Float64: Floor angle of top cabin [rad]\nfront_seat_offset::Float64: Front cabin offset before seats [m]\nrear_seat_offset::Float64: Rear cabin offset after seats [m]\nunit_load_device::String: Unit load device type\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.structures.StructuralMember","page":"Data structure details","title":"TASOPT.structures.StructuralMember","text":"mutable struct StructuralMember\n\nStructuralMember: Contains structural and material properties of structural members \n\nmaterial::StructuralAlloy: Material: Automatically sets stress and density of StructuralMember [StructuralAlloy]\nweight::TASOPT.structures.Weight: Weight\nEIh::Float64: Horizontal/Bending Stiffness [N m^2]\nEIv::Float64: Vertical/Normal Stiffness [N m^2]\nGJ::Float64: Torsional Rigidity [N m^2]\nthickness::Float64: Thickness [m]\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.structures.WingLayout","page":"Data structure details","title":"TASOPT.structures.WingLayout","text":"Wing layout is a structure that defines the wing planform. See WingSection and WingCrossSection as well.\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.structures.WingSection","page":"Data structure details","title":"TASOPT.structures.WingSection","text":"mutable struct WingSection <: TASOPT.structures.AbstractWingSection\n\nWing Section\n\ncross_section::TASOPT.structures.WingCrossSection: Wing Section layout\nco::Float64: Starting section chord [m]\nλ::Float64: Taper ratio λ = cend/cstart\nwebs::TASOPT.structures.StructuralMember: Wing Section webs\ncaps::TASOPT.structures.StructuralMember: Wing Section caps\nEI::Matrix{Float64}: Bending Stiffness EI matrix [N m^2]\nGJ::Float64: Torsional Stiffness GJ [N m^2]\nmax_shear_load::Float64: Max shear load [N]\nmoment::Float64: Moment [N m]\nweight::Float64: Weight [N]\ndyW::Float64: Wing root moment contribution from wing weight section of engine [N m]\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.structures.WingCrossSection","page":"Data structure details","title":"TASOPT.structures.WingCrossSection","text":"mutable struct WingCrossSection\n\nStores all the non-dimensional parameters  in the normal-plane cross section of the wing (mainly related to the spar-box) Cross-section of wing box:          \n\n                ┌──────────────────────────────────────┐        \n            ┌──┘               ▲                      └──┐     \n        ▲┌──┘                  │                         └──┐  \nweb height ││               spar box height                  ││  \n        ▼└──┐                  │                         ┌──┘  \n            └──┐               ▼                      ┌──┘     \n                └──────────────────────────────────────┘        \n            ◄───────────────── box width ──────────────────────►   \n◄───────────────────────────── c⟂ ──────────────────────────────────►\n\nthickness_to_chord::Float64: Wing section's spar box height to perpendicular chord (c⟂) [-]\nwidth_to_chord::Float64: Wing section's spar box width to c⟂[-]\nweb_to_box_height::Float64: Wing section's web height to max box height [-]\nt_cap::Float64: Sparbox cap normalized thickness (i.e., h_cap/c⟂) [-]\nt_web::Float64: Sparbox web normalized thickness\nA_internal::Float64: Internal Area normalized by chord2\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.aerodynamics.airfoil","page":"Data structure details","title":"TASOPT.aerodynamics.airfoil","text":"airfoil\n\nA type representing a database of pre-computed airfoil data for a single Reyolds number  and a range of Mach numbers, sectional lift coefficients, and thickness-to-chord ratios. By default, this is the original TASOPT transonic airfoil, as modelled by M. Drela in MSES and stored in src/air/.\n\nOverloads Base.show to print a summary of the airfoil model.\n\nFields:\n\nMa::AbstractVector{Float64} :  Mach nos.\ncl::AbstractVector{Float64} :  Sectional lift coefficients.\nτ::AbstractVector{Float64} :  Thickness-to-chord ratios.\nRe::Float64 :  Reynolds number.\nA::AbstractArray{Float64}: Multi-dimensional array of aero performance data.\n\nVarious views of the data:\n\nA_M::AbstractArray{Float64}:\nA_τ::AbstractArray{Float64}:\nA_cl::AbstractArray{Float64}:\nA_M_τ::AbstractArray{Float64}:\nA_M_cl::AbstractArray{Float64}:\nA_cl_τ::AbstractArray{Float64}:\nA_M_cl_τ::AbstractArray{Float64}:\n\nSee also airfun and airtable.\n\n\n\n\n\n","category":"type"},{"location":"data_io/structs/#TASOPT.materials.StructuralAlloy","page":"Data structure details","title":"TASOPT.materials.StructuralAlloy","text":"mutable struct StructuralAlloy\n\nGeneric structural alloy.\n\nname::String: Name\nρ::Float64: Density [kg/m³]\nE::Float64: Young's Modulus [Pa]\nG::Float64: Shear Modulus [Pa]\nν::Float64: Poisson's Ratio [-]\nσmax::Float64: Maximum Stress (Yield or Ultimate Strength) [Pa]\nτmax::Float64: Maximum Shear [Pa]\nYTS::Float64: Yield tensile strength [Pa]\nUTS::Float64: Ultimate tensile strength [Pa]\nUSS::Float64: Ultimate shear strength [Pa]\nk::Float64: Thermal conductivity [W/(m K)]\n\n\n\n\n\n","category":"type"},{"location":"aero/theory_lifting/","page":"-","title":"-","text":"details: 📖 Theory - Wing lift distribution\nThe lift distribution \"taper ratios\" are defined using local section c_ell factors r_c_ell s and r_c_ell t. beginaligned\ngamma_s  =  r_c_ell s  lambda_s \n\ngamma_t  =  r_c_ell t  lambda_t \n\nfracp scriptstyle (eta)p_o  equiv  \nP scriptstyle (eta    eta_oeta_s gamma_sgamma_t)\n =  \nleft\nbeginarraylcl\n 1    0  eta  eta_o \n05em\ndisplaystyle\n     1 + (gamma_s- 1)  fraceta - eta_oeta_s-eta_o \n   eta_o  eta  eta_s \n025em\ndisplaystyle\ngamma_s + (gamma_t-gamma_s) fraceta - eta_s1-eta_s \n   eta_s  eta  1\nendarray\nright\nlabelpeta\nendalignedTo get the actual aerodynamic load tildep, lift corrections Delta L_o and Delta L_t are applied to account for the fuselage carryover and tip lift rolloff, as sketched in the figure above. The detailed shapes of these modifications are not specified, but instead only their integrated loads are defined by the following integral relation.beginaligned\nfracL_rm wing2  = \nint_0^b2  tildep  rm dy  =  int_0^b2  p  rm dy\n+ Delta L_o\n+ Delta L_t\nendalignedThe corrections are specified in terms of the center load magnitude p_o and the f_L_scriptstyle o f_L_scriptstyle t adjustment factors.beginaligned\nDelta L_o  =  f_L_scriptstyle o p_o  fracb_o2 \n= f_L_scriptstyle o p_o  fracb2  eta_o\nlabelDLo\n025em\nDelta L_t  =  f_L_scriptstyle t p_t  c_t \n= f_L_scriptstyle t p_o  c_o  gamma_t lambda_t\nlabelDLt\n05em\nf_L_scriptstyle o simeq  -05\n\nf_L_scriptstyle t simeq  -005\nendalignedLift load magnitude (Wing only)The wing's p_o center loading magnitude is determined by requiring that the aerodynamic loading integrated over the whole span is equal to the total weight times the load factor, minus the tail lift.beginaligned\nL_rm total = 2 int_0^b2 tildepscriptstyle (eta) rm dy = \np_o  b int_0^1 Pscriptstyle (eta) rm deta + 2 Delta L_o\n+ 2 Delta L_t \n= N W - (L_rm htail)_N\nhspace2em\nlabeltotlift\nendalignedFor structural sizing calculations N = N_rm lift is chosen, and the appropriate value of (L_rm htail)_N is the worst-case (most negative) tail lift expected in the critical sizing case. One possible choice is the trimmed tail load at dive speed, where N_rm lift is most likely to occur.The wing area S_def and aspect ratio AR_def definitions allow the root chord and the tip lift drop Delta L_t to be expressed as beginaligned\nc_o  =  b  K_o\n\nDelta L_t  =  \nf_L_scriptstyle t p_o  b  K_o  gamma_t lambda_t\nlabelDLt2\n\nmathrmwhere hspace2em\nK_o equiv frac1K_c  Ahspace-05exR \nendalignedso that L_rm total can be evaluated to the following. The Pscriptstyle (eta) integrals have the form as for Cscriptstyle (eta), given by int_0^eta_o C  rm deta – int_eta_s^1 C^2  (eta-eta_s)  rm deta, but with the lambda's replaced by gamma's.beginaligned\np_o  b  K_p  =  N W - (L_rm htail)_N hspace2em\n\nmathrmwhere hspace3em\nK_p  = \neta_o + textstyle frac12(1 + gamma_s) (eta_s - eta_o)\n    + textstyle frac12(gamma_s + gamma_t) (1 - eta_s)\nnonumber \n +  f_L_scriptstyle oeta_o + 2 f_L_scriptstyle tK_o gamma_tlambda_t \nhspace2em\nendalignedThe root and planform-break loadings can then be explicitly determined. beginaligned\np_o  =  fracN W - (L_rm htail)_NK_p  b \nlabelpodef\n\np_s  = p_o  gamma_s\n\np_t  = p_o  gamma_t\nendaligned","category":"page"},{"location":"propulsion/propsys/#Propulsion-system","page":"Propulsion system","title":"Propulsion system","text":"","category":"section"},{"location":"propulsion/propsys/","page":"Propulsion system","title":"Propulsion system","text":"A turbofan model is provided in TASOPT.jl","category":"page"},{"location":"propulsion/propsys/#Turbofan-model","page":"Propulsion system","title":"Turbofan model","text":"","category":"section"},{"location":"propulsion/propsys/#TASOPT.engine.tfcalc!","page":"Propulsion system","title":"TASOPT.engine.tfcalc!","text":"tfcalc!(wing, engine, parg, para, pare, ip, ifuel, opt_calc_call, opt_cooling, initializes_engine)\n\nCalls on-design sizing function tfsize! or off-design analysis function tfoper! for one operating point ip.\n\ndetails: 🔃 Inputs and Outputs\nInput:opt_calc_call:\n\"sizing\": call on-design sizing routine tfsize!\n\"oper_fixedTt4\": call off-design analysis routine tfoper! with specified Tt4\n\"oper_fixedFe\": call off-design analysis routine tfoper! with specified net thrust (Fe)\nopt_cooling: turbine cooling flag\n\"none\": no cooling mass flow\n\"fixed_coolingflowratio\": use specified cooling flow ratios epsrow(.); calculate Tmrow(.)\n\"fixed_Tmetal\": use specified metal temperatures Tmrow(.); calculate epsrow(.)\ninitializes_engine:\ntrue: initialize variables for iteration in tfoper!\nfalse: use current variables as initial guesses in tfoper!\n\n\n\n\n\n","category":"function"},{"location":"propulsion/propsys/#TASOPT.engine.tfsize!","page":"Propulsion system","title":"TASOPT.engine.tfsize!","text":"tfsize!(gee, M0, T0, p0, a0, M2, M25,\n  Feng, Phiinl, Kinl, eng_has_BLI_cores,\n  BPR, pif, pilc, pihc,\n  pid, pib, pifn, pitn,\n  Ttf, ifuel, etab,\n  epf0, eplc0, ephc0, epht0, eplt0,\n  mofft, Pofft,\n  Tt9, pt9, Tt4,\n  epsl, epsh,\n  opt_cooling,\n  Mtexit, dTstrk, StA, efilm, tfilm,\n  fc0, epht_fc,\n  M4a, ruc,\n  ncrowx, ncrow,\n  epsrow, Tmrow, \n  Δh_PreC, Δh_InterC, Δh_Regen, Δh_TurbC,\n  Δp_PreC, Δp_InterC, Δp_Regen)\n\nTurbofan performance and sizing routine.\n\nCalculation procedure follows that of Kerrebrock, but the usual gas property formulas are replaced by function calls (described in Gas Calculations), which can therefore implement more general gas models. In addition, a turbine cooling model is added.\n\ndetails: 🔃 Inputs and Outputs\nInputs:gee:     gravity acceleration\nM0:      freestream Mach\nT0:      freestream temperature  [K]\np0:      freestream pressure  [Pa]\nM2:      fan-face Mach number\nM25:     HPC-face Mach number\nFeng:    required net thrust  (PKinl+PKout-Phi_jet)/u0  =  sum( mdot u)\nPhiinl:  inlet ingested dissipation\neng_has_BLI_cores:   false=core in clear flow, true=core sees Phiinl\nBPR:     bypass ratio  = mdot_fan/mdot_core\npif:     fan      pressure ratio  ( = pt7 /pt2)\npilc:    LP comp  pressure ratio  ( = pt25/pt2)\npihc:    HP comp  pressure ratio  ( = pt3 /pt25)\npid:     diffuser pressure ratio  ( = pt2 /pt0)\npib:     burner   pressure ratio  ( = pt4 /pt3)\npifn:    fan     nozzle pressure ratio  ( = pt7/pt2.1)\npitn:    turbine nozzle pressure ratio  ( = pt5/pt4.9)\nTtf:     fuel temperature entering combustor\nifuel:   fuel index, see function gasfun\nhvap:    fuel enthalpy of vaporization (J/kg)\netab:    combustor efficiency (fraction of fuel burned)\nepf0:    fan max polytropic efficiency\neplc0:   LPC max polytropic efficiency\nephc0:   HPC max polytropic efficiency\nepht0:   HPT max polytropic efficiency\neplt0:   LPT max polytropic efficiency\nmofft:   mass flow offtake at LPC discharge station 2.5\nPofft:   low spool power offtake\nTt9:     offtake air discharge total temperature\npt9:     offtake air discharge total pressure\nepsl:    low  spool power loss fraction\nepsh:    high spool power loss fraction\nopt_cooling: turbine cooling flag\n\"none\" = no cooling, ignore all cooling parameters below\n\"fixed_coolingflowratio\" = usual cooling, using passed-in fcool\n\"fixed_Tmetal\" = usual cooling, but set (and return) fcool from Tmetal\nMtexit:   turbine blade-row exit Mach, for setting temperature drops\ndTstrk:   hot-streak temperature delta [K], used only if opt_cooling=\"fixed_Tmetal\"\nStA:      area-weighted Stanton number    , used only if opt_cooling=\"fixed_Tmetal\"\nM4a:      effective Mach at cooling-flow outlet (start of mixing)\nruc:      cooling-flow outlet velocity ratio, u/ue\nncrowx:      dimension of epsrow array\nncrow:       number of blade rows requiring cooling\nepsrow(.):   specified cooling-flow bypass ratio if opt_cooling=\"fixed_coolingflowratio\"\nTmrow(.):    specified metal temperature [K] if opt_cooling=\"fixed_Tmetal\"Outputs:epsrow(.):   resulting cooling-flow bypass ratio if opt_cooling=\"fixed_Tmetal\"\nTmrow(.):    resulting metal temperature [K] if opt_cooling=\"fixed_coolingflowratio\"\nTSFC:    thrust specific fuel consumption = mdot_fuel g / F   [1/s]\nFsp:     specific thrust  = F / (mdot u0) = F / ((1+BPR) mdot_core u0)\nhfuel:   fuel heating value   [J / kg K]\nff:      fuel mass flow fraction  =  mdot_fuel / mdot_core\nmcore:   core mass flow = mdot_core  [kg/s]\nA2:      fan-face area [m^2]\nA25:     HPC-face area [m^2]\nA5:      core nozzle area [m^2]\nA7:      fan  nozzle area [m^2]\nA6:      core plume  area [m^2]\nA8:      fan  plume  area [m^2]\nTt?:     total temperature\nht?:     total complete enthalpy (includes heat of formation)\npt?:     total pressure\ncpt?:    specific heat at stagnation temperature  (= dh/dT)\nRt?:     gas constant  at stagnation conditions\nT?:      static temperature\nu?:      velocity\nepf:     fan polytropic efficiency\neplc:    LPC polytropic efficiency\nephc:    HPC polytropic efficiency\nepht:    HPT polytropic efficiency\neplt:    LPT polytropic efficiency\netaf:    fan overall efficiency\netalc:   LPC overall efficiency\netahc:   HPC overall efficiency\netaht:   HPT overall efficiency\netalt:   LPT overall efficiency\nLconv:   true if convergence was successful, false otherwiseThe \"?\" symbol denotes the station index:0: freestream\n18: fan face outside of casing BLs\n19: fan face over LPC portion\n2: fan face over fan portion\n21: fan exit\n25: LPC exit, HPC inlet\n3: compressor exit\n4: combustor exit before cooling air addition\n41: turbine inlet after cooling air addition\n45: HPT exit, LPT inlet\n49: LPT exit\n5: core nozzle\n6: core flow downstream\n7: fan nozzle\n8: fan flow downstream\n\n\n\n\n\n","category":"function"},{"location":"propulsion/propsys/#TASOPT.engine.tfweight","page":"Propulsion system","title":"TASOPT.engine.tfweight","text":"tfweight(ac)\n\nEngine weight estimation function using Giulia Pantalone, Drela, or Fitzgerald model.\n\ndetails: 🔃 Inputs and Outputs\nInput:ac::aircraft: aircraft objectOutput:Weng: Total engine weight.\nWnac: Nacelle weight. \nWebare: Bare engine weight.\nSnace1: Nacelle area.\n\n\n\n\n\n","category":"function"},{"location":"propulsion/propsys/#Turbofan-Maps","page":"Propulsion system","title":"Turbofan Maps","text":"","category":"section"},{"location":"propulsion/propsys/#TASOPT.engine.Ncmap-NTuple{6, Any}","page":"Propulsion system","title":"TASOPT.engine.Ncmap","text":"Ncmap(pratio, mb, piD, mbD, NbD, Cmap)\n\nCalculates compressor or fan corrected speed as a function of pressure ratio and corrected mass flow\n\ndetails: 🔃 Inputs and Outputs\nInputs:pratio: pressure ratio \nmb:       corrected mass flow\npiD:      design pressure ratio\nmbD:      design corrected mass flow\nNbD:      design corrected speed\nCmap(.):  map constantsOutputs:Nb:     wheel speed\nNb_?:   derivatives\n\n\n\n\n\n","category":"method"},{"location":"propulsion/propsys/#TASOPT.engine.ecmap-NTuple{8, Any}","page":"Propulsion system","title":"TASOPT.engine.ecmap","text":"ecmap(pratio, mb, piD, mbD, Cmap, effo, piK, effK)\n\nCalculates compressor or fan efficiency as a function of pressure ratio and corrected mass flow\n\ndetails: 🔃 Inputs and Outputs\nInputs:pratio:        pressure ratio\nmb:        corrected mass flow\npiD:       design pressure ratio\nmbD:       design corrected mass flow\nCmap(.):   map constants\neffo:      maximum efficiency\npiK:       pi-dependence offset  eff = effo + effK*(pi-piK)\neffK:      pi-dependence slopeOutputs:eff:        efficiency\neff_?:      derivatives\n\n\n\n\n\n","category":"method"},{"location":"propulsion/propsys/#TASOPT.engine.Ncmap1-NTuple{9, Any}","page":"Propulsion system","title":"TASOPT.engine.Ncmap1","text":"Ncmap1(pratio, m, piD, mbD, NbD, ABCDm, iabcd, Tr, pr)\n\nCalculates compressor or fan efficiency as a function of pressure ratio and corrected mass flow\n\ndetails: 🔃 Inputs and Outputs\nInputs:pratio:        pressure ratio\nmb:        corrected mass flow\npiD:       design pressure ratio\nmbD:       design corrected mass flow\nNbD:      design corrected speed\nABCDm:   map constants\niabcd:   map exponents\nTr:      T/Tref\npr:      p/prefOutputs:N:        wheel speed\nN_?:      derivatives\n\n\n\n\n\n","category":"method"},{"location":"propulsion/propsys/#TASOPT.engine.ecmap1-NTuple{9, Any}","page":"Propulsion system","title":"TASOPT.engine.ecmap1","text":"ecmap1(pratio, m, piD, mbD, ABCDm, iabcd, effo, Tr, pr)\n\nCalculates compressor or fan efficiency as a function of pressure ratio and mass flow\n\ndetails: 🔃 Inputs and Outputs\nInputs:pratio:        pressure ratio\nmb:        corrected mass flow\npiD:       design pressure ratio\nmbD:       design corrected mass flow\nABCDm:   map constants\niabcd:   map exponents\neffo:     maximum efficiency\nTr:      T/Tref\npr:      p/prefOutputs:eff:        efficiency\neff_?:      derivatives\n\n\n\n\n\n","category":"method"},{"location":"propulsion/propsys/#TASOPT.engine.etmap-NTuple{11, Any}","page":"Propulsion system","title":"TASOPT.engine.etmap","text":"etmap(dh, mb, Nb, piD, mbD, NbD, ept0, Tmap, Tt, cpt, Rt)\n\nCalculates turbine efficiency as a function of work and corrected mass flow\n\ndetails: 🔃 Inputs and Outputs\nInputs:dh:        enthalpy change\nmb:        corrected mass flow\nNb:        corrected speed\npiD:      design pressure ratio\nmbD:      design corrected mass flow\nNbD:      design corrected speed\nept0:      turbine polytropic efficiency estimate\nTmap(.):   map constantsOutputs:eff:        efficiency\neff_?:      derivatives\n\n\n\n\n\n","category":"method"},{"location":"propulsion/propsys/#TASOPT.engine.Pimap-NTuple{6, Any}","page":"Propulsion system","title":"TASOPT.engine.Pimap","text":"Pimap(mb, Nb, piD, mbD, NbD, Cmap)\n\nCalculates compressor or fan pressure ratio as a function of pressure ratio and corrected mass flow\n\ndetails: 🔃 Inputs and Outputs\nInputs:mb:        corrected mass flow\nNb:        corrected speed\npiD:      design pressure ratio\nmbD:      design corrected mass flow\nNbD:      design corrected speed\nCmap(.):  map constantsOutputs:pratio:      pressure ratio\npi_?:    derivatives\n\n\n\n\n\n","category":"method"},{"location":"propulsion/propsys/#TASOPT.engine.tfoper!","page":"Propulsion system","title":"TASOPT.engine.tfoper!","text":"function tfoper!(gee, M0, T0, p0, a0, Tref, pref,\n  Phiinl, Kinl, eng_has_BLI_cores,\n  pid, pib, pifn, pitn,\n  Gearf,\n  pifD, pilcD, pihcD, pihtD, piltD,\n  mbfD, mblcD, mbhcD, mbhtD, mbltD,\n  NbfD, NblcD, NbhcD, NbhtD, NbltD,\n  A2, A25, A5, A7,\n  opt_calc_call,\n  Ttf, ifuel, etab,\n  epf0, eplc0, ephc0, epht0, eplt0,\n  mofft, Pofft,\n  Tt9, pt9,\n  epsl, epsh,\n  opt_cooling,\n  Mtexit, dTstrk, StA, efilm, tfilm,\n  M4a, ruc,\n  ncrowx, ncrow,\n  epsrow, Tmrow,\n  Feng,\n  M2, pif, pilc, pihc, mbf, mblc, mbhc, Tt4, pt5, mcore, M25)\n\nTurbofan operation routine. Calculation procedure follows that of Kerrebrock, but the usual gas property formulas are replaced by function calls, which can therefore implement more general gas models. In addition, a turbine cooling model is added.\n\nThe gas routines are described in Gas Calculations\n\ndetails: 🔃 Inputs and Outputs\nInputs:gee:     gravity acceleration\nM0:      freestream Mach\nT0:      freestream temperature  [K]\np0:      freestream pressure  [Pa]\nTref:    reference temperature for corrected mass flow and speed\npref:    reference pressure for corrected mass flow\nPhiinl:  inlet ingested dissipation  Phi_inl\neng_has_BLI_cores:\nfalse: core in clear flow\ntrue: core sees Phiinl\npid:     diffuser pressure ratio  ( = pt2/pt0)\npib:     burner   pressure ratio  ( = pt4/pt3)\npifn:    fan     nozzle pressure ratio  ( = pt7/pt6.9)\npitn:    turbine nozzle pressure ratio  ( = pt5/pt4.9)\nGearf:   fan gear ratio  ( = Nl/Nf )\npifD:    design fan pressure ratio  ( = pt21/pt2)\npilcD:   design LPC pressure ratio  ( = pt25/pt19)\npihcD:   design HPC pressure ratio  ( = pt3/pt25)\npihtD:   design HPT pressure ratio  ( = pt45/pt41)\npiltD:   design LPT pressure ratio  ( = pt49/pt45)\nmbfD:    design corrected fan mass flow ( = mf*sqrt(Tt2/Tref)/(pt2/pref) ) where mf = mc*BPR\nmblcD:   design corrected LPC mass flow ( = mc*sqrt(Tt19/Tref)/(pt19/pref) )\nmbhcD:   design corrected HLC mass flow ( = mc*sqrt(Tt25/Tref)/(pt25/pref) )\nmbhtD:   design corrected HPT mass flow ( = mt*sqrt(Tt41/Tref)/(pt41/pref) ) where mt = mc*(1+ff)\nmbltD:   design corrected LPT mass flow ( = mt*sqrt(Tt45/Tref)/(pt45/pref) )\nNbfD:    design corrected fan speed ( = Nf/sqrt(Tt2/Tref) )\nNblcD:   design corrected LPC speed ( = Nl/sqrt(Tt19/Tref) )\nNbhcD:   design corrected HPC speed ( = Nh/sqrt(Tt25/Tref) )\nNbhtD:   design corrected HPT speed ( = Nh/sqrt(Tt41/Tref) )\nNbltD:   design corrected LPT speed ( = Nl/sqrt(Tt45/Tref) )\nA2:      fan-face area [m^2]\nA25:     HPC-face area [m^2]\nA5:      core nozzle area [m^2]\nA7:      fan  nozzle area [m^2]\nopt_calc_call:\n\"oper_fixedTt4\": Tt4 is specified\n\"oper_fixedFe\": Feng is specified\nTt4:     turbine-inlet total temperature [K]\nTtf:     fuel temperature entering combustor\nifuel:   fuel index, see function gasfun\nhvap:    fuel enthalpy of vaporization (J/kg)\netab:    combustor efficiency (fraction of fuel burned)\nepf0:    max fan polytropic efficiency\neplc0:   LPC max polytropic efficiency\nephc0:   HPC max polytropic efficiency\nepht0:   HPT max polytropic efficiency\neplt0:   LPT max polytropic efficiency\nmofft:    mass flow offtake at LPC discharge station 2.5\nPofft:    low spool power offtake\nTt9:     offtake air discharge total temperature\npt9:     offtake air discharge total pressure\nepsl:    low  spool power loss fraction\nepsh:    high spool power loss fraction\nopt_cooling:   turbine cooling flag\n\"none\": no cooling, ignore all cooling parameters below\n\"fixed_coolingflowratio\": usual cooling, using passed-in fcool\n\"fixed_Tmetal\": usual cooling, but set (and return) fcool from Tmetal\nMtexit:   turbine blade-row exit Mach, for setting temperature drops\nTmetal:   specified metal temperature  [K], used only if opt_cooling=\"fixed_Tmetal\"\ndTstrk:   hot-streak temperature delta {K}, used only if opt_cooling=\"fixed_Tmetal\"\nStA:      area-weighted Stanton number    , used only if opt_cooling=\"fixed_Tmetal\"\nM4a:      effective Mach at cooling-flow outlet (start of mixing)\nruc:      cooling-flow outlet velocity ratio, u/ue\nncrowx:      dimension of epsrow array\nncrow:       number of blade rows requiring cooling\nepsrow(.): input specified  cooling-flow bypass ratio if opt_cooling=\"fixed_coolingflowratio\"; output resulting cooling-flow bypass ratio if opt_cooling=\"fixed_Tmetal\".\nTmrow(.): input specified metal temperature [K] if opt_cooling=\"fixed_Tmetal\"; output resulting metal temperature [K] if opt_cooling=\"fixed_coolingflowratio\"Output:epsrow(.):   see above\nTmrow(.):    see above\nTSFC:    thrust specific fuel consumption = mdot_fuel g / F   [1/s]\nFsp:     specific thrust  = F / (mdot u0) = F / ((1+BPR) mdot_core u0)\nhfuel:   fuel heating value   [J / kg K]\nff:      fuel mass flow fraction  =  mdot_fuel / mdot_core\nFeng:    net effective thrust  = (PK_inl+PK_out-Phi_jet)/u0  =  sum(mdot u)\nmcore:   core mass flow = mdot_core  [kg/s]\nBPR:     bypass ratio   = mdot_fan/mdot_core\nTt?:     total temperature\nht?:     total complete enthalpy (includes heat of formation)\npt?:     total pressure\ncpt?:    specific heat at stagnation temperature  (= dh/dT)\nRt?:     gas constant  at stagnation conditions\nT?:      static temperature\nu?:      velocity\netaf:    fan          overall efficiency\netac:    compressor   overall efficiency\netatf:   fan-turbine  overall efficiency\netatc:   comp-turbine overall efficiency\nLconv:   true if convergence was successful, false otherwiseThe \"?\" symbol denotes the station index:0: freestream\n18: fan face outside of casing BLs\n19: fan face over LPC portion\n2: fan face over fan portion\n21: fan exit, precooler inlet\n19c: precooler outlet, LPC inlet\n25: LPC exit, intercooler inlet\n25c: intercooler exit, HPC inlet\n3: compressor exit\n4: combustor exit before cooling air addition\n41: turbine inlet after cooling air addition\n45: HPT exit, LPT inlet\n49: LPT exit, regenerative cooler inlet\n49c: regenerative cooler outlet\n5: core nozzle\n6: core flow downstream\n7: fan nozzle\n8: fan flow downstream\n\n\n\n\n\n","category":"function"},{"location":"propulsion/propsys/#Turbofan-Cooling","page":"Propulsion system","title":"Turbofan Cooling","text":"","category":"section"},{"location":"propulsion/propsys/#TASOPT.engine.mcool-NTuple{9, Any}","page":"Propulsion system","title":"TASOPT.engine.mcool","text":"mcool(ncrowx, Tmrow, Tt3, Tt4, dTstreak, Trrat, efilm, tfilm, StA)\n\nCalculates cooling mass flow requirement.\n\ndetails: 🔃 Inputs and Outputs\nInputs:ncrowx:    dimension of Tmrow(.) and epsrow(.) arrays (max number of blade rows)\nTmrow(.):  design metal temperature for each blade row\nTt3:       cooling flow temperature\nTt4:       hot gas temperature from burner\ndTstreak:  hot-streak temperature increase over Tt4, for first blade row \nTrrat:     static temperature ratio across each blade row, T4.1 / T4\nefilm:     cooling efficiency = (Tco-Tci)/(Tmetal-Tci)\ntfilm:     film effectiveness = (Tgas-Tfaw)/(Tgas-Tco) where\nTco = temperature of cooling air exiting  blade\nTci = temperature of cooling air entering blade\nTfaw = film adiabatic wall temperature (for insulated-wall case)\nStA:        area-weighted external Stanton number =St (Asurf/Aflow) cpgas/cpcool`Output:ncrow:      number of blade rows which need cooling\nepsrow(.):  cooling mass flow ratio for each blade row, m_c_row/m_air\n\n\n\n\n\n","category":"method"},{"location":"propulsion/propsys/#TASOPT.engine.Tmcalc-NTuple{10, Any}","page":"Propulsion system","title":"TASOPT.engine.Tmcalc","text":"Tmcalc(ncrowx, ncrow, Tt3, Tt4, dTstreak, Trrat, efilm, tfilm, StA, epsrow)\n\nCalculates metal temperature for blade row\n\ndetails: 🔃 Inputs and Outputs\nInputs:ncrowx:    dimension of Tmrow(.),epsrow(.) arrays (max number of blade rows)\nncrow:     number of blade rows which are cooled\nepsrow(.):  cooling mass flow ratio for each blade row, mcrow/m_air\nTt3:       cooling flow temperature\nTt4:       hot gas temperature from burner\ndTstreak:  hot-streak temperature increase over Tt4, for first blade row \nTrrat:     static temperature ratio across each blade row, T4.1 / T4\nefilm:     cooling efficiency = (Tco-Tci)/(Tmetal-Tci)\ntfilm:     film effectiveness = (Tgas-Tfaw)/(Tgas-Tco)              Tco = temperature of cooling air exiting  blade              Tci = temperature of cooling air entering blade              Tfaw = film adiabatic wall temperature (for insulated-wall case)\nStA:       area-weighted external Stanton number = St (Asurf/Aflow) cpgas/cpcool\nOutput:\nTmrow(.):  design metal temperature for each blade row\n\n\n\n\n\n","category":"method"},{"location":"propulsion/propsys/#Turbomachinery-Components","page":"Propulsion system","title":"Turbomachinery Components","text":"","category":"section"},{"location":"propulsion/propsys/","page":"Propulsion system","title":"Propulsion system","text":"The compressor off-design performance is determined by interpolation to the compressor maps in pyCycle[1]. The compressor parameters are scaled to the design pressure ratios, speeds, and mass flow rates in the pyCycle maps by using","category":"page"},{"location":"propulsion/propsys/","page":"Propulsion system","title":"Propulsion system","text":"    tildep = fracpi -1pi_D -1","category":"page"},{"location":"propulsion/propsys/","page":"Propulsion system","title":"Propulsion system","text":"    tildem = fracbarmbarm_D","category":"page"},{"location":"propulsion/propsys/","page":"Propulsion system","title":"Propulsion system","text":"    tildeN = fracbarNbarN_D","category":"page"},{"location":"propulsion/propsys/","page":"Propulsion system","title":"Propulsion system","text":"where pi represents the pressure ratio, barm is the corrected mass flow rate, barN is the corrected speed, and the subscript D denotes the design values. For a given set of compressor parameters, the normalized parameters tildep, tildem, and tildeN are used to calculate the dimensional values in the pyCycle map space. ","category":"page"},{"location":"propulsion/propsys/","page":"Propulsion system","title":"Propulsion system","text":"The pyCycle maps contain data for pressure ratio, corrected mass flow rate, and isentropic efficiency as a function of corrected speed and R-line parameter. However, the turbofan operation function, tfoper!(), is set up so that the polytropic efficiency and corrected speed is calculated from the pressure ratio and corrected mass flow rate. Therefore, a reverse interpolation problem is required to compute these parameters. For this, the compressor maps are extrapolated and a standard non-linear solver is used in find_NR_inverse_with_derivatives() to calculate the corrected speed and R-line parameter that correspond to given corrected mass flow rate and pressure ratio. The extrapolated pressure ratio and polytropic efficiency maps are shown below. These parameters are then translated to the scaled map by using tildep, tildem, and tildeN in calculate_compressor_speed_and_efficiency(), which also returns the polytropic efficiency and derivatives.","category":"page"},{"location":"propulsion/propsys/","page":"Propulsion system","title":"Propulsion system","text":"(Image: PEMfig) (Image: PEMfig)","category":"page"},{"location":"propulsion/propsys/#TASOPT.engine.calculate_compressor_speed_and_efficiency","page":"Propulsion system","title":"TASOPT.engine.calculate_compressor_speed_and_efficiency","text":"calculate_compressor_speed_and_efficiency(map, pratio, mb, piD, mbD, NbD, epol0; Ng=0.5, Rg=2.0)\n\nCalculates corrected speed and polytropic efficiency for a compressor, along with derivatives to pressure ratio and mass flow.\n\ndetails: 🔃 Inputs and Outputs\nInputs:map::CompressorMap: structure containing the compressor map and interpolations.\npratio::Float64: compressor pressure ratio.\nmb::Float64: current mass flow rate.\npiD::Float64: design pressure ratio.\nmbD::Float64: design mass flow rate.\nNbD::Float64: design rotational speed.\nepol0::Float64: maximum polytropic efficiency.\nNg::Float64: initial guess for normalized speed (optional).\nRg::Float64: initial guess for R-line (optional).Outputs:Nb::Float64: corrected compressor speed.\nepol::Float64: polytropic efficiency.\ndNb_dpi::Float64: derivative of corrected speed w.r.t. piD.\ndNb_dmb::Float64: derivative of corrected speed w.r.t. mb.\ndepol_dpi::Float64: derivative of efficiency w.r.t. piD.\ndepol_dmb::Float64: derivative of efficiency w.r.t. mb.\nN::Float64: matched normalized speed.\nR::Float64: matched R-line.\n\n\n\n\n\n","category":"function"},{"location":"propulsion/propsys/#TASOPT.engine.find_NR_inverse_with_derivatives","page":"Propulsion system","title":"TASOPT.engine.find_NR_inverse_with_derivatives","text":"find_NR_inverse_with_derivatives(itp_Wc, itp_PR, Wc_target, PR_target; Ng=0.5, Rg=2.0)\n\nFinds the normalized speed N and R-line R corresponding to a target corrected mass flow Wc_target and pressure ratio PR_target, using a nonlinear solver with Jacobian information from interpolation gradients.\n\ndetails: 🔃 Inputs and Outputs\nInputs:itp_Wc::GriddedInterpolation: interpolation of corrected mass flow over (N, R).\nitp_PR::GriddedInterpolation: interpolation of pressure ratio over (N, R).\nWc_target::Float64: target corrected mass flow.\nPR_target::Float64: target pressure ratio.\nNg::Float64: initial guess for normalized speed (optional).\nRg::Float64: initial guess for R-line (optional).Outputs:N::Float64: normalized speed at the matched point.\nR::Float64: R-line value at the matched point.\ndN_dw::Float64: ∂N/∂Wc\ndN_dpr::Float64: ∂N/∂PR\ndR_dw::Float64: ∂R/∂Wc\ndR_dpr::Float64: ∂R/∂PR\n\n\n\n\n\n","category":"function"},{"location":"propulsion/propsys/","page":"Propulsion system","title":"Propulsion system","text":"[1]: https://github.com/OpenMDAO/pyCycle","category":"page"},{"location":"data_io/data_io/#Loading-and-saving-models","page":"Loading and saving models","title":"Loading and saving models","text":"","category":"section"},{"location":"data_io/data_io/#TOML-input-files","page":"Loading and saving models","title":"TOML input files","text":"","category":"section"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"TASOPT models can be loaded from and saved to human-readable TOML files via read_aircraft_model() and save_aircraft_model(). These scripts are written to process files based on the /example/defaults/default_input.toml, as is done when load_default_model() is run; they are usable for simple cases that alter the default inputs. For larger deviations from the default (e.g., mission-specific aero or engine performance), customized scripts are recommended when not required.","category":"page"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"Once it is loaded in this fashion, the aircraft can be manipulated and re-sized. Note: TOML-based saves do not store the performance of the sized model, so a model must be sized before data can be referenced usefully:","category":"page"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"using TASOPT\n\ninclude(__TASOPTindices__)  #import array indices from ./src/data_structs/index.inc, including igTmetal\n\nfilepath = \"/path/to/your/aircraft.toml\"\nac = read_aircraft_model(filepath)   #creates new aircraft using default input .toml\nsize_aircraft!(ac)\n\nac.parg[igTmetal] = 2000    #set max metal temp to 2000 K\nsize_aircraft!(ac)          #resizing after parameter change","category":"page"},{"location":"data_io/data_io/#Quicksave-and-quickload-to-.jld2","page":"Loading and saving models","title":"Quicksave and quickload to .jld2","text":"","category":"section"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"Complete aircraft structs can also be serialized to JLD2 files by calling quicksave_aircraft(). Though inscrutable to the human eye, these saves capture ALL elements of the aircraft and can be loaded via quickload_aircraft() to a fresh REPL in an already-sized state.","category":"page"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"#load and size the default aircraft model\nusing TASOPT\nac2 = load_default_model()\nsize_aircraft!(ac2)\n\n#quicksave aircraft\nfilepath2 = \"/path/to/your/new/quicksave.toml\"\nquicksave_aircraft(ac2, filepath2)\n\n#quickload aircraft, ready to pull results\nac2 = quickload_aircraft(filepath2)","category":"page"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"","category":"page"},{"location":"data_io/data_io/#Output-data-to-CSV","page":"Loading and saving models","title":"Output data to CSV","text":"","category":"section"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"aircraft data can be saved to CSVs via output_csv(), where each column will be a par array quantity and each row can be a different aircraft or case. This is especially useful for post-processing of parameter sweeps.","category":"page"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"The data that is output can be customized by specifying individual par array quantities, flight points, or missions. By default, only the first cruise point of the design mission is output for a representative set of values (i.e., those in default_output_indices). ","category":"page"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"For ease of use, the default behavior is to create or append to the file at the user-given filepath, though if the requested indices are changed, a new file will be created to avoid inconsistency. This file will also appendable without further input. Overwrite behavior can also be specified.","category":"page"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"The following example shows the basic functionalities for a parameter sweep. See the output_csv() docstring for details.","category":"page"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"# Sweeping a parameter space and outputting each design\nusing TASOPT\ninclude(__TASOPTindices__) #import par array indices, including igTmetal\nac = load_default_model()\nfilepath = \"path/to/your/newfile.csv\"\n\n#set up sweep of max metal temp in engine\nTmetals = [1800, 1850, 1900, 1950] # Kelvin\nfor Tmetal in Tmetals\n    \n    ac.parg[igTmetal] = Tmetal\n    size_aircraft!(ac)\n\n    #output default quantities, appending each time\n    output_csv(ac, filepath) \n    #output with more engine quantities and with data at all flight points\n    #due to inconsistent headings at filepath, a new file will be created and appended to\n    output_csv(ac, filepath, indices = output_indices_wEngine, includeMissions = true)  \nend","category":"page"},{"location":"data_io/data_io/","page":"Loading and saving models","title":"Loading and saving models","text":"","category":"page"},{"location":"data_io/data_io/#IO-Functions","page":"Loading and saving models","title":"IO Functions","text":"","category":"section"},{"location":"data_io/data_io/#TASOPT.read_aircraft_model-Tuple{}","page":"Loading and saving models","title":"TASOPT.read_aircraft_model","text":"read_aircraft_model(datafile; \ndefaultfile = joinpath(TASOPT.__TASOPTroot__, \"../example/defaults/default_input.toml\"))\n\nReads a specified TOML file that describes a TASOPT aircraft model  with a fall back to the default aircraft definition  provided in \"/example/defaults/default_input.toml\"\"\n\nnote: Deviating from default\nExtending read_input.jl and save_model.jl is recommended for models deviating appreciably  from the default functionality. Thorough knowledge of the model is required.\n\nExamples\n\njulia> read_aircraft_model(\"examples/defaults/default_input.toml\")\n\n\n┌ Info: engine_location not found in user specified input file. \n│ Reading engine_location from default TASOPT input:\n│ \n│ engine_location = wing\n└ \n\n┌ Info: pylon_weight_fraction not found in user specified input file. \n│ Reading pylon_weight_fraction from default TASOPT input:\n│ \n│ pylon_weight_fraction = 0.1\n└ \nName: Example TASOPT Model;\nWpay = 210.0 kN\nDes. Range  = 5.56e6 km\nCruise Mach = 0.8\n\n\n\n\n\n\n","category":"method"},{"location":"data_io/data_io/#TASOPT.save_aircraft_model-Tuple{}","page":"Loading and saving models","title":"TASOPT.save_aircraft_model","text":"save_aircraft_model(ac::TASOPT.aircraft=TASOPT.read_aircraft_model(), \ndatafile=joinpath(TASOPT.__TASOPTroot__, \"IO/default_output.toml\"),\nsave_output::Bool=false)\n\nConverts an aircraft model into a dictionary and writes  it to a TOML file. Values to be written are explicitly set following the default_input.toml. All values are written in SI units.\n\nThis save operation makes add'l* assumptions about parameter repetition. Namely: The same value is applied for all flight segments/points for:     - parm[] parameters     - excrescencedragfactors, wing overspeeds, wing/stabilizer Re_refs The same value is applied for all missions and flight segments for:     - parg[] and pare[] parameters     - fuel temperature\n\nSaid value is the first entry in the corresponding array axis,  except for some aero parameters where other points are more relevant (e.g., \"Cruise\" \"Takeoff\").\n\n*and modifiable\n\nnote: Deviating from default\nExtending read_input.jl and save_model.jl is recommended for models deviating appreciably  from the default functionality. Thorough knowledge of the model is required.\n\n\n\n\n\n","category":"method"},{"location":"data_io/data_io/#TASOPT.quicksave_aircraft-Tuple{}","page":"Loading and saving models","title":"TASOPT.quicksave_aircraft","text":"quicksave_aircraft(ac::TASOPT.aircraft=TASOPT.read_aircraft_model(),\n    filepath=joinpath(TASOPT.__TASOPTroot__, \"IO/default_quicksave_aircraft.jld2\"))\n\nSerializes and saves aircraft struct to a .jld2 using JLD2 (not human-readable). Intended to store aircraft models with ALL fields (since not everything is stored by saveaircraftmodel).\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac::TASOPT.aircraft: TASOPT aircraft struct containing model in any state. \nfilepath::String: path and name of .jld2 file to be written.Outputs:None.\n\n\n\n\n\n","category":"method"},{"location":"data_io/data_io/#TASOPT.quickload_aircraft-Tuple{}","page":"Loading and saving models","title":"TASOPT.quickload_aircraft","text":"quickload_aircraft(datafile=joinpath(TASOPT.__TASOPTroot__, \"IO/default_quicksave_aircraft.jld2\"))\n\nReads a .jld2 file generated by quicksave_aircraft() and returns the generated aircraft structure.\n\ndetails: 🔃 Inputs and Outputs\nInputs:filepath::String: path and name of .jld2 file to be written.Outputs:ac::TASOPT.aircraft: TASOPT aircraft struct with model in the state it was saved in.\n\n\n\n\n\n","category":"method"},{"location":"data_io/data_io/#TASOPT.output_csv-Tuple{}","page":"Loading and saving models","title":"TASOPT.output_csv","text":"output_csv(ac::TASOPT.aircraft=TASOPT.load_default_model(), \n        filepath::String=joinpath(TASOPT.__TASOPTroot__, \"IO/default_output.csv\");\n        overwrite::Bool = false, indices::Dict = default_output_indices,\n        includeMissions::Union{AbstractVector,Colon,Bool,Integer} = false, \n        includeFlightPoints::Union{AbstractVector,Colon,Bool,Integer} = false,\n        forceMatrices::Bool = false)\n\nwrites the values of ac to CSV file filepath with index variables as headers.  A typical set of values is output by default for the design mission at the first cruise point. Appends to extant filepath if headers are compatible, appending integer suffixes to filename when not.\n\nOutput is customizable by:\n\nindices: specifies the desired indices of each par array,\nincludeMissions: allows output of all missions (i.e., =true) or specifiable indices (e.g., =[1,2,3]),\nincludeFlightPoints: allows output of all flight points (as for includeMissions).\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac::TASOPT.aircraft: TASOPT aircraft struct containing model in any state. \nfilepath::String: path and name of .csv file to be written.\noverwrite::Bool: deletes existing file at filepath when true, default is false.\nindices::Dict{String => Union{AbstractVector,Colon(), Integer}}: specifies desired indices of par arrays given as keys. Customizable; built-in options: default_output_indices, output_indices_all, and output_indices_wEngine.\nincludeMissions::Union{AbstractVector,Colon,Bool,Integer}: saves all mission entries as an array in a CSV cell when true, default is false, inner nested array when flight points are also output. specific indices can also be specified as Vectors of Ints.\nincludeFlightPoints::Union{AbstractVector,Colon,Bool,Integer}: saves all flight point entries as an array in a CSV cell when true, default is false, outer nested array when missions are also output. specific indices can also be specified as Vectors of Ints.\nforceMatrices::Bool: forces all entries that vary with mission and flight point to follow nested array structure\nstruct_excludes::AbstractVector{String}: names/substrings of fields to exclude from output of ac struct. Default is [], excluding nothing.Outputs:newfilepath::String: actual output filepath; updates in case of header conflicts. same as input filepath if overwrite = true.\n\n\n\n\n\n","category":"method"},{"location":"data_io/data_io/#TASOPT.default_output_indices","page":"Loading and saving models","title":"TASOPT.default_output_indices","text":"Indices of quantities of par arrays selected to be output by default by output_csv(). Formatted as a Dict() where keys are par array names and values are arrays of indices. Note that this selection is only along the first dimension of par arrays (i.e., selecting quantities, not missions or flight points).\n\nCustom Dicts() can be passed to output_csv() following the format: Dict(){String => Union{AbstractVector,Colon(), Integer}}. \n\nFor example: 1 : default_output_indices[\"parg\"] = [1, 5, igtotal]         > when submitted to output_csv(), will output as columns the first, fifth, and last entry of parg\n\n2 : default_output_indices[\"para\"] = Colon() #NOT [Colon()]         > when submitted to output_csv(), will output all indices of para (whether all flights or missions are included is controlled by a separate parameter)\n\n\n\n\n\n","category":"constant"},{"location":"propulsion/gascalc/#Gas-Calculations","page":"Gas Calculations","title":"Gas Calculations","text":"","category":"section"},{"location":"propulsion/gascalc/","page":"Gas Calculations","title":"Gas Calculations","text":"Gas calculations used with TASOPT.jl propulsion systems.","category":"page"},{"location":"propulsion/gascalc/#Ideal-gas-with-variable-c_p","page":"Gas Calculations","title":"Ideal gas with variable c_p","text":"","category":"section"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_tset-NTuple{4, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_tset","text":"gas_tset(alpha, n, hspec, tguess)\n\nCalculates temperature for a specified enthalpy. The constant-cp equivalent is\n\n          t = (hspec - hf) /cp  \n\n where hf is the heat of formation included in h[t]\n\ndetails: 🔃 Inputs and Outputs\nInput:alpha(.): mass fractions for gas constituents i = 1..n\nn: number of constituents present\nhspec: specified enthalpy\ntguess: first guess for temperatureOutput:t: temperature\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_tsetd-NTuple{4, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_tsetd","text":"gas_tsetd(alpha, n, hspec, tguess)\n\nSame as gas_tset, but also returns derivative\n\ndetails: 🔃 Inputs and Outputs\nInputs:alpha(.): mass fractions for gas constituents i = 1..n\nn: number of constituents present\nhspec: specified enthalpy\ntguess: first guess for temperatureOutputs:t: temperature\nt_hspec: ?\nt_al: ?\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gasfun","page":"Gas Calculations","title":"TASOPT.engine.gasfun","text":"gasfun(igas, t)\n\nComputes properties of a thermally-perfect gas with some variable specific heat cp[T].\n\ndetails: 🔃 Inputs and Outputs\nInput:igas: index specifying the gas (see if blocks below for list)\nt: temperature T in KelvinOutput:s: entropy-complement function s[T]\ns_t: ds/dT\nh: complete enthalpy function h[T]\nh_t: dh/dT\ncp: specific heat cp[T]\nr: ideal-gas constant R\n\nThe adiabatic pressure change over a process 1->2 with some polytropic efficiency epol is:\n\n p2  =  p1  exp    epol   (s2-s1)R    compression\n\n p2  =  p1  exp  (1epol) (s2-s1)R    expansion\n\n\n\n\n\n","category":"function"},{"location":"propulsion/gascalc/#TASOPT.engine.gaschem-Tuple{Any}","page":"Gas Calculations","title":"TASOPT.engine.gaschem","text":"gaschem(igas)\n\nReturns number of C,H,O,N atoms in gas molecule, for the gases implemented in function gasfun above.\n\ndetails: 🔃 Inputs and Outputs\nInput:igas: index specifying the gas (see if blocks below for list)Output:nchon(.): number of C,H,O,N atoms in gas molecule\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gassum-Tuple{Any, Any, Any}","page":"Gas Calculations","title":"TASOPT.engine.gassum","text":"gassum(alpha, n, t)\n\nCalculates all gas-mixture properties at specified temperature T, and mixing fractions alpha(.)\n\ndetails: 🔃 Inputs and Outputs\nInputs:alpha(.): mass fractions for gas constituents i = 1..n\nn: number of gas constituents\nt: temperature T,  KelvinOutputs:s: entropy-complement function s[T]\ns_t: ds/dT\nh: complete enthalpy function h[T]\nh_t: dh/dT\ncp: specific heat cp[T]\nr: ideal-gas constant R\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gassumd-Tuple{Any, Any, Any}","page":"Gas Calculations","title":"TASOPT.engine.gassumd","text":"gassumd(alpha, n, t)\n\nSame as gassum, but also returns cp_t\n\ndetails: 🔃 Inputs and Outputs\nInputs:alpha(.): mass fractions for gas constituents i = 1..n\nn: number of gas constituents\nt: temperature T,  KelvinOutputs:s: entropy-complement function s[T]\ns_t: ds/dT\nh: complete enthalpy function h[T]\nh_t: dh/dT\ncp: specific heat cp[T]\nr: ideal-gas constant R\ncp_t: dcp / dT\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_prat-NTuple{10, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_prat","text":"gas_prat(alpha, n, po, to, ho, so, cpo, ro, pratio, epol)\n\nCalculates state change for a specified pressure ratio. The constant-cp equivalent is the usual isentropic relations, but with epol included.\n\ng = cp/(cp-r)\ngexp = (g-1)/(g*epol)\ntau = pratio^gexp\np = po * pratio\nt = to * tau\n(h-hf) = (ho-hf) * tau\n\ndetails: 🔃 Inputs and Outputs\nInputs:alpha(.): mass fractions for gas constituents i = 1..n\nn: number of gas constituents\npo: starting pressure\nto: starting temperature\nho: starting enthalpy\nso: starting entropy-complement\ncpo: starting specific heat\nro: starting gas constant\npratio: pressure ratio\nepol: polytropic efficiency of change process  , if compression\nepol: 1/(polytropic efficiency of change process) , if expansionOutputs:p: ending pressure\nt: ending temperature\nh: ending enthalpy\ns: ending entropy-complement\ncp: ending specific heat\nr: ending gas constant (this will be the same as starting ro)\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_pratd-NTuple{10, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_pratd","text":"gas_pratd(alpha, n, po, to, ho, so, cpo, ro, pratio, epol)\n\nSame as gas_prat, but also returns Jacobians w.r.t. po,to,pratio,epol\n\ndetails: 🔃 Inputs and Outputs\nInputs:alpha(.): mass fractions for gas constituents i = 1..n\nn: number of gas constituents\npo: starting pressure\nto: starting temperature\nho: starting enthalpy\nso: starting entropy-complement\ncpo: starting specific heat\nro: starting gas constant\npratio: pressure ratio\nepol: polytropic efficiency of change process  , if compression\nepol: 1/(polytropic efficiency of change process) , if expansionOutputs:p: ending pressure\nt: ending temperature\nh: ending enthalpy\ns: ending entropy-complement\ncp: ending specific heat\nr: ending gas constant (this will be the same as starting ro)\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_delh-NTuple{10, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_delh","text":"gas_delh(alpha, n, po, to, ho, so, cpo, ro, delh, epol)\n\nCalculates state change for a specified enthalpy change. The constant-cp equivalent is the usual isentropic relations, but with epol included.\n\n  t - to = delh/cp\n  g = cp/(cp-r)\n  gexp = (g-1)/(g*epol)\n  tau = t/to\n  pi = tau^(1/gexp)\n  p = po * pi\n  (h-hf) = (ho-hf) * tau\n\ndetails: 🔃 Inputs and Outputs\nInputs:alpha(.): mass fractions for gas constituents i = 1..n\nn: number of constituents present\npo: starting pressure\nto: starting temperature\nho: starting enthalpy\nso: starting entropy-complement\ncpo: starting specific heat\nro: starting gas constant\ndelh: enthalpy change\nepol: polytropic efficiency of change process, if compression and 1/(polytropic efficiency of change process) , if expansionOutput:p: ending pressure\nt: ending temperature\nh: ending enthalpy\ns: ending entropy-complement\ncp: ending specific heat\nr: ending gas constant (this will be the same as starting ro)\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_delhd-NTuple{10, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_delhd","text":"gas_delhd(alpha, n, po, to, ho, so, cpo, ro, delh, epol)\n\nSame as gas_delh, but also returns Jacobians w.r.t. po,to,delh\n\ndetails: 🔃 Inputs and Outputs\nInputs:alpha(.): mass fractions for gas constituents i = 1..n\nn: number of constituents present\npo: starting pressure\nto: starting temperature\nho: starting enthalpy\nso: starting entropy-complement\ncpo: starting specific heat\nro: starting gas constant\ndelh: enthalpy change\nepol: polytropic efficiency of change process, if compression and 1/(polytropic efficiency of change process) , if expansionOutput:p: ending pressure\nt: ending temperature\nh: ending enthalpy\ns: ending entropy-complement\ncp: ending specific heat\nr: ending gas constant (this will be the same as starting ro)\np_so: \np_po: \np_ep: \np_ho: \nt_ho: \nh_ho: \ns_ho: \np_dh: \nt_dh: \nh_dh: \ns_dh: \np_al: \nt_al: \nh_al: \ns_al: \ncp_al: \nr_al: \n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_burn-NTuple{9, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_burn","text":"gas_burn(alpha, beta, gamma, n, ifuel, to, tf, t, hvap)\n\nCalculates fuel/air mass fraction in combustion with specified start and end temperatures to,t . Calculates mass fractions of post-combustion constituents\n\ndetails: 🔃 Inputs and Outputs\nInput: alpha(.): mass fractions for air  constituents i = 1..nbeta(.): mass fractions for fuel constituents i = 1..n\ngamma(.): mass fraction changes of air constituents due to combustion\nn: number of constituents present, air is 1..n-1, fuel is n\nifuel: index specifying fuel molecule\nto: starting air temperatur\ntf: starting fuel temperature\nt: temperature of combustion products\nhvap: fuel enthalpy of vaporizationOutput: f: fuel/air mass fraction lambda(.): mass fractions for combustion product constituents\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_burnd-NTuple{9, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_burnd","text":"gas_burnd(alpha, beta, gamma, n, ifuel, to, tf, t, hvap)\n\nSame as gas_burn, but also returns derivatives.\n\ndetails: 🔃 Inputs and Outputs\nInput: alpha(.): mass fractions for air  constituents i = 1..nbeta(.): mass fractions for fuel constituents i = 1..n\ngamma(.): mass fraction changes of air constituents due to combustion\nn: number of constituents present, air is 1..n-1, fuel is n\nifuel: index specifying fuel molecule\nto: starting air temperatur\ntf: starting fuel temperature\nt: temperature of combustion products\nhvap: fuel enthalpy of vaporizationOutput: f: fuel/air mass fraction lambda(.): mass fractions for combustion product constituents f_t:  l_to:  l_tf:  l_t: \n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_mach-NTuple{11, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_mach","text":"gas_mach(alpha, n, po, to, ho, so, cpo, ro, mo, m, epol)\n\nCalculates state change for a specified Mach number change. The constant-cp equivalent is the usual isentropic relations, but with epol included.\n\ng = cp/(cp-r)\ngexp = (g-1)/(g*epol)\ntau = (1 + 0.5*(g-1)*mo^2) / (1 + 0.5*(g-1)*m^2)\npi = tau^(1/gexp)\np = po * pi\nt = to * tau\n(h-hf) = (ho-hf) * tau\n  \n!!! details \"🔃 Inputs and Outputs\"     \n**Input:**\n`alpha(.)`: mass fractions for gas constituents i = 1..n\n`n`: number of constituents present\n`po`: starting pressure\n`to`: starting temperature\n`ho`: starting enthalpy\n`so`: starting entropy-complement\n`cpo`: starting specific heat\n`ro`: starting gas constant\n`mo`: starting Mach number\n`m`: ending Mach number\n`epol`: polytropic efficiency of change process  , if compression\n`epol`: 1/(polytropic efficiency of change process) , if expansion\n  \n**Output:**\n`p`: ending pressure\n`t`: ending temperature\n`h`: ending enthalpy\n`s`: ending entropy-complement\n`cp`: ending specific heat\n`r`: ending gas constant (this will be the same as starting ro)\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_machd-NTuple{11, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_machd","text":"gas_machd(alpha, n, po, to, ho, so, cpo, ro, mo, m, epol)\n\nSame as gas_mach, but also returns derivatives\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gas_mass-NTuple{10, Any}","page":"Gas Calculations","title":"TASOPT.engine.gas_mass","text":"gas_mass(alpha, n, po, to, ho, so, cpo, ro, mflux, Mguess)\n\nCalculates state a specified mass flux. Mguess specifies the initial guess, and also selects either the subsonic or the supersonic branch.\n\ndetails: 🔃 Inputs and Outputs\nInput: alpha(.)  mass fractions for gas constituents i = 1..nn         number of constituents present po        total pressureto        total temperature ho        total enthalpyso        total entropy-complement cpo       total specific heatro        total gas constant mflux     specified mass flux = rho u = mdot/AMguess    specifies the initial guess for the static quantitiesOutput:       p       static pressuret       static temperature h       static enthalpys       static entropy-complement cp      static specific heatr       static gas constant (this will be the same as total ro)\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gasfuel-Tuple{Any, Any}","page":"Gas Calculations","title":"TASOPT.engine.gasfuel","text":"gasfuel(ifuel, n)\n\nReturns mass fraction of constituent changes as a result of combustion with atmospheric oxygen\n\ndetails: 🔃 Inputs and Outputs\nInput:`ifuel   index of fuel  (see function gasfun)\n`n       number of constituents in reactionOutput:`gamma(.)  mass fraction changes due to reaction for i = 1..n\n\n\n\n\n\n","category":"method"},{"location":"propulsion/gascalc/#TASOPT.engine.gasPr-Tuple{Any, Any}","page":"Gas Calculations","title":"TASOPT.engine.gasPr","text":"gasPr(gas, T)\n\nThis function calculates some gas thermodynamic properties of different species, including viscosity, thermal conductivity, specific heat, and Prandtl number.\n\ndetails: 🔃 Inputs and Outputs\nInputs:gas::char: gas name\nT::Float64: temperature (K)Outputs:R::Float64: gas constant (J/kg/K)\nPr::Float64: Prandtl number\nγ::Float64: ratio of specific heats\ncp::Float64: specific heat at constant pressure (J/kg/K)\nμ::Float64: dynamic viscosity (Pa s)\nk::Float64: thermal conductivity (W/m/K) \n\n\n\n\n\n","category":"method"},{"location":"aero/theory_fuse_profile_drag/","page":"-","title":"-","text":"details: 📖 Theory - axisymmetric fuselage profile drag\nThe viscous calculation produces displacement, momentum, and kinetic energy areas Delta^* Theta Theta^* scriptstyle (x).The cross-sectional area over the center cylindrical portion is A_rm fuse, which has already been defined bybeginaligned\nA_rm fuse =  left pi + n_rm fwebleft( 2theta_rm fb+ sin 2 theta_rm fbright) \n right R_rm fuse^2 + 2 left R_rm fuse+ n_rm fwebw_rm fbright Delta R_rm fuse\nendalignedThis also defines the radius of the equivalent round cylinder.  beginaligned R_rm cyl =  sqrtfracA_rm fusepi endaligned The equivalent radii over the tapering nose and radius are then defined via the following convenient functions.beginaligned\nR scriptstyle (x) = \nleft\nbeginarraylcl\ndisplaystyle\nR_rm cyl\nleft  \n1 - left( fracx_rm blend_1 - xx_rm blend_1 - x_rm nose \n      right)^ a \n      right^ 1a\n   x_rm nose x  x_rm blend_1 \n10em\ndisplaystyle\nR_rm cyl\n   x_rm blend_1  x  x_rm blend_2\n05em\ndisplaystyle\nR_rm cyl\nleft \n1 - left( fracx - x_rm blend_2x_rm end - x_rm blend_    2 \n      right)^ b \n      right\n   x_rm blend_2  x  x_rm tail\nendarray\nright\n\na  simeq 16 \n\nb  simeq 20 \nendalignedThe x_rm blend_1 and x_rm blend_2 locations are the nose and tailcone blend points, and do not necessarily have to be exactly the same as the x_rm shell_1 and x_rm shell_2 locations which define the loaded pressure shell. Likewise, x_rm end is the aerodynamic endpoint of the tailcone, and is distinct from its structural endpoint x_rm conend. The a and b constant values above give reasonable typical fuselage shapes.If the fuselage is nearly round, the necessary area and perimeter distributions follow immediately. beginaligned\nA scriptstyle (x) =  pi  Rscriptstyle (x)^2\n\nb_0 scriptstyle (x) =  2 pi R scriptstyle (x)\nendalignedThis would be suitably modified for non-circular cross-sections.With this geometry definition, the viscous/inviscid calculation procedure provides the momentum and kinetic energy area distributions along the body and wake,beginaligned\nleft Theta scriptstyle (s)   Theta^* scriptstyle (s)right  = \nf_rm f_excr \ncal F(M_scriptscriptstyle infty Re_ell   A scriptstyle (x) b_0 scriptstyle (x))\nendalignedwhere cal F denotes the overall viscous/inviscid calculation procedure, and f_rm f_excr geq 1 is an empirical factor to allow for fuselage excrescence drag sources.Specific values of interest are the momentum area Theta_rm wake at the wake numerical endpoint s_rm wake, the far-downstream momentum area Theta_scriptscriptstyle infty, and the kinetic energy area Theta_scriptscriptstyle TE at the body endpoint or trailing edge. beginaligned\nTheta_rm wake =  Theta (s_rm wake) \n\nH_rm avg   =  \ntextstyle frac12left H(s_rm wake) + 1 + (gamma-1) M_scriptscriptstyle infty^2 right\n\nTheta_scriptscriptstyle infty =  Theta_rm wake\nleft( fracu_e (s_rm wake)V_scriptscriptstyle infty right)^H_rm avg \n\nTheta^*_scriptscriptstyle TE =  Theta^*(s_scriptscriptstyle TE) \nendalignedThe equation above is the Squire-Young formula, with H_rm avg being the average shape parameter between the end of the wake and far downstream.The fuselage surface + wake dissipated power in the absence of BLI is then evaluated as follows, consistent with the usual wake momentum defect relations. beginaligned\nC_D_rm fuse  equiv \nfracPhi_rm surf-P_V_rm surf + Phi_rm wake-P_V_rm wake\n           textstyle frac12rho_scriptscriptstyle inftyV_scriptscriptstyle infty^3 S \nhspace6ex\nrm(without BLI)\nhspace-90ex\n\nC_D_rm fuse\n =  fracD_rm fusetextstyle frac12rho_scriptscriptstyle inftyV_scriptscriptstyle infty^2 S\n= frac2 Theta_scriptscriptstyle inftyS \nhspace17ex\nrm(without BLI)\nhspace-90ex\nendalignedIf BLI is present at or near the trailing edge, the upstream boundary layer and corresponding surface dissipation Phi_rm surf will be mostly unaffected. But the viscous fluid flowing into the wake is now reduced by the ingestion fraction f_rm scriptscriptstyle BLI_scriptstyle f, so that the wake dissipation Phi_rm wake will be reduced by the same fraction. This then gives the following overall fuselage dissipation coefficient for the BLI case. beginaligned\nC_D_rm fuse = \nfracPhi_rm surf-P_V_rm surf + \n       (Phi_rm wake-P_V_rm wake)(1-f_rm scriptscriptstyle BLI_scriptstyle f)\n     textstyle frac12rho_scriptscriptstyle inftyV_scriptscriptstyle infty^3 S \nhspace3ex\nmathrm(with BLI)\nhspace-2ex\n\nC_D_rm fuse \n simeq \nC_D_rm fuse - C_Phi_rm wake f_rm scriptscriptstyle BLI_scriptstyle f\nhspace23ex\nmathrm(with BLI)\nhspace-2ex\n05em\nrmwhere hspace3ex\nC_Phi_rm wake  =  \nfrac2 Theta_scriptscriptstyle inftyS - fracTheta^*_scriptscriptstyle TES \nendaligned","category":"page"},{"location":"examples/NM_optimization/#Example-for-a-Multi-variable-Optimization","page":"Nelder Mead","title":"Example for a Multi-variable Optimization","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"(Image: Optimization Iteration Plot)","category":"page"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"To run a multi-variable optimization run on an aircraft model first determining your design variables. For this example, the design variables are:","category":"page"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"Aspect Ratio: AR\nCruise Altitude: Alt\nLift Coefficient: Cl  \nWing Sweep: sweep\nInner panel taper ratio: λs  \nOuter panel taper ratio: λt  \nRoot thickness to chord: hboxo\nSpanbreak thickness to chord: hboxs\nBreak/root cl ratio = cls/clo: rcls\nTip/root cl ratio = clt/clo: rclt\nTt4: Tt4\nHigh Pressure Compressor Pressure Ratio: pihc\nFan Pressure ratio: pif","category":"page"},{"location":"examples/NM_optimization/#Initialiation-and-loading-models","page":"Nelder Mead","title":"Initialiation and loading models","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"Start the script importing TASOPT.jl, Plots, index.inc, NLopt.","category":"page"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"# Import modules\nusing Plots\nusing TASOPT\n# you can optionally define\n# const tas = TASOPT \n# to use as a shorthand\ninclude(\"../src/data_structs/index.inc\")\n# import indices for calling parameters\nusing NLopt","category":"page"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"Initialize arrays used for plotting","category":"page"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"xarray = []\nfarray = []\nPFEIarray = []\nCDarray = []\nOPRarray = []\nplot_obj = nothing\nft_to_m = 0.3048","category":"page"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"Load aircraft model and size it to get initial values:","category":"page"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"# Load default model\nac = read_aircraft_model(joinpath(TASOPT.__TASOPTroot__, \"../example/opt_input.toml\"))\n#     datafile\n# Size aircraft once to get initial values\nsize_aircraft!(ac)","category":"page"},{"location":"examples/NM_optimization/#Setting-Optimization-Parameters","page":"Nelder Mead","title":"Setting Optimization Parameters","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"This example uses a Nelder Mead optimization aimed towards optimizing for passenger fuel emission index (PFEI) while checking for other constraints.","category":"page"},{"location":"examples/NM_optimization/#Set-the-Upper-and-Lower-limits-for-all-design-variables","page":"Nelder Mead","title":"Set the Upper and Lower limits for all design variables","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"# DESIGN VARIABLES\n#             AR    Alt(ft)  Cl     sweep     λs  λt   hboxo   hboxs   rcls    rclt     Tt4CR   iepihc iepif\nlower      = [7.0 , 20000.0, 0.40, 10.0, 0.1, 0.1, 0.10,   0.10,   0.1,    0.1,     700.0,  6,      0]\nupper      = [12.0, 60000.0, 0.65, 40.0, 1.0, 1.0, 0.15,   0.15,   1.4,    1.0,     2000.0, 15,     10] \n","category":"page"},{"location":"examples/NM_optimization/#Set-the-initial-values-for-all-design-variables","page":"Nelder Mead","title":"Set the initial values for all design variables","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"initial =[\n        ac.parg[igAR], 33000.0, 0.57, ac.parg[igsweep], \n        ac.parg[iglambdas], ac.parg[iglambdat], ac.parg[ighboxo], \n        ac.parg[ighboxs], ac.para[iarcls, ipcruise1,1], ac.para[iarclt, ipcruise1,1], 1587, 11.46, 1.66\n]","category":"page"},{"location":"examples/NM_optimization/#Set-initial-dx-values-for-all-design-variables","page":"Nelder Mead","title":"Set initial dx values for all design variables","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"initial_dx = [ 0.5, 1000.0,  0.05, 0.1,  0.01,0.01,0.01,   0.01,   0.01,   0.01, 100, 0.5,0.2]","category":"page"},{"location":"examples/NM_optimization/#Set-other-optimization-factors","page":"Nelder Mead","title":"Set other optimization factors","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"# Set FTOL\nf_tol_rel = 1e-5\n\n# Set Optimization module\nopt = NLopt.Opt(:LN_NELDERMEAD, length(initial))\n# Other Optimization algorithms are also possible:\n# # opt = NLopt.Opt(:LN_BOBYQA, length(initial))\n# # opt = NLopt.Opt(:LN_COBYLA, length(initial))\n\n# Set Optimization parameters\nopt.lower_bounds = lower\nopt.upper_bounds = upper\nopt.min_objective = obj\nopt.initial_step = initial_dx\nopt.ftol_rel = f_tol_rel","category":"page"},{"location":"examples/NM_optimization/#Objective-Function","page":"Nelder Mead","title":"Objective Function","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"function obj(x, grad)\n    ac.parg[igAR] = x[1] # Aspect Ratio \n    ac.para[iaalt, ipcruise1, :] .=  x[2] * ft_to_m # Cruise Altitude\n    ac.para[iaCL, ipclimb1+1:ipdescentn-1, :] .= x[3] # CL\n    ac.parg[igsweep] = x[4] # Wing sweep \n    ac.parg[iglambdas] = x[5] #inner_panel_taper_ratio\n    ac.parg[iglambdat] = x[6] #outer_panel_taper_ratio\n    ac.parg[ighboxo] = x[7] #root_thickness_to_chord\n    ac.parg[ighboxs] = x[8] #spanbreak_thickness_to_chord\n    ac.para[iarcls, ipclimb1+1 : ipdescentn-1, :] .= x[9]   #  rcls    break/root cl ratio = cls/clo\n    ac.para[iarclt, ipclimb1+1 : ipdescentn-1, :] .= x[10]   #  rclt    tip  /root cl ratio = clt/clo\n    ac.pare[ieTt4, ipcruise1:ipcruise2, :] .= x[11] # Tt4\n    ac.pare[iepihc, ipclimb1+1 : ipdescentn-1, :] .= x[12] # High Pressure Compressor Pressure Ratio\n    ac.pare[iepif, ipclimbn, :] .= x[13] #Fan PR \n    ac.pare[iepilc, :, :] .= 3 # Low Pressure Compressure Pressure Ratio set to 3\n\n    # Sizing aircraft with new ac.parameters\n    TASOPT.size_aircraft!(ac, iter =50, printiter=false)\n    f = ac.parm[imPFEI]\n    push!(PFEIarray, ac.parm[imPFEI])\n    push!(xarray, x)\n    push!(CDarray, ac.para[iaCD, ipcruise1, 1])\n    push!(OPRarray, ac.pare[iept3]/ac.pare[iept2])\n    \n    # Ensure aircraft weight makes sense\n    WTOmax = ac.parg[igWMTO]\n    WTO = ac.parm[imWTO,1]\n    constraint = WTO/WTOmax - 1.0\n    penfac = 10*ac.parg[igWpay]\n    f = f + penfac*max(0.0, constraint)^2\n\n    # Ensure fuel volume makes sense\n    Wfmax = ac.parg[igWfmax]\n    Wf    = ac.parg[igWfuel]\n    constraint = Wf/Wfmax - 1.0\n    penfac = 10*ac.parg[igWpay]\n    f = f + penfac*max(0.0, constraint)^2\n    \n    println(\"X̄ = $x  ⇨  PFEI = $(ac.parm[imPFEI]) f = $f, OPR = $(ac.pare[iept3]/ac.pare[iept2]),\")\n    push!(farray, f)\n    \n    return f\nend","category":"page"},{"location":"examples/NM_optimization/#Running-the-optimization","page":"Nelder Mead","title":"Running the optimization","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"opt_time = @elapsed (optf, optx, ret) = NLopt.optimize(opt, initial)\nnumevals = opt.numevals # the number of function evaluations\n\nprintln(\"got $optf at $optx after $numevals iterations which took $(opt_time/60) min (returned $ret)\")\n","category":"page"},{"location":"examples/NM_optimization/#Plotting-resulting-data","page":"Nelder Mead","title":"Plotting resulting data","text":"","category":"section"},{"location":"examples/NM_optimization/#Plot-aircraft-model-details","page":"Nelder Mead","title":"Plot aircraft model details","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"figure()\nsavedir = \"./example/optimization/\"\nif !isdir(savedir)\n    # If it doesn't exist, create the \"optimization\" directory\n    mkdir(savedir)\n    println(\"The 'optimization' directory has been created.\")\nend\nfigname = \"Opt_tutorial_ac_details\"\nplot_obj = TASOPT.plot_details(ac; plot_obj = plot_obj)\nsavefig(plot_obj, savedir*figname*\".png\")","category":"page"},{"location":"examples/NM_optimization/#Plot-optimization-outputs-over-iterations","page":"Nelder Mead","title":"Plot optimization outputs over iterations","text":"","category":"section"},{"location":"examples/NM_optimization/","page":"Nelder Mead","title":"Nelder Mead","text":"## Second figure\n# Create a 2x2 layout\nlayout = @layout [a b; c d]\n\np1 = plot(PFEIarray, xlabel=\"Iterations\", ylabel=\"PFEI (J/Nm)\", title=\"\")\np2 = plot(farray, yscale=:log10, xlabel=\"Iterations\", ylabel=\"Objective f\", title=\"\")\np3 = plot(CDarray, xlabel=\"Iterations\", ylabel=\"CD\", title=\"\")\np4 = plot(OPRarray, xlabel=\"Iterations\", ylabel=\"OPR\", title=\"\")\n\n# Create the plot\np = plot(p1, p2, p3, p4,    \n    layout = layout,\n    size=(1200, 800),\n    plot_title=\"Optimization outputs\"\n)\n\n# Save the plot\nfigname2 = \"Opt_tutorial_iterations\"\nsavefig(p, savedir * figname2 * \".png\")","category":"page"},{"location":"sizing/weightmodels/#TASOPT-Weight-Model","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"","category":"section"},{"location":"sizing/weightmodels/#Overall-Weight-Breakdown","page":"TASOPT Weight Model","title":"Overall Weight Breakdown","text":"","category":"section"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"In calculating the weight models, TASOPT combines:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"Fundamental, physics-based structural models for the primary structures (fuselage, wing, tail), sized by specified load factors and material properties.\nEmpirically derived fractional weights (for items such as seats, furnishings, equipment, etc.) that scale with either payload or primary structure area/weight.","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"(Image: )","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"As shown in the figure above, each component in the aircraft can be divided into sub-weights, some of which are explicitly derived from geometry and stress analyses, and others that are assigned via fractional or fixed scaling. Altogether the overall flying weight of the aircraft is:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"beginaligned\nW \n=r_rm payW_rm pay\n+r_rm fuelW_rm fuel\n+W_rm fuse\n+W_rm wing\n+W_rm strut\n+W_rm htail\n+W_rm vtail\nquad+W_rm eng\n+W_rm hpesys\n+W_rm lgnose\n+W_rm lgmain\nendaligned","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"where r_mathrmpay and r_mathrmfuel can range from 0 to 1 to represent partial loads.","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"","category":"page"},{"location":"sizing/weightmodels/#[Fuselage-Weight](@ref-fuselage)","page":"TASOPT Weight Model","title":"Fuselage Weight","text":"","category":"section"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"details: 📖 Theory - Fuselage Weight Calculation\nThe fuselage structural weight is calculated using:Pressure shell modeling\nBending loads\nSecondary items (Seats, and other interior equipment).","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"These fuselage-related weights (shell, floor beams, tail cone, added bending material, etc.) plus passenger-proportional items are summed to get the total fuselage weight, expressed mathematically as:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"beginaligned\nW_rm fuse = \nW_rm fix+ \nW_rm apu+ \nW_rm padd+ \nW_rm seat\nnonumber \n +  \nW_rm shell+ \nW_rm cone+\nW_rm window+ \nW_rm insul+ \nW_rm floor\nnonumber \n +\nW_rm hbend+ \nW_rm vbend\nendaligned","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"where W_rm fix is a fixed weight (cockpit, instruments, etc.), W_rm apu,W_rm seat, W_rm padd scale with passenger payload or seating capacity, W_rm shell, W_rm cone, W_rm floor come from explicit structural and geometric modeling (pressurization, bending, torsion), and W_rm hbend, W_rm vbend represent added fuselage skin/stringer material for horizontal and vertical bending loads.","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"","category":"page"},{"location":"sizing/weightmodels/#[Wing-Weight](@ref-wingtail)","page":"TASOPT Weight Model","title":"Wing Weight","text":"","category":"section"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"details: 📖 Theory - Wing Weight Calculation\nTASOPT’s wing weight model first computes the primary wingbox weight via beam theory, sizing spar caps and webs to meet bending and shear stress limits under specified load factors. Each panel (inner and outer) is integrated for structural volume, as well as for maximum possible fuel volume. Secondary elements (leading and trailing-edge devices, ribs, flaps, spoilers, etc.) are included through empirical fraction multipliers on the primary structure.","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"The total wing structural weight is:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"beginaligned\nW_rm wing = \n2 bigl(W_mathrmscen + W_mathrmsinn + W_mathrmsoutbigr)bigl(1 + f_mathrmwaddbigr)\nendaligned","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"where W_mathrmscen, W_mathrmsinn, and W_mathrmsout are the structural weights of the center, inner, and outer wing panels, respectively, and f_mathrmwadd is the sum of fractional add-ons (flaps, slats, ailerons, etc.).","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"","category":"page"},{"location":"sizing/weightmodels/#[Tail-Weight](@ref-wingtail)","page":"TASOPT Weight Model","title":"Tail Weight","text":"","category":"section"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"Both horizontal and vertical tails are sized much like a small wing:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"Each tail’s planform is analyzed for maximum tail-load conditions (e.g., at never-exceed dynamic pressure).\nSpars and skins are sized with the same beam-type approach.\nThe final tail weight sums with the fuselage to include the tail cone, sometimes lumped into a single “rear mass” for bending load computations.","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"","category":"page"},{"location":"sizing/weightmodels/#Engine-Weight","page":"TASOPT Weight Model","title":"Engine Weight","text":"","category":"section"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"There are currently two options for engine weight models in TASOPT. The Drela engine model  or Fitzgerald's engine model (Section 2.10 of the TASOPT Technical Desc).  ","category":"page"},{"location":"sizing/weightmodels/#Drela-Engine-Model","page":"TASOPT Weight Model","title":"Drela Engine Model","text":"","category":"section"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"The bare weight function has been calibrated with listed weights for existing turbofans, as described in the document Turbofan Weight Model from Historical Data. The bare engine weight W_mathrmebare scales with turbofan design parameters (mass flow, overall pressure ratio, bypass ratio). Added fractions for accessories, fuel systems, and pylons yield the overall engine system weight:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"beginaligned\nW_rm bare = n_rm engW_e_1bigl(dotm_D OPR_DBPR_Dbigr)6pt\nW_rm add = W_rm baref_rm eadd6pt\nW_rm pylon =bigl(W_rm bare + W_rm add + W_rm nacebigr)f_rm pylon6pt\nW_rm eng = W_rm bare + W_rm add + W_rm nace + W_rm pylon\nendaligned","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"Here, W_rm bare is determined by the core flow correlation; W_rm add is an empirical fraction of W_rm bare; W_rm nace is the nacelle + thrust reverser weight (based on fan diameter, length, etc.), and W_rm pylon accounts for the engine mounting structure.","category":"page"},{"location":"sizing/weightmodels/#Fitzgerald-Engine-Model","page":"TASOPT Weight Model","title":"Fitzgerald Engine Model","text":"","category":"section"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"This engine weight model is based on a correlation for bare engine weight as a function of overall pressure ratio, bypass ratio, and core mass flow. There are options to use the basic as well as advanced model.","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"In the basic model four bare engine weight correlations are based on data from NPSS/WATE++. It has the ability to model a direct-drive turbofan or a geared turbofan. The nacelle, pylon, and additional weights are calculated as functions of bare engine weight and fan diameter and then summed to find the total engine weight as given in the equation below:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"beginaligned\nW_rm eng = W_rm bare + W_rm add + W_rm nace + W_rm pylon\nendaligned","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"The advanced model uses the weight correlations from NPSS/WATE++ as well but features separate surrogate models for the core, fan, combustor, nozzle and nacelle weights:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"beginaligned\nW_rm eng = W_rm core + W_rm fan + W_rm comb + W_rm nozz + W_rm nace + W_rm pylon\nendaligned","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"","category":"page"},{"location":"sizing/weightmodels/#Empirical-Weight-Fractions","page":"TASOPT Weight Model","title":"Empirical Weight Fractions","text":"","category":"section"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"Many aircraft components are assumed to scale linearly with related weights. For example:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"beginaligned\nW_rm APU = f_rm APU W_rm payload = 0035 times W_rm payload\nendaligned","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"The default values for these empirical weight fractions (f) are:","category":"page"},{"location":"sizing/weightmodels/","page":"TASOPT Weight Model","title":"TASOPT Weight Model","text":"Weight Components Default f Scaling Weight\nW_rm hpesys High-Pressure and Electrical Systems 0.010 W_rm MTO\nW_rm lgmain Landing Gear (main) 0.044 W_rm MTO\nW_rm lgnose Landing Gear (nose) 0.011 W_rm MTO\nW_rm APU APU 0.035 W_rm payload\nW_rm seat Seat 0.1 W_rm payload\nW_rm padd Added Payload 0.35 W_rm payload\nW_rm flap Wing Flaps 0.2 W_rm wing\nW_rm slat Wing Slats 0.1 W_rm wing\nW_rm aile Wing Ailerons 0.04 W_rm wing\nW_rm lete Wing Leading Trailing Edge 0.1 W_rm wing\nW_rm ribs Wing Ribs 0.15 W_rm wing\nW_rm spoi Wing Spoilers 0.02 W_rm wing\nW_rm watt Wing Attachments 0.03 W_rm wing\nW_rm hadd H-tail Added Weight 0.3 W_rm htail\nW_rm vadd V-tail Added Weight 0.4 W_rm vtail\nW_rm eadd Engine Access Weight 0.1 W_rm engbare\nW_rm pylon Pylon 0.1 W_rm eng","category":"page"},{"location":"atmos/atmos/#Atmospheric-properties","page":"Atmospheric properties","title":"Atmospheric properties","text":"","category":"section"},{"location":"atmos/atmos/#TASOPT.atmosphere.atmos","page":"Atmospheric properties","title":"TASOPT.atmosphere.atmos","text":"atmos(h, ΔT)\n\nAtmospheric functions T(h), ρ(h) etc valid to h=20km, p(h) valid to h=70km.\n\nAlso calculates viscosity using Sutherland's law. Non-standard sea-level temperatures are allowed with an ISA + ΔT like model.\n\nUnits:\n\n[h]   = km ASL\n[T]   = Kelvin\n[p]   = Pa\n[ρ]   = kg/m^3\n[a]   = m/s\n[μ]   = kg/m-s \n\n\n\n\n\n","category":"function"},{"location":"atmos/atmos/","page":"Atmospheric properties","title":"Atmospheric properties","text":"This function can be used to return the atmospheric properties at a given altitude as follows:","category":"page"},{"location":"atmos/atmos/","page":"Atmospheric properties","title":"Atmospheric properties","text":"h = 10.0 # km\nT,p,ρ,a,μ = atmos(h)\nT,p,ρ,a,μ","category":"page"},{"location":"examples/sensitivity/#Calculating-Parameter-Sensitivities","page":"Sensitivities","title":"Calculating Parameter Sensitivities","text":"","category":"section"},{"location":"examples/sensitivity/","page":"Sensitivities","title":"Sensitivities","text":"(Image: SensitivityPlot)","category":"page"},{"location":"examples/sensitivity/","page":"Sensitivities","title":"Sensitivities","text":"Using the sensitivity module it is possible to calculate the gradients of TASOPT parameters over PFEI. The sensitivity is calculated using finite difference (central relative difference).","category":"page"},{"location":"examples/sensitivity/","page":"Sensitivities","title":"Sensitivities","text":"The function input takes parameters as a list of symbols. There are a variety of parameters that can be taken in shown in the example below. The sensitivities can also be plot in a bar chart.","category":"page"},{"location":"examples/sensitivity/","page":"Sensitivities","title":"Sensitivities","text":"using TASOPT\ninclude(__TASOPTindices__)\n# List of the parameters you want to update as symbols\n    params = [\n    # Parg type with just one index\n    :(ac.parg[igetas]),\n    # pare/para type with full range of values across all mission points\n    :(ac.pare[ieepolf,:,:]),\n    # pare/para type with specific range of mission points [NOTE: This will return a vector of gradients relative to each input param in the range]\n    :(ac.pare[iepihc,ipclimbn:ipcruise1,1]),\n    # TASOPT strucutral, nested parameter\n    :(ac.fuselage.layout.cross_section.radius)\n]\nepsilon = 1e-5\ndefault_model = load_default_model()\nsize_aircraft!(default_model)\nTASOPT.get_sensitivity(params, model_state = default_model, eps = epsilon)","category":"page"},{"location":"examples/sensitivity/","page":"Sensitivities","title":"Sensitivities","text":"If you want the default model as the model state and epsilon as 1e-5  you can also call the function directly with just the params:","category":"page"},{"location":"examples/sensitivity/","page":"Sensitivities","title":"Sensitivities","text":"sens = TASOPT.get_sensitivity(params)\n\n#Plot Sensitivities\nTASOPT.plot_sensitivities(sens)","category":"page"},{"location":"structures/landing_gear/#landing_gear","page":"Landing gear","title":"Landing gear","text":"","category":"section"},{"location":"structures/landing_gear/","page":"Landing gear","title":"Landing gear","text":"The landing gear in TASOPT.jl can be modeled in two ways depending on the user preference in the input file. The simplest model assumes that the nose and main landing gears are simply constant fractions of the maximum takeoff weight. A more elaborate model calculates the landing gear length and uses this to find its mass via a correlation to historical data from Raymer[1]. The landing gear is sized in size_landing_gear!().","category":"page"},{"location":"structures/landing_gear/","page":"Landing gear","title":"Landing gear","text":"details: 📖 Theory - Landing gear sizing via historical correlations\nThe landing gear length can be sized by (a) the need to avoid a tailstrike at rotation during takeoff, or (b) the need to provide a minimum engine ground clearance, as illustrated in the figure below. In TASOPT.jl, the nose gear length is calculated first and the main gear length is subsequently calculated based on the wing geometry. (Image: LGlength)In the tailstrike case, the length of the landing gear (l_ts) can be determined from the geometry as    l_ts= (x_end - x_mg) tan(theta_ts) - D_fwhere x_end is the distance from the front of the aircraft to the end of the fuselage, x_mg is the main gear location, theta_ts is the desired tailstrike angle, and D_f is the fuselage diameter.In the engine ground clearance case, the length of the landing gear (l_c) is given by    l_c= d_c + D_fan - y_engtan(Gamma)where d_c is the desired ground clearance, D_fan is the fan diameter, y_eng is the distance from the fuselage centerline to the engine centerline, and Gamma is the wing dihedral angle.The selected nose gear length is l_ng=max(l_tsl_c). The main gear length is    l_mg = l_ng+y_mgtan(Gamma)where y_mg is the spanwise location of the main gear.Once this has been determined, the historical-data correlations in Raymer[1] can be used to calculate the mass of the nose and main landing gears. For the main gear, the mass (in lbs) is given by    m_mg = 00106 mathrmMTOW^0888 N_l^025 l_mg^04 N_wm^0321 N_sm^-05 V_stall^01where mathrmMTOW is the maximum takeoff weight in lbs, N_l=45 is the ultimate load factor that the landing gear is sized for, l_mg is the main gear length in inches, N_wm is the total number of wheels in the main gear, N_sm is the number of main gear shock struts, and V_stall is the stall speed in knots.Similarly, the mass of the nose gear (in lbs) is determined by[1]    m_ng = 0032mathrmMTOW^0646 N_l^02 l_ng^05 N_wn^045where l_ng is the length of the nose gear in inches and N_wn is the number of wheels in the nose gear.","category":"page"},{"location":"structures/landing_gear/#TASOPT.structures.size_landing_gear!","page":"Landing gear","title":"TASOPT.structures.size_landing_gear!","text":"size_landing_gear!(ac)\n\nFunction to calculate the landing gear mass and geometric properties.\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac::aircraft: structure with aircraft parametersOutputs: No direct outputs; parameters in ac are modified.\n\n\n\n\n\n","category":"function"},{"location":"structures/landing_gear/","page":"Landing gear","title":"Landing gear","text":"[1]: Raymer, Daniel. Aircraft design: a conceptual approach. American Institute of Aeronautics and Astronautics, Inc., 2012.","category":"page"},{"location":"structures/theory_wingstruct/","page":"-","title":"-","text":"details: 📖 Theory - Normal-plane Stresses\nTogether with the normal-plane coordinate and chord relations, the shear and bending moment are related to the corresponding airplane-axes quantities and to the sweep angle Lambda as follows.beginaligned\ncal S_scriptscriptstyle perp =  cal S\nlabelSperp \ncal M_scriptscriptstyle perp =  cal M cos Lambda\nlabelMperp\nendalignedThe box is assumed to be the only structurally-significant element, with the slats, flaps, and spoilers (if any), represented only by added weight. It is convenient to define all dimensions as ratios with the local normal-plane chord c_scriptscriptstyle perp.beginaligned\nbarh equiv frach_rm wboxc_scriptscriptstyle perp \nbarw equiv fracw_rm wboxc_scriptscriptstyle perp \nbart_rm capequiv fract_rm capc_scriptscriptstyle perp \nbart_rm webequiv fract_rm webc_scriptscriptstyle perp \nendalignedThe maximum height h_rm wbox at the box center corresponds to the airfoil thickness, so that barh is the usual \"tc\" airfoil thickness ratio. The height is assumed to taper off quadratically to a fraction r_h at the webs, so that the local height h scriptstyle (xi) is  beginaligned h scriptstyle (xi) =  h_rm wboxleft  1 - (1-r_h) xi^2  right endaligned where xi = -1 ldots 1 runs chordwise over the sparbox extent. Typical metal wings and airfoils have barw simeq 05, r_h simeq 075, although these are left as input parameters. For evaluating areas and approximating the bending inertia, it's useful to define the simple average and r.m.s. average normalized box heights. beginaligned\nbarh_rm avg =  frac1c_scriptscriptstyle perp int_0^1 h scriptstyle (xi) rm dxi \n= barh left  1 - frac13(1-r_h)  right\n\nbarh_rm rms^2  =  frac1c_scriptscriptstyle perp^2 int_0^1 h^2 scriptstyle (xi) rm dxi \n= barh^2 left  \n1 - frac23(1-r_h) + frac15 (1-r_h)^2  right\nendalignedThe areas and the bending and torsion inertias, all normalized by the normal chord, can now be determined. beginaligned\nbarA_rm fuelequiv fracA_rm fuelc_scriptscriptstyle perp^2 =\n(barw - 2 bart_rm web)(barh_rm avg- 2 bart_rm cap) \n\nbarA_rm capequiv fracA_rm capc_scriptscriptstyle perp^2 = 2  bart_rm capbarw \n\nbarA_rm webequiv fracA_rm webc_scriptscriptstyle perp^2 = 2  bart_rm web r_h  barh \n\nbarI_rm cap simeq  fracI_rm capc_scriptscriptstyle perp^4 =\nfracbarw12 \nleft barh_rm rms^3 - (barh_rm rms-2bart_rm cap)^3 right\n\nbarI_rm webequiv fracI_rm webc_scriptscriptstyle perp^4 =\nfracbart_rm web r_h^3  barh^36   ll  barI_rm cap\nhspace2em mathrm(typically)\n\nGbarJ equiv \nfrac4 (barw - bart_rm web)^2 (barh_rm avg- bart_rm cap)^2\n displaystyle \n2 frac r_h barh - bart_rm capG_rm webbart_rm web +\n2 frac     barw - bart_rm webG_rm capbart_rm cap \nendaligned","category":"page"},{"location":"aero/theory_geometry/","page":"-","title":"-","text":"details: 📖 Theory - Chord distribution\nThe wing or tail surface is assumed to have a two-piece linear planform with constant sweep Lambda, shown in the figure below. The inner and outer surface planforms are defined in terms of the center chord c_o and the inner and outer taper ratios. beginaligned\nlambda_s  =  c_sc_o\n\nlambda_t  =  c_tc_o\nendalignedSimilarly, the spanwise dimensions are defined in terms of the span b and the normalized spanwise coordinate eta.beginaligned\neta    =  2y  b  \n\neta_o  =  b_o  b\n\neta_s  =  b_sb \nendalignedFor generality, the wing center box width b_o is assumed to be different from the fuselage width to allow possibly strongly non-circular fuselage cross-sections. It will also be different for the tail surfaces. A planform break inner span b_s is defined, where possibly also a strut or engine is attached. Setting b_s = b_o and c_s = c_o will recover a single-taper surface.It's convenient to define the piecewise-linear normalized chord functionbeginaligned\nfracc scriptstyle (eta)c_o  equiv  \nC scriptstyle (eta    eta_oeta_s lambda_slambda_t)\n   =  \nleft\nbeginarraylcl\n 1    0  eta  eta_o \n05em\ndisplaystyle\n 1  + (lambda_s-1 ) fraceta   - eta_oeta_s-eta_o\n   eta_o  eta  eta_s \n025em\ndisplaystyle\nlambda_s + (lambda_t-lambda_s) fraceta   - eta_s1-eta_s\n   eta_s  eta  1\nendarray\nright\nlabelceta\nendalignedThe following integrals will be useful for area, volume, shear, and moment calculations. beginaligned\nint_0^eta_o C  rm deta \n =  eta_o\n\nint_eta_o^eta_s C  rm deta\n = frac12 ( 1+lambda_s)(eta_s-eta_o)\n\nint_eta_s^1 C  rm deta \n =  frac12 (lambda_s+lambda_t)(1-eta_s)\n025em\nint_0^eta_o C^2 rm deta \n =  eta_o\n\nint_eta_o^eta_s C^2 rm deta\n =  frac13 ( 1+lambda_s+lambda_s^2)(eta_s-eta_o)\n\nint_eta_s^1 C^2 rm deta \n =  frac13 (lambda_s^2+lambda_s lambda_t+lambda_t^2)(1-eta_s)\n\n\nint_eta_o^eta_s C  (eta-eta_o)  rm deta\n =  frac16 ( 1+2lambda_s)(eta_s-eta_o)^2\n\nint_eta_s^1 C  (eta-eta_s)  rm deta\n =  frac16 (lambda_s+2lambda_t)(1-eta_s)^2\n\nint_eta_o^eta_s C^2  (eta-eta_o)  rm deta\n =  frac112 ( 1+2lambda_s+3lambda_s^2)(eta_s-eta_o)^2\n\nint_eta_s^1 C^2  (eta-eta_s)  rm deta\n =  frac112 (lambda_s^2+2lambda_slambda_t+3lambda_t^2)(1-eta_s)^2\nlabelCint2\nendaligned","category":"page"},{"location":"aero/theory_geometry/","page":"-","title":"-","text":"details: 📖 Theory - Surface area and aspect ratio\nThe surface area S is defined as the exposed surface area plus the fuselage carryover area. beginaligned\nS  =  2 int_0^b2  c  rm dy = c_o  b  K_c\nlabelSdef\n\nmathrmwhere hspace3em\nK_c  =   int_0^1  C  rm deta = \neta_o + textstyle frac12( 1       +lambda_s)(eta_s-eta_o)\n      + textstyle frac12(lambda_s+lambda_t  )(1     -eta_s)\nendalignedThe aspect ratio is then defined in the usual way. This will also allow relating the root chord to the span and the taper ratios. beginaligned\nAhspace-05exR =  fracb^2S\nlabelARdef\nendalignedIt is also useful to define the wing's mean aerodynamic chord c_rm ma and area-centroid offset scriptstyle Deltax_rm wing from the center axis.beginaligned\nfracc_rm mac_o =\nfrac1c_o frac2S int_0^b2  c^2  rm dy \n= fracK_ccK_c\n\nscriptstyle Deltax_rm wing\n=\nfrac2S int_b_o2^b2  c  (y - y_o) tanLambda  rm dy \n= fracK_cxK_c  b  tanLambda\n\nx_rm wing =  x_rm wbox+ scriptstyle Deltax_rm wing\n025em\nmathrmwhere hspace1em\nK_cc = int_0^1  C^2  rm deta\nnonumber \n= eta_o\n+ frac13 ( 1         +lambda_s+lambda_s^2)(eta_s-eta_o)\n+ frac13 (lambda_s^2+lambda_s lambda_t+lambda_t^2)(1-eta_s)\nhspace3em\n025em\nK_cx =  int_eta_o^1  C  (eta-eta_o)  rm deta \nnonumber \n=\nfrac112 ( 1       +2lambda_s)(eta_s-eta_o)^2 +\nfrac112 (lambda_s+2lambda_t)(1-eta_s)^2      +\nfrac14  (lambda_s+lambda_t)(1-eta_s)(eta_s-eta_o)\nhspace3em\nendalignedThe wing area centroid is used in the fuselage bending load calculations as described earlier.","category":"page"},{"location":"aero/theory_geometry/#Reference-quantities","page":"-","title":"Reference quantities","text":"","category":"section"},{"location":"aero/theory_geometry/","page":"-","title":"-","text":"The aircraft reference quantities are chosen to be simply the values for the wing. ","category":"page"},{"location":"aero/theory_geometry/","page":"-","title":"-","text":"beginaligned\nb_rm ref   = (b)_rm wing\nS_rm ref   = (S)_rm wing\nAhspace-05exR_rm ref = (Ahspace-05exR)_rm wing\nc_rm ref   = (c_rm ma)_rm wing\nendaligned","category":"page"},{"location":"data_io/data_basics/#datastructs_basics","page":"Data structure basics","title":"Data structure basics","text":"","category":"section"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"Performance and design data is held largely in the par arrays (a holdover from FORTRAN TASOPT) along with a growing body of structs to represent cohesive components and systems. An aircraft struct wraps these arrays, structs, and auxiliary information.","category":"page"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"compat: Future Changes\nWe don't like this hybrid approach either. It's the legacy of Fortran.In a future major revision, we aim to completely replace the par array system with the struct-oriented approach.","category":"page"},{"location":"data_io/data_basics/#par-arrays","page":"Data structure basics","title":"par arrays","text":"","category":"section"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"Four arrays contain both prescribed inputs and computed outputs, some of which are multi-dimensional:","category":"page"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"parg::AbstractVector{Float64}:  geometric quantities, weights, structural values, and other values inherent to an instantiated design (not operation).\nparm::AbstractArray{Float64, 2}:  mission-prescribing parameters. The second dimension allows the specification of multiple mission profiles.\npara::AbstractArray{Float64, 3}:  aerodynamic performance quantities. The second dimension captures the variation over a mission. The third dimension allows the specification of multiple mission profiles.\npare::AbstractArray{Float64, 3}:  engine perfomance quantities. As for para, the second and third dimensions capture flight-point and mission dependencies, respectively.","category":"page"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"Data in the par arrays are accessed via Integer indices defined at src/data_structs/index.inc. These indices can be added to a namespace via include(__TASOPTindices__):","category":"page"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"using TASOPT\n#using __TASOPTroot__, which fetches the src directory\ninclude(joinpath(__TASOPTroot__, \"data_structs/index.inc\"))\n\n#or more concisely\ninclude(__TASOPTindices__)","category":"page"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"The variable names of these indices indicate which par array they should access and hint at the quantity in question. For example, ieTfuel evaluates to 2 and retrieves the model's fuel temperature via pare[ieTfuel]. ","category":"page"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"Note that for the multi-dimensional par arrays, indexing with a single Integer only retrieves the value for the first flight point of the first mission (namely, the design mission). Additional indexing is required to access data from different flight points or missions. Indices for specific flight points are defined in index.inc and should be used when indexing pare or para, e.g., ipstatic for static ground condition or ipcruise1 for the start of cruise.","category":"page"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"using TASOPT\ninclude(__TASOPTindices__)\nac = load_default_model()\n\nprintln(\"Single element: \", size(ac.pare[ieTfuel]))\nprintln(ac.pare[ieTfuel])\n\nprintln(\"Full slices: \", size(ac.pare[ieTfuel,:,:]))\nprintln(ac.pare[ieTfuel,:,:])\n\nprintln(\"All missions at cruise start: \", size(ac.pare[ieTfuel,ipcruise1,:]))\nprintln(ac.pare[ieTfuel,ipcruise1,:])\n","category":"page"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"can be included via the convenience variable __TASOPTindices__","category":"page"},{"location":"data_io/data_basics/#aircraft-struct","page":"Data structure basics","title":"aircraft struct","text":"","category":"section"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"An aircraft is composed of par array fields, title and description fields, and a is_sized flag to indicate its status. An optional fuse_tank field is present as a trial for future struct-based development. All fields are dot-accessible and array elements can be changed (e.g., ac.parg[igS] = 20), though the struct itself is not mutable.","category":"page"},{"location":"data_io/data_basics/","page":"Data structure basics","title":"Data structure basics","text":"Refer to the struct reference page for add'l details.","category":"page"},{"location":"misc/misc/#Other-utilities","page":"Other utilities","title":"Other utilities","text":"","category":"section"},{"location":"misc/misc/#General-outputs","page":"Other utilities","title":"General outputs","text":"","category":"section"},{"location":"misc/misc/#Outputs-for-post-processing","page":"Other utilities","title":"Outputs for post-processing","text":"","category":"section"},{"location":"misc/misc/","page":"Other utilities","title":"Other utilities","text":"The following tools can be used to generate outputs that can be further post-processed with other code.","category":"page"},{"location":"sizing/sizing/#Design-and-evaluation","page":"Design and evaluation","title":"Design and evaluation","text":"","category":"section"},{"location":"sizing/sizing/#sizing","page":"Design and evaluation","title":"Sizing the aircraft","text":"","category":"section"},{"location":"sizing/sizing/","page":"Design and evaluation","title":"Design and evaluation","text":"The aircraft is sized via a fixed point iteration for the design mission (size_aircraft!()). The performance of the design can be evaluated for the design (imission = 1) and off-design (imission >= 2) missions via fly_mission!().","category":"page"},{"location":"sizing/sizing/","page":"Design and evaluation","title":"Design and evaluation","text":"size_aircraft!() is typically the driving function in an analysis, as in the first example. The sizing analysis calls the various performance subroutines (e.g., fuselage_drag!(), wing_weights!(), aircraft_drag!(), _mission_iteration!(), etc.) as shown in the TASOPT flowchart. These subroutines are called automatically within _size_aircraft!(), which is wrapped by the user-facing size_aircraft!().","category":"page"},{"location":"sizing/sizing/","page":"Design and evaluation","title":"Design and evaluation","text":"details: 🖥️ Code structure - Aircraft sizing\nThe aircraft-sizing function requires an aircraft object as input. See read_aircraft_model() to get an idea of the fields that are required in this object. This object is unpacked into storage arrays and other component objects, such as wing, fuselage or engine. The eventual aim is to eliminate all data storage array and replace them by component objects but this is still work in progress.  The first major function called within size_aircraft!() is fuselage_drag!(), which calculates the fuselage boundary layer properties and drag coefficients for start-of-cruise; these are then used in other mission points. size_aircraft!() then uses simplified methods to initialize the relevant aircraft weights and parameters, unless the user specifies otherwise with an optional input (init_weight=true). The bulk of the computational cost and time is spent in the weight sizing loop. After the weight sizing loop is completed, the aircraft takeoff performance and field lengths are calculated using takeoff!().Weight sizing loopsize_aircraft!() performs a fixed point iteration by sequentially running weight and performance models for the different aircraft components. This is done via a for loop that gets terminated once the maximum aircraft weight has converged within a desired tolerance. The solver will fail to converge for infeasible combinations of aircraft and missions. The solver may fail to converge due to poor initial guesses (or conditioning); this can be addressed by adjusting the initial guess or raising the maximum number of iterations.The fuselage weight is calculated first in the sizing loop through fusew!(). Then, the total maximum takeoff weight gets recomputed and there is a check for whether the sizing loop is terminated. If weight has not converged, the loop continues.The wing geometry is set by running set_wing_geometry!() and the wing pitching moments are computed through wing_CM(). The horizontal and vertical tail geometry is computed through tail_loading!(). Finally, the weights of the three aerodynamic surfaces are calculated by running wing_weights!().If the aircraft requires an insulated fuel tank in the fuselage, for example, if the fuel is cryogenic, the tank is sized using tanksize!(); this function calculates the structural weight and sizes the thermal insulation. For details on how the fuel tank is sized, see Fuel tanks. The sized tank dimensions are then use to recalculate the fuselage geometry to accommodate the tank in update_fuse!().The weight and balance of the aircraft at start-of-cruise is adjusted using balance_aircraft!(). This can move the wing, resize the horizontal tail, or change the tail trim to achieve a desired metric for longitudinal stability (e.g., a set static margin).The total drag at start-of-cruise, which is the engine design point, is calculated using aircraft_drag!(). This function calls a combination of models for the drag of aerodynamic surfaces, engine nacelle, and induced drag at the Trefftz plane.The engines are sized at the start-of-cruise to produce a total thrust force equal to the aircraft drag, as computed by aircraft.engine.enginecalc!(), a specifiable function in the engine object. This field stores a user defined function for the engine performance. Although the user is free to use alternative models by modifying the engine object, TASOPT currently includes a two-spool turbofan engine model. The turbofan engine functions are called via a wrapper, tfwrap!(), which in turns calls the engine calculation function tfcalc!().Once the engines are sized, the fuel demand at every point in the mission is calculated using _mission_iteration!(). This function in turn recalculates the balance, drag, and engine performance at every point. Further details on mission are provided below. _mission_iteration!() is usually the greatest time sink in an aircraft sizing. The weight gets updated after running _mission_iteration!() and the loop restarts.","category":"page"},{"location":"sizing/sizing/#mission","page":"Design and evaluation","title":"Mission evaluation","text":"","category":"section"},{"location":"sizing/sizing/","page":"Design and evaluation","title":"Design and evaluation","text":"The function _mission_iteration!() contains the fuel burn calculation for the entire mission. It can be used both in sizing, as part of the iteration to obtain a converged aircraft, or in off-design, to calculate the performance of an already-designed airplane. Rather than calling _mission_iteration!() directly, users should call its user-facing wrapper, fly_mission!().","category":"page"},{"location":"sizing/sizing/","page":"Design and evaluation","title":"Design and evaluation","text":"details: 🖥️ Code structure - Mission\nThe _mission_iteration!() function simulates the entire mission of an aircraft, calculating fuel burn and other mission variables.From the altitude, the function sets the initial conditions including temperature, pressure, and density atmos(). Then, the lift coefficient is interpolated over the climb and descent points to ensure smooth transitions between different phases of the mission.Next, the function estimates the takeoff speed and sets the velocity and Reynolds number over the climb and descent points. This involves calculating the takeoff lift coefficient and using it to estimate the takeoff speed. The Reynolds number is then calculated based on the takeoff speed and other atmospheric conditions.The function proceeds to calculate the climb and descent parameters using aerodynamic and engine performance models. It integrates the climb and descent trajectories using a predictor-corrector scheme to update the range, time, and weight fractions.Once the climb and descent parameters are set, the function sets the conditions for the cruise phase, including altitude, speed, and fuel consumption. It calculates the fuel burn and weight fractions for the entire mission via calls to engine.enginecalc!(), and adds any vented fuel. This involves adjusting the aircraft's balance and trim settings via calls to balance_aircraft!() to ensure stability throughout the mission, and recalculating the drag via aircraft_drag!().The function also sets up the climb points at equal altitude intervals and calculates the available thrust assuming maximum-throttle climb. It initializes the climb integrands and integrates the trajectory over the climb phase. The function calculates the cruise-climb angle based on available thrust and atmospheric conditions.The descent phase is then set up, with the function interpolating the descent points and integrating the time and weight over the descent. It calculates the velocity, Mach number, and Reynolds number for each descent point and adjusts the pitch trim by adjusting the horizontal tail lift coefficient.Finally, the function calculates the mission fuel fractions and weights, including the weight of any vented fuel; it updates the mission parameters, such as the takeoff and fuel weights, and computes the mission's payload-fuel energy intensity (PFEI; a productivity-specific energy metric in kJ/kg-km),mathrmPFEI = fracW_fbmathrmLHVg W_pay Rwhere W_fb is the mission fuel burn weight, mathrmLHV is the fuel's lower heating value, g is the acceleration of gravity, W_pay is the payload weight, and R is the mission range.","category":"page"},{"location":"sizing/sizing/#missionexec","page":"Design and evaluation","title":"On- and off-design performance","text":"","category":"section"},{"location":"sizing/sizing/","page":"Design and evaluation","title":"Design and evaluation","text":"The function fly_mission!() can calculate the off-design performance of a sized aircraft: it runs the aircraft through a mission with different range, payload, and conditions to the design mission. For this purpose, it calls _mission_iteration!() and iterates the fuel burn until a converged takeoff mass is reached. If called on the design mission, the on-design performance is recovered. See PayloadRange() for an example of how fly_mission!() can be used.","category":"page"},{"location":"sizing/sizing/#Function-documentation","page":"Design and evaluation","title":"Function documentation","text":"","category":"section"},{"location":"sizing/sizing/#TASOPT.size_aircraft!","page":"Design and evaluation","title":"TASOPT.size_aircraft!","text":"size_aircraft(ac::aircraft; iter=35, initwgt=false, Ldebug=false,\n    printiter=true, saveOD=false)\n\nsizes the given aircraft instance. A light wrapper around the _size_aircraft! function, which does the actual work.\n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT._size_aircraft!","page":"Design and evaluation","title":"TASOPT._size_aircraft!","text":"_size_aircraft!(ac; itermax=35,\nwrlx1=0.5, wrlx2=0.9, wrlx3=0.5, initwgt=false, initializes_engine=true, \niairf=1, Ldebug=false, printiter=true, saveODperf=false)\n\nMain weight sizing function. Calls on various sub-functions to calculate weight of fuselage, wings, tails, etc., and iterates until the MTOW converges to within a specified tolerance. Formerly, wsize().\n\nwarning: Warning\n_size_aircraft!() Should not be called directly by users, instead use size_aircraft!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:Array of flags that control design choices - fuel types, where to store fuel, etc.\nGeometric and structural parameters - dimensions primarily\nAerodynamic parameters - CL, CD, KE dissipation, etc.\nMission-specific parameters - alt, mach, P, T etc.\nEngine-specific parameters Outputs:No explicit outputs. Computed quantities are saved to par arrays of aircraft model.\n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT.fly_mission!","page":"Design and evaluation","title":"TASOPT.fly_mission!","text":"fly_mission!(ac, imission, itermax, initializes_engine, opt_prescribed_cruise_parameter)\n\nRuns the aircraft through the specified mission, computing and converging the fuel weight. Formerly, fly_offdesign_mission!().\n\ndetails: 🔃 Inputs and Outputs\n\n\nInputs:\n\nac::aircraft: Aircraft with first mission being the design mission\nimission::Int64: Off design mission to run (Default: 1)\nitermax::Int64: Maximum iterations for sizing loop\ninitializes_engine::Boolean: Use design case as initial guess for engine state if true\nopt_prescribed_cruise_parameter::String: option for whether cruise altitude or lift coefficient is specified. Options are \"altitude\" or \"lift_coefficient\"\n\nOutputs:\n\nNo explicit outputs. Computed quantities are saved to par arrays of aircraft model for the mission selected\n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT.aerodynamics.fuselage_drag!","page":"Design and evaluation","title":"TASOPT.aerodynamics.fuselage_drag!","text":"fuselage_drag!(fuse, parg, para, ip)\n\nCalculates surface velocities, boundary layer, wake  for a quasi-axisymmetric body in compressible flow. Formerly, fusebl!().\n\nA compressible source line represents the potential flow. An integral BL formulation with lateral divergence represents the surface BL and wake. An added-source distribution represents the viscous displacement influence on the potential flow. The body shape is defined by its area and perimeter distributions A(x),  b0(x), which are defined by the various geometric parameters in parg. \n\ndetails: 🔃 Inputs and Outputs\nInputs:fuse::Fuselage: Fuselage model object.\nparg::AbstractArray{Float64}: Vector of aircraft model geometry parameters.\npara::AbstractArray{Float64}: Vector of aircraft model aerodynamic parameters.\nparm::AbstractArray{Float64}: Vector of aircraft model mission parameters.\nip::Integer: Index of flight point in par arrays.Outputs:No explicit outputs. Computed drag values are saved to para of aircraft model.\n\nSee Simplified Viscous/Inviscid Analysis for Nearly-Axisymmetric Bodies. See also _axisymm_BL and _axisymm_flow.\n\ncompat: Future Changes\nIn an upcoming revision, an aircraft struct and auxiliary indices will be passed in lieu of pre-sliced par arrays.\n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT.aerodynamics.set_wing_geometry!","page":"Design and evaluation","title":"TASOPT.aerodynamics.set_wing_geometry!","text":"set_wing_geometry!(W, CL, qinf, wing)\n\nSizes wing area, span, root chord from q, CL, W, AR at given point (taken as start-of-cruise in size_aircraft!).\n\ndetails: 🔃 Inputs and Outputs\nInputs:W::Float64: Aircraft weight.\nCL::Float64: Lift coefficient.\nqinf::Float64: Freestream dynamic head.\nwing::TASOPT.structures.Wing: Wing structure \n\nSee Sections 2.5 and 3.4.1 of the TASOPT Technical Desc.\n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT.aerodynamics.wing_CM","page":"Design and evaluation","title":"TASOPT.aerodynamics.wing_CM","text":"wing_CM(b,bs,bo, sweep, Xaxis,\n                   λt, λs, γt, γs,\n                   AR, fLo, fLt, cmpo, cmps, cmpt)\n\nCalculates components of wing pitching moment (C_M) about wing root axis:\n\nC_M = C_M0 + C_M1 (C_L - C_Lsurf)\n\nΔC_m surf = ΔC_m 0 + dCₘdCL  (C_L - C_Lh)\n\nFormerly, surfcm().\n\ndetails: 🔃 Inputs and Outputs\nInputs:b::Float64: Span.\nbs::Float64: Outer panel break span.\nbo::Float64: Root (fuselage) span.\nsweep::Float64: Sweep, degrees.-\tXaxis::Float64: Surface axis position.λt::Float64: Outer-panel chord taper ratio  ct/co.\nλs::Float64: Inner-panel chord taper ratio  cs/co.\nγt::Float64: Outer-panel load  taper ratio  pt/po.\nγs::Float64: Inner-panel load  taper ratio  ps/po.\nAR::Float64: Surface aspect ratio.\nfLo::Float64, fLt::Float64 : Wing root and tip load adjustment factors.\ncmpo::Float64,cmps::Float64,cmpt::Float64: Perpendicular sectional lift coefficient at wing root, break (\"snag\"), and tip.Outputs:CM0::Float64: Zero-lift surface pitching moment.\nCM1::Float64: Surface pitching moment including lift contribution.\n\nSee Section 2.6.3 of the TASOPT Technical Desc. See also wing_profiledrag_scaled and wing_profiledrag_direct.\n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT.aerodynamics.tail_loading!","page":"Design and evaluation","title":"TASOPT.aerodynamics.tail_loading!","text":"tail_loading!(tail,S,qne; t_fac = 1.0)\n\nCalculates stabilizer span, root chord, and root loading based on the  never-exceed dynamic pressure, maximum CL, sweep, and aspect ratio. Formerly, tailpo!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:tail::TASOPT.structures.tail: Tail structure.\nS::Float64: Stabilizer area.\nqne::Float64: Never-exceed dynamic pressure.\nt_fac::Float64: Tail Factor (1 for Htail/Wing, 2 for Vtail).Outputs:po::Float64: Stabilizer root loading.\nb::Float64: Stabilizer wingspan.\n\nSee Geometry or Section 2.3.2 and 2.9.6 of the TASOPT Technical Description.\n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT.structures.wing_weights!","page":"Design and evaluation","title":"TASOPT.structures.wing_weights!","text":"wing_weights!(wing, po, gammat, gammas, \n   Nload, We, neout, dyeout, neinn, dyeinn, sigfac, rhofuel; n_wings=2.0)\n\nCalculates Wing or Tail loads, stresses, weights of individual wing sections. Also returns the material gauges, torsional and bending stiffness. Formerly, get_wing_weights!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:wing::TASOPT.structures.Wing: Wing structure.\npo::Float64: Wing root loading magnitude.\ngammat::Float64: Wing outer section taper ratio.\ngammas::Float64: Wing inner section taper ratio.\nNload::Int: Max vertical load factor for wing bending loads.\nWe::Float64: Weight of the engine.\nneout::Int:  Number of engines mounted outboard of the wing break (strut attachment point).\ndyeout::Float64: Spanwise moment arm for outboard engines, measured from the wing break station.\nneinn::Int: Number of engines mounted inboard of the wing break (strut attachment point).\ndyeinn::Float64: Spanwise moment arm for inboard engines, measured from the wing break station.\nsigfac::Float64: Stress Factor.\nrhofuel::Float64: Density of the fuel.\nn_wings::Int64: Number of total wings (1 for Vtail).\n\nSee Geometry,  Wing/Tail Structures, and Section 2.7  of the TASOPT Technical Description. \n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT.structures.update_fuse!","page":"Design and evaluation","title":"TASOPT.structures.update_fuse!","text":"update_fuse!(ac, imission)\n\nFunction to update the fuselage layout when there is a change in fuselage fuel-tank length.\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac::aircraft: object with aircraft parameters\nimission::Int64: mission indexOutputs: No direct outputs; parameters in ac are modified.\n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT.engine.tfwrap!","page":"Design and evaluation","title":"TASOPT.engine.tfwrap!","text":"tfwrap!(ac, case, imission, ip, initializes_engine, iterw = 0)\n\nCalls the turbofan sizing or off-design performance functions for the aircraft's turbofan model. This function is basically a wrapper on tfcalc!, going from the basic engine inputs to those required by the function and storing the outputs.\n\ndetails: 🔃 Inputs and Outputs\nInput:ac::aircraft: aircraft object\ncase::String: case identifier, e.g. \"sizing\" or \"off_design\"\nimission::Int64: mission index\nip::Int64: mission point index\ninitializes_engine::Bool: flag to initialize engine:\ntrue: initialize variables for iteration in engine\nfalse: use current variables as initial guesses in engine\niterw::Int64: sizing loop iterationOutput: No direct outputs. The ac object gets modified with the engine parameters.\n\n\n\n\n\n","category":"function"},{"location":"sizing/sizing/#TASOPT._mission_iteration!-Tuple{Any, Any, Any}","page":"Design and evaluation","title":"TASOPT._mission_iteration!","text":"_mission_iteration!(ac, imission, Ldebug; calculate_cruise = false)\n\nRuns aircraft through mission, calculating fuel burn and other mission variables. Formerly, mission!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac::aircraft: aircraft data storage object\nimission::Int64: mission index\nLdebug::Bool: debugging flag\n\nNOTE:  This routine assumes that estimates of the climb-leg flight path  gamma angles are passed in via para[iagamV,ipclimb1:ipclimbn]. These appear as cos(gamma) factors in the climb equations, and can be passed in as zero with only a minor error. They are updated and returned in the same para[iagamV,ip] array.\n\n\n\n\n\n","category":"method"},{"location":"sizing/sizing/#TASOPT.takeoff!-Tuple{Any}","page":"Design and evaluation","title":"TASOPT.takeoff!","text":"takeoff!(ac)\n\nCalculates takeoff parameters and balanced field length. The aircraft must be defined in parg array. The ipstatic and iprotate points are assumed to exist.\n\n\n\n\n\n","category":"method"},{"location":"sizing/sizing/#TASOPT.PayloadRange","page":"Design and evaluation","title":"TASOPT.PayloadRange","text":"PayloadRange(ac_og; Rpts, Ppts, plots_OEW, filename, itermax, initializes_engine, Ldebug)\n\nFunction to plot a payload range diagram for an aircraft\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac_og::aircraft: Aircraft structure for payload range diagram.\nRpts::Int64: Density of ranges to be plot (Optional).\nPpts::Int64: Density of payloads to be plot (Optional).\nfilename::String: filename string for the plot to be stored (Optional).\nplots_OEW::Bool: Whether to plot OEW+Payload (true) on the y-axis or just Payload (false, default) (Optional).\nitermax::Int64: Max Iterations for fly_mission! loop (Optional).\ninitializes_engine::Bool: Use design case as initial guess for engine state if true (Optional)\nspecifying_cruise::String: option for whether cruise altitude or lift coefficient is specified. Options are \"altitude\" or \"lift_coefficient\"\nLdebug::Bool: verbosity flag. false by default, hiding outputs as PR sweeps progress (Optional).\n\n\n\n\n\n","category":"function"},{"location":"balance/balance/#Aircraft-Stability","page":"Stability","title":"Aircraft Stability","text":"","category":"section"},{"location":"balance/balance/","page":"Stability","title":"Stability","text":"This module provides functions to size the tail surfaces and balance the aircraft to achieve pitch trim throughout flight when called by _size_aircraft!().","category":"page"},{"location":"balance/balance/","page":"Stability","title":"Stability","text":"balance_aircraft!() makes adjustments as described below to achieve pitch trim. It calculates the aircraft's resulting center of gravity (xCG), center of pressure (xCP), and neutral point (xNP) at a specific flight point. To meet the pitch trim requirement, the routine adjusts one of (i) the horizontal tail's lift coefficient, (ii) its area, or (iii) the axial location of the wing box. In almost all the use cases, only option (i) adjusting the horizontal tail's lift coefficient is relevant for trim calculations.","category":"page"},{"location":"balance/balance/","page":"Stability","title":"Stability","text":"warning: Some `balance_aircraft!()` options change the aircraft design\nExercise caution if options (ii) or (iii) are being used as these options alter the design of the aircraft (i.e., they should not be used in off-design cases).","category":"page"},{"location":"balance/balance/","page":"Stability","title":"Stability","text":"size_htail() performs a more involved stability analysis: it determines the horizontal tail area (Sh) and wing box position (xwbox), solving for pitch trim and static stability across all flight conditions.","category":"page"},{"location":"balance/balance/","page":"Stability","title":"Stability","text":"Both stability analyses call the following helper functions.","category":"page"},{"location":"balance/balance/","page":"Stability","title":"Stability","text":"CG_limits() computes forward (xcgF) and aft (xcgB) CG limits based on payload and fuel distribution. \nLastly, cabin_centroid() calculates the cabin centroid (xcabin) and length (lcabin), accounting for fuel tank placement and fuselage geometry.","category":"page"},{"location":"balance/balance/","page":"Stability","title":"Stability","text":"details: 📖 Theory - Pitch trim and stability requirements\nEvery operating point must meet the requirement of pitch trim, which is equivalent to the centers of weight and pressure coinciding. This is enforced by requiring that the following total-moment residual is zero.mathcalR_Mleft( x_textwbox S_h C_Lh C_L r_textfuel r_textpay xi_textpay right) equiv x_textCG - x_textCP = fracxWW + fracc_o  C_mC_L = 0An aircraft must also have some minimum amount of static pitch stability, which means that the rearmost center of gravity must be ahead of the neutral point by the static margin fraction f_SM of the mean aerodynamic chord. This is met when the following stability residual is zero:mathcalR_S_hleft( x_textwbox S_h r_textfuel r_textpay xi_textpay right) equiv x_textCG - x_textNP + f_textSM  c_textMA = 0","category":"page"},{"location":"balance/balance/#TASOPT.balance_aircraft!","page":"Stability","title":"TASOPT.balance_aircraft!","text":"  balance_aircraft!(ac, imission, ip, rfuel, rpay, ξpay, opt_trim_var; Ldebug)\n\nComputes the aircraft's center of gravity (xCG), center of pressure (xCP), and neutral point (xNP) based on payload, fuel distribution, and trim adjustments. Makes one of three (or none) changes to achieve pitch trim. Formerly, balance().\n\nDescription This routine performs a CG and stability analysis for a given aircraft configuration. It calculates the total weight and moment by accounting for:\n\nPayload distribution (rpay, ξpay).\nFuel distribution (rfuel).\nStructural components (fuselage, wing, tail, landing gear).\nTrim adjustments (opt_trim_var), which modify horizontal tail lift, area, or wing box location.\n\nThe routine computes the **neutral point (xNP), indicating the aircraft's longitudinal static stability, and may achieve pitch trim by adjusting for one of the following:\n\nopt_trim_var Adjustment Method\n\"none\" No adjustments. Only calculates and returns the neutral point (xNP)\n\"CL_htail\" Adjusts horizontal tail lift coefficient (CLh)\n\"S_htail\" Adjusts horizontal tail area (Sh)\n\"x_wingbox\" Adjusts wing box location (xwbox)\n\ndetails: 🔃 Inputs and Outputs\nInputsac : Aircraft object\nimission : Mission index (used for unpacking mission-specific parameters; 1 is design mission).\nip : flight point index (used for aerodynamic/weight calculations).\nrfuel : Fuel fraction.\nrpay : Payload fraction.\nξpay : Payload distribution factor (0.0 = front-loaded, 1.0 = rear-loaded).\nopt_trim_var : Variable to adjust to achieve pitch trim (\"none\" for no adjustments, \"CL_htail\" for htail lift coefficient, \"S_htail\" for htail area, \"x_wingbox\" for wing box location).\nLdebug : Optional debug flag (default: false). If true, prints debug information.Outputs    No explicit return values, but updates fields inside para. Namely:para[iaxCG] : Computed center of gravity (xCG).\npara[iaxCP] : Computed center of pressure (xCP).\npara[iaxNP] : Computed neutral point (xNP).\n\nNotes\n\nUses CG_limits() to compute CG limits (xcgF, xcgB).\nUses cabin_centroid() to determine cabin location.\nIf there is fuel in the wings (ac.options.has_wing_fuel), it does not shift between CG cases.\nxNP is affected by engine placement (xengcp), aerodynamics (CMw1, CMh1), and fuel distribution.\n\n\n\n\n\n","category":"function"},{"location":"balance/balance/#TASOPT.CG_limits","page":"Stability","title":"TASOPT.CG_limits","text":"CG_limits(ac; Ldebug::Bool = false)\n\nComputes the most forward (xcgF) and most rearward (xcgB)  center of gravity (CG) locations based on payload extremes, along with the corresponding payload fractions. Formerly, cglpay().\n\nDescription\n\nThis function determines the CG shift due to varying passenger and fuel load configurations.\n\nxcgF: The forward-most CG position, assuming worst-case forward payload arrangement.\nxcgB: The rearward-most CG position, assuming worst-case aft payload arrangement.\nrpayF: The fraction of payload contributing to the forward-most CG.\nrpayB: The fraction of payload contributing to the rearward-most CG.\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac : Aircraft object\nLdebug : Debug flag for verbose output (default: false, optional)Outputs: Returns six values:rfuelF : Fuel fraction for forward CG case (always 0.0).\nrfuelB : Fuel fraction for aft CG case (always 0.0).\nrpayF : Payload fraction contributing to the forward CG (xcgF).\nrpayB : Payload fraction contributing to the rearward CG (xcgB).\nxcgF : Most forward CG location.\nxcgB : Most rearward CG location.\n\n\n\n\n\n","category":"function"},{"location":"balance/balance/#TASOPT.size_htail","page":"Stability","title":"TASOPT.size_htail","text":"size_htail(ac, paraF, paraB, paraC)\n\nSolves for the feasible horizontal tail area (Sh) and wing box location  (xwbox) to ensure: (1) pitch trim req't with forward CG and (2) stability requirement with aft CG across different flight conditions.\n\nThis routine iteratively adjusts:\n\nHorizontal tail area (Sh): Ensuring sufficient control authority.\nWing box location (xwbox): Maintaining static and dynamic stability.\n\nThe routine considers:\n\nMax and min CG locations** (xcgF, xcgB) computed using CG_limits().\nAerodynamic parameters (paraF, paraB, paraC).\nStatic margin constraints (SM).\nFuel and payload distribution effects.\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac : Aircraft object\nparaF[.] : Aerodynamic parameters for the forward CG trim condition.\nparaB[.] : Aerodynamic parameters for the aft CG stability condition.\nparaC[.] : Aerodynamic parameters for the cruise tail lift condition.Outputs:   No direct return values. Instead, the function updates key fields inside ac:htail.layout.S : Horizontal tail area (Sh).\nwing.layout.box_x : Wing box location (xwbox).\nwing.layout.x : Wing location (adjusted for xwbox).\n\nNote: two flags determine the sizing strategy:\n\n  - `htail.opt_sizing`\n        * = \"fixed_Vh\"    set Sh from prescribed tail volume\n        * = \"CLmax_fwdCG\" set Sh to meet the \"worst-case\" scenario: max wing CL with most fwd CG, with an assumed max CLh\n\n  - `ac.opt_move_wing`\n        * = \"fixed\"         no changes to wing location\n        * = \"fixed_CLh\"     adjust wingbox location to set tail lift at cruise, CLh = CLhspec\n        * = \"min_static_margin\" adjust wingbox location to get SM = SMmin at aft-CG\n\nThe two flags can be set independently and affect how the two stability residuals are driven to zero. The 2x2 system is built sequentially as annotated in the source code for this function. \n\n\n\n\n\n","category":"function"},{"location":"balance/balance/#TASOPT.cabin_centroid","page":"Stability","title":"TASOPT.cabin_centroid","text":"cabin_centroid(nftanks, fuse, xftankaft, lftank)\n\nComputes the centroid (xcabin) and length (lcabin) of the passenger cabin accounting for the presence and location of fuel tanks.\n\ndetermines the cabin centroid (xcabin) and cabin length (lcabin) based on:\n\nThe number of fuel tanks (nftanks).\nWhether the fuel tank is located at the front or rear (xftankaft).\nThe length of the fuel tank (lftank).\nThe fuselage layout (fuse.layout), including pressure shell and cylindrical section dimensions.\n\nThe cabin centroid is calculated as the midpoint of the effective passenger cabin length, which varies depending on fuel tank placement.\n\ndetails: 🔃 Inputs and Outputs\nInputs:nftanks : Number of fuel tanks (0, 1, or 2).\nfuse : Fuselage object containing geometry properties.\nxftankaft : Binary flag (0.0 if fuel tank is at the front, otherwise rear).\nlftank : Length of the fuel tank.Outputs:xcabin : x-coordinate of the cabin centroid.\nlcabin : Length of the passenger cabin.\n\n\n\n\n\n","category":"function"},{"location":"examples/gradient_based_optimization/#Example-for-a-Gradient-Based-Optimization","page":"Gradient Based Optimization","title":"Example for a Gradient Based Optimization","text":"","category":"section"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"This example shows how to perform a gradient based optimization on a TASOPT model. It uses the IPOPT optimization module using a central, relative finite difference sensitivity module.","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"NOTE:  We are currently working on a autodiff based sensitivity module.","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"For this example, the design variables are:","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"Aspect Ratio: AR\nLift Coefficient: Cl  \nWing Sweep: Λ\nTt4 at Cruise: Tt4\nFan Pressure ratio: pif","category":"page"},{"location":"examples/gradient_based_optimization/#Initialiation-and-loading-models","page":"Gradient Based Optimization","title":"Initialiation and loading models","text":"","category":"section"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"Start the script importing the necessary modules.","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"# Import modules\nusing TASOPT\nusing JuMP\nusing Ipopt\nusing Test\ninclude(__TASOPTindices__)","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"Set the relative tolerance used in the Finite difference method","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"epsilon = 1e-5","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"Load the default aircraft model and size it to get initial values:","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"default_model = load_default_model()\nsize_aircraft!(default_model)","category":"page"},{"location":"examples/gradient_based_optimization/#Setting-Optimization-Parameters","page":"Gradient Based Optimization","title":"Setting Optimization Parameters","text":"","category":"section"},{"location":"examples/gradient_based_optimization/#Set-the-input-parameters","page":"Gradient Based Optimization","title":"Set the input parameters","text":"","category":"section"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"input_params = [\n    :(ac.parg[igAR]), \n    :(ac.para[iaCL,ipcruise1:ipcruise2,1]),\n    :(ac.parg[igsweep]),\n    :(ac.pare[ieTt4, ipcruise1:ipcruise2, 1]),\n    :(ac.pare[iepif, ipcruise1, 1]) ,\n]\n\n# Formatting params for usage \nparams = map(p -> TASOPT.format_params(TASOPT.expr_to_string(p)), input_params)","category":"page"},{"location":"examples/gradient_based_optimization/#Set-the-Upper-and-Lower-limits-for-all-design-variables-as-well-as-initial-values","page":"Gradient Based Optimization","title":"Set the Upper and Lower limits for all design variables as well as initial values","text":"","category":"section"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"lower      = [9.0 , 0.53, 25.0, 1400.0, 1.25]\nupper      = [11.0, 0.60, 30.0, 1650.0, 2.0 ] \ninitial    = [10.5, 0.57, 26.0, 1580.0, 1.685]\n","category":"page"},{"location":"examples/gradient_based_optimization/#Objective-and-Constraint-Functions","page":"Gradient Based Optimization","title":"Objective and Constraint Functions","text":"","category":"section"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"In this optimization we will have a constraint on max fuel weight, max span, min climb gradient, and max Tt3. Set functions that return the objective value and constraints of your optimization","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"function pfei_fn(ac)\n    return ac.parm[imPFEI]\nend\n\nfunction wfuel_fn(ac)\n    return ac.parg[igWfuel]/ac.parg[igWfmax]\nend\n\nfunction span_fn(ac)\n    return ac.parg[igb]/ac.parg[igbmax]\nend\n\nfunction gtoc_fn(ac)\n    return ac.para[iagamV, ipclimbn,1]/ac.parg[iggtocmin]\nend\n\nfunction tt3_fn(ac)\n    maxtt3 = 900\n    return maximum(ac.pare[ieTt3, :, 1])/maxtt3\nend\n\n# Make an array that stores all these functions\ncon_f_arr = [\n    pfei_fn, wfuel_fn, span_fn, tt3_fn, gtoc_fn\n]","category":"page"},{"location":"examples/gradient_based_optimization/#Objective-Function","page":"Gradient Based Optimization","title":"Objective Function","text":"","category":"section"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"# Function that sizes aircraft and returns both objective value and constraint values\nfunction sizing_ac(x::T...) where {T<:Real}\n    ac = deepcopy(default_model)\n    # Set params\n    for (i,x_i) in enumerate(x)\n        field_path, index = params[i]\n        TASOPT.setNestedProp!(ac, field_path, x_i, index)\n    end\n\n    try\n        size_aircraft!(ac,printiter=false)\n        return [con_f_arr[i](ac) for i in 1:length(con_f_arr)]\n    catch\n        println(\"size_aircraft! FAILED\")\n        return [Inf for i in 1:length(con_f_arr)]\n    end\n    \nend","category":"page"},{"location":"examples/gradient_based_optimization/#Gradient-Function","page":"Gradient Based Optimization","title":"Gradient Function","text":"","category":"section"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"function gradient_all(x::T...) where {T<:Real}\n    ac = deepcopy(default_model)\n    # Set params\n    for (i,x_i) in enumerate(x)\n        field_path, index = params[i]\n        TASOPT.setNestedProp!(ac, field_path, x_i, index)\n    end\n    return TASOPT.get_sensitivity(input_params; model_state=ac, eps=epsilon, optimizer=true, f_out_fn=con_f_arr)\nend","category":"page"},{"location":"examples/gradient_based_optimization/#Memoization","page":"Gradient Based Optimization","title":"Memoization","text":"","category":"section"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"In order to reduce the function calls to size_aircraft we shall be using memoization to chache objective and constraint values for a specific point in the design space","category":"page"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"function memoize(foo::Function, n_outputs::Int)\n    last_x, last_f = nothing, nothing\n    function foo_i(i, x::T...) where {T<:Real}\n        if x !== last_x\n            last_x, last_f = x, foo(x...)\n        end\n        return last_f[i]::T\n    end\n    return [(x...) -> foo_i(i, x...) for i in 1:n_outputs]\nend\n\nfunction memoize_sensitivity(foo::Function, n_outputs::Int)\n    last_x, last_f = nothing, nothing\n    function foo_s!(i, g::AbstractVector{T}, x::T...) where {T<:Real}\n        if x !== last_x\n            last_x, last_f = x, foo(x...)\n        end\n        if (size(g)[1] >0)\n            for (k,grads) in enumerate(g)\n                g[k] = last_f[i][k]\n            end\n        end\n    end\n    return [(x...) -> foo_s!(i, x...) for i in 1:n_outputs]\nend\n\nmemoized_size_ac = memoize(sizing_ac, length(con_f_arr))\nmemoized_fd_ac = memoize_sensitivity(gradient_all, length(con_f_arr))","category":"page"},{"location":"examples/gradient_based_optimization/#Running-the-optimization","page":"Gradient Based Optimization","title":"Running the optimization","text":"","category":"section"},{"location":"examples/gradient_based_optimization/","page":"Gradient Based Optimization","title":"Gradient Based Optimization","text":"model = Model(Ipopt.Optimizer)\n# set_silent(model)\nset_optimizer_attribute(model, \"tol\", 1e-3)\nset_optimizer_attribute(model, \"nlp_scaling_method\", \"gradient-based\")\nset_optimizer_attribute(model, \"obj_scaling_factor\", 1.0)\nset_optimizer_attribute(model, \"nlp_scaling_max_gradient\", Float64(1))\nset_optimizer_attribute(model, \"nlp_scaling_min_value\", 1e-8)\n\n@variable(model, lower[i] <= x[i=1:length(initial)] <= upper[i], start=initial[i])\n\n@operator(model, f_size_ac, length(initial), memoized_size_ac[1],memoized_fd_ac[1])\n@operator(model, f_con_wfuel, length(initial), memoized_size_ac[2],memoized_fd_ac[2])\n@operator(model, f_con_b, length(initial), memoized_size_ac[3],memoized_fd_ac[3])\n@operator(model, f_con_tt3, length(initial), memoized_size_ac[4],memoized_fd_ac[4])\n@operator(model, f_con_gtoc, length(initial), memoized_size_ac[5],memoized_fd_ac[5])\n\n@objective(model, Min, f_size_ac(x...))\n@constraint(model, f_con_wfuel(x...) <= 1)\n@constraint(model, f_con_b(x...) <= 1)\n@constraint(model, f_con_tt3(x...) <= 1)\n@constraint(model, f_con_gtoc(x...) >= 1)\n\noptimize!(model)\n\nprintln(\"Finished optimization with $(value.(x))\")\n","category":"page"},{"location":"aero/theory_trefftz_plane/","page":"-","title":"-","text":"details: 📖 Theory - induced drag $C_{d,i}$\nThe induced drag is calculated using a discrete vortex Trefftz-Plane analysis. The circulation of the wing wake immediately behind the trailing edge is beginaligned\nGamma_rm wing scriptstyle (eta)\n = fractildep scriptstyle (eta)rho_scriptscriptstyle inftyV_scriptscriptstyle infty\n simeq  fracp scriptstyle (eta)rho_scriptscriptstyle inftyV_scriptscriptstyle infty  sqrt1 - eta^k_t\n\nk_t  simeq 16\nendalignedwhere the approximation realistically represents the tip lift rolloff for typical taper ratios, and is consistent with the assumed f_L_scriptstyle tsimeq -005 value for the tip lift loss factor. This circulation is convected into the wake along streamlines which will typically constrict behind the fuselage by continuity. The Figure above shows two possible aft fuselage taper shapes, giving two different wake constrictions.An annular streamtube at the wing contracts to another annular streamtube in the wake with the same cross-sectional area. The y and y locations on the wing and wake which are connected by a streamline are therefore related by the correspondence function. beginaligned\nyscriptstyle (y) =  sqrt y^2 - y_o^2 + y_o^2\nendalignedThe Trefftz Plane circulation Gamma scriptstyle (y) is then given by the coordinate shift. The mapping function yscriptstyle (y) is not defined for y    y_o, so the circulation there is simply set from the y_o value. beginaligned\nGamma_rm wake scriptstyle (y) =  \nleft\nbeginarraylcl\nGamma_rm wing left( y scriptstyle (y)right)\n   y  y_o \nGamma_rm wing left( y_o right)\nendarray\nright\nendalignedThe Trefftz Plane analysis uses point vortices. The circulation ([Gamwake]) is evaluated at the midpoints of n intervals along the wake trace, spaced more or less evenly in the Glauert angle to give a cosine distribution in physical space. The wake's vertical z positions are simply taken directly from the wing. beginaligned\ntheta_i+12  =  fracpi2  fraci-12n\nhspace2ex  hspace2ex i = 1 ldots n\n\ny_i+12  =  fracb2  cos theta_i+12\n\ny_i+12  =  sqrty_i+12^2 - y_o^2 + y_o^2\n\nz_i+12  =  z_i+12\n\nGamma_i+12  =  Gamma_rm wing (y_i+12)\nendalignedThe locations of n+1 trailing vortices are computed similarly. beginaligned\ntheta_i  =  fracpi2  fraci-1n\nhspace2ex  hspace2ex i = 1 ldots n+1\n\ny_i  =  fracb2  cos theta_i\n\ny_i  =  sqrty_i^2 - y_o^2 + y_o^2\n\nz_i  =  z_i\nendalignedThe circulations of these trailing vortices are the differences of the adjacent bound circulations, with the circulation beyond the tips effectively zero. beginaligned\nbarGamma_i  =  \nleft\nbeginarraylcl\nhspace65ex\n-Gamma_i-12    i = 1 hspace35em mathrm(left tip)\n\nGamma_i+12-Gamma_i-12    i = 2 ldots n\n\nGamma_i+12    i = n+1 hspace2em mathrm(right tip)\nendarray\nright\nendalignedThe above definitions are also applied to the horizontal tail, with its discrete points simply appended to the list and n increased accordingly.The Trefftz plane calculation proceeds by first calculating the y-z wake velocity components at the y_i+12z_i+12 interval midpoints, induced by all the trailing vortices and their left-side images. beginaligned\nv_i+12  =  sum_j=1^n+1 fracbarGamma_j2pi \nleft\nfrac-(z_i+12-z_j)\n      (y_i+12-y_j)^2\n     + (z_i+12-z_j)^2\n-\nfrac-(z_i+12-z_j)\n      (y_i+12+y_j)^2\n     + (z_i+12-z_j)^2\nright\nhspace2em\n\nw_i+12  =  sum_j=1^n+1 fracbarGamma_j2pi\nleft\nfrac y_i+12-y_j\n     (y_i+12-y_j)^2\n    + (z_i+12-z_j)^2\n-\nfrac y_i+12+y_j\n     (y_i+12+y_j)^2\n    + (z_i+12-z_j)^2\nright\nendalignedThe overall lift and induced drag are then computed using the Trefftz Plane vertical impulse and kinetic energy. The sums are doubled to account for the left side image. beginaligned\nC_L_scriptscriptstyle TP  =  frac2textstyle frac12rho_scriptscriptstyle inftyV_scriptscriptstyle infty^2 S  sum_i=1^n \n rho_scriptscriptstyle inftyV_scriptscriptstyle infty Gamma_i+12  (y_i+1-y_i)\n\nC_D_scriptscriptstyle TP  =  frac2textstyle frac12rho_scriptscriptstyle inftyV_scriptscriptstyle infty^2 S  sum_i=1^n \n-fracrho_scriptscriptstyle infty2  Gamma_i+12 left\n      w_i+12 (y_i+1-y_i)\n -v_i+12 (z_i+1-z_i) right\nendalignedTo minimize any modeling and numerical errors incurred in the wake contraction model and the point-vortex summations, the final induced drag value is scaled by the square of the surface-integral and Trefftz-Plane drag values. beginaligned\nC_D_i  =  C_D_scriptscriptstyle TP left(fracC_LC_L_scriptscriptstyle TP right)^2\nendalignedThis is equivalent to using the Trefftz Plane analysis to calculate the span efficiency rather than the actual induced drag coefficient.","category":"page"},{"location":"structures/cabin_sizing/#cabin_sizing","page":"Cabin sizing","title":"Cabin sizing","text":"","category":"section"},{"location":"structures/cabin_sizing/","page":"Cabin sizing","title":"Cabin sizing","text":"When creating an aircraft input file, the fuselage geometry has to be specified (i.e., the pressure vessel start and end locations, cylindrical portion start and end locations and radius, guesses for the wing and tail). The user is given the option to resize the fuselage if, for example, these parameters are not known or if the radius is to be optimized. This can be accomplished via structures.update_fuse_for_pax!().  ","category":"page"},{"location":"structures/cabin_sizing/#Theory","page":"Cabin sizing","title":"Theory","text":"","category":"section"},{"location":"structures/cabin_sizing/","page":"Cabin sizing","title":"Cabin sizing","text":"details: 📖 Theory - Cabin sizing\nThe TASOPT input file requires the user to specify a radius and general fuselage layout, including the start and end of the pressure vessel, and the start and end of the cylindrical portions. Whether this provided layout is used or not depends on the flag calculate_cabin_length in the Fuselage.Geometry input field: this flag is False by default, implying that the fuselage length and layout does not get recalculated for the input radius. However, if the flag is set to True, the function structures.update_fuse_for_pax!() is used to update the fuselage length and layout to accommodate the desired number of passengers.To resize the fuselage, information about the number of passengers and seat properties are needed. The number of passengers used the resize the fuselage is set in the input file as exit_limit in Mission; this is assumed to be the maximum number of people that could fit in the cabin in an all-economy layout. The goal then is to determine the minimum cabin length corresponding to the specified radius and seat properties: seat pitch, width and height. Two key functions are used for this purpose:structures.find_floor_angles(): This function aims to determine the angular placement of the cabin floor inside the fuselage cross-section. If the cabin has a single deck, this is the angle that maximizes the cabin width. If the aircraft is a double-decker, the main (lower) cabin could be at any angle; the main-cabin angle must then be specified so that the upper-cabin angle can be calculated from the cabin height. The double-decker geometry problem is more involved and is described in the subsequent section.\nstructures.find_cabin_width() If the fuselage has a single deck, the angular position of the cabin floor is then used by the following function to calculate the maximum width corresponding to that section. For example, if the seat height is 0, the angular placement would be 0 and the maximum width of a single bubble fuselage is 2R_fuse. When the seat height is greater than 0, the effective cabin width is the distance between the top or bottom of the seats in the cabin, whichever is smallest.Once the geometric properties of the floor and cabin width have been determined, the seats are placed in the cabin so as to determine the total cabin length. A 10 ft offset from the front of the cabin is assumed. First, the number of seats abreast is determined by structures.findSeatsAbreast(). This function assumes an aisle width of 20 inches and a fuselage offset of 6 inches, as seats do not start at the edge of the fuselage. Once the number of seats abreast is known, the number of rows is calculated from the exit-limit number of passengers and the cabin length is calculated from the seat pitch, taking emergency exits into account.When the cabin length has been determined, the structures.update_fuse_for_pax!() proceeds to update the position of all the structural elements that have to be specified by the user, such as the cylinder and pressure vessel ends, horizontal and vertical tail placements, etc. To do this, the relative distances between these elements specified by the user are maintained. For example, the distance from the end of the fuselage to the horizontal and vertical tails is the same in the resized aircraft as in the user-defined parameters.","category":"page"},{"location":"structures/cabin_sizing/","page":"Cabin sizing","title":"Cabin sizing","text":"details: 📖 Theory - Double-decker aircraft\nWhen the cabin has two decks, determining the best layout is more involved as the position of the lower floor and the passenger split between the lower and upper cabins is not known in advance. In TASOPT, this is solved as an optimization problem: the optimization variables are the number of passengers in the lower cabin and the lower-cabin floor angle. The geometry of the cabin is shown in the figure below.(Image: cabin)The objective function to be minimized is the cabin length, which is the maximum of the lengths of the upper and lower cabins. An optimal design is expected to be one in which both cabins have similar lengths. Constraints are applied on the minimum cargo bay height, d_cargo, and on the minimum height of the upper cabin, d_cabin (by default 2 m). The available cargo bay height is calculated so that it can fit the width of a standard unit load device. The objective function is structures.find_double_decker_cabin_length(), which returns the maximum of the lengths of either cabins (which is used as the objective function), and the number of seats abreast in the main cabin for a later check (ignored in the optimization process). The optimization is done using the NLopt.jl optimization suite via structures.optimize_double_decker_cabin().Since there are only two optimization variables, this function uses the GN_AGS global optimizer. Once the minimum cabin length has been determined, the fuselage and component layouts get updated in structures.update_fuse_for_pax!() as in the single deck case.","category":"page"},{"location":"structures/cabin_sizing/","page":"Cabin sizing","title":"Cabin sizing","text":"details: 📖 Theory - Fuselage radius from seats abreast\nIn some circumstances, it may be of interest to calculate the minimum fuselage radius that results in a given number of seats abreast. If multiple fuselage radii are being tested, it is likely that the ones providing best performance are those with the narrowest cabin for a given number of seats abreast (and therefore cabin length).In TASOPT, this problem is solved as an optimization problem: the goal is to find the minimum fuselage radius such that the seats abreast in the main cabin are exactly equal to the desired number. This is done with  structures.find_minimum_radius_for_seats_per_row()(@ref).In this function, two optimizers are used. First, the global optimizer GN_DIRECT is used to find the approximate location of the solution with up to 500 function evaluations. This optimizer cannot handle equality constraints directly; instead, the constraint is introduced with a penalty function. The objective function is simply f = R_fuse+10^3 Delta swhere Delta s is the difference between the desired and actual seats per row for a given radius. The function that computes this difference for a given radius is structures.check_seats_per_row_diff(). ```Once the approximate solution has been found, a local optimizer LN_NELDERMEAD is used to polish off the solution at a lower computational cost. Finally, the solution is checked to verify it meets the equality constraint.","category":"page"},{"location":"structures/cabin_sizing/#Functions","page":"Cabin sizing","title":"Functions","text":"","category":"section"},{"location":"structures/cabin_sizing/#TASOPT.structures.update_fuse_for_pax!","page":"Cabin sizing","title":"TASOPT.structures.update_fuse_for_pax!","text":"update_fuse_for_pax!(ac)\n\nFunction to update the fuselage layout when the cabin length is not known a priori, for example if the radius is changed.  It sizes the cabin for the design number of passengers.\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac::aircraft: aircraft objectOutputs: Parameters in parg are modified. It also outputs:seats_per_row::Float64: number of seats per row in main cabin (lower deck if double decker)\n\n\n\n\n\n","category":"function"},{"location":"structures/cabin_sizing/#TASOPT.structures.find_floor_angles","page":"Cabin sizing","title":"TASOPT.structures.find_floor_angles","text":"find_floor_angles(is_doubledecker::Bool, Rfuse::Float64, dRfuse::Float64; θ1::Float64 = 0.0, h_seat::Float64 = 0.0, d_floor::Float64 = 0.0)\n\nThis function can be used to place the passenger decks inside the fuselage. It works for single deck or double decker cabins. It returns the angular position of each deck with respect to the center of the upper bubble.\n\ndetails: 🔃 Inputs and Outputs\nInputs:is_doubledecker::Bool: flag to indicate whether aircraft is a double decker\nRfuse::Float64: fuselage exterior radius (m)\ndRfuse::Float64: vertical shift of downward bubble (m)\nθ1::Float64: required in some cases; angle of main floor wrt upper bubble center (rad)\nh_seat::Float64: required in some cases; seat height (m)\nd_floor::Float64: required in some cases; distance between double decks (m)Outputs:θ1::Float64: angle of main floor wrt upper bubble center (rad)\nθ2::Float64: returned when double decker; angle of upper floor wrt upper bubble center (rad)\n\n\n\n\n\n","category":"function"},{"location":"structures/cabin_sizing/#TASOPT.structures.find_cabin_width","page":"Cabin sizing","title":"TASOPT.structures.find_cabin_width","text":"find_cabin_width(Rfuse::Float64, wfb::Float64, nfweb::Int64, θ::Float64, h_seat::Float64)\n\nThis function can be used to calculate the width of the passenger cabin from the double-bubble parameters and the floor angular position.\n\ndetails: 🔃 Inputs and Outputs\nInputs:Rfuse::Float64: fuselage exterior radius (m)\nwfb::Float64: lateral shift of double bubble (m)\nnfweb::Float64: number of vertical webs in fuselage\nθ::Float64: angle of floor wrt upper bubble center (rad)\nh_seat::Float64: seat height (m)Outputs:w::Float64: width of cabin (m).\n\n\n\n\n\n","category":"function"},{"location":"structures/cabin_sizing/#TASOPT.structures.findSeatsAbreast","page":"Cabin sizing","title":"TASOPT.structures.findSeatsAbreast","text":"findSeatsAbreast(cabin_width, \nseat_width = 19.0*in_to_m, aisle_halfwidth = 10.0*in_to_m, fuse_offset = 6.0*in_to_m)\n\nFunction to find the number of seats abreast that can fit in a given cabin width.\n\ndetails: 🔃 Inputs and Outputs\nInputs:cabin_width::Float64: width of cabin (m).\nseat_width::Float64: width of one seat (m).\naisle_halfwidth::Float64: half the width of an aisle (m).\nfuse_offset::Float64: distance from outside of fuselage to edge of closest window seat (m).Outputs:seats_per_row::Float64: number of seats per row.\n\n\n\n\n\n","category":"function"},{"location":"structures/cabin_sizing/#TASOPT.structures.find_double_decker_cabin_length","page":"Cabin sizing","title":"TASOPT.structures.find_double_decker_cabin_length","text":"find_double_decker_cabin_length(x::Vector{Float64}, parg, fuse)\n\nThis function can be used to calculate the length of a double decker cabin with different number of  passengers on each deck.\n\ndetails: 🔃 Inputs and Outputs\nInputs:x::Vector{Float64}: vector with optimization variables\nparg::Vector{Float64}: vector with aircraft geometric and mass parameters\nfuse::Fuselage: structure with fuselage parametersOutputs:maxl::Float64: required cabin length (m)\npax_per_row_main::Float64: number of seats abreast in lower cabin\n\n\n\n\n\n","category":"function"},{"location":"structures/cabin_sizing/#TASOPT.structures.optimize_double_decker_cabin","page":"Cabin sizing","title":"TASOPT.structures.optimize_double_decker_cabin","text":"optimize_double_decker_cabin(fuse)\n\nThis function can be used to optimize the deck layouts and passenger distribution in a double decker aircraft. \n\ndetails: 🔃 Inputs and Outputs\nInputs:parg::Vector{Float64}: vector with aircraft geometric and mass parameters\nfuse::Fuselage: structure with fuselage parametersOutputs:xopt::Vector{Float64}: vector with optimization results\nseats_per_row_main::Float64: number of seats abreast in lower cabin\n\n\n\n\n\n","category":"function"},{"location":"structures/cabin_sizing/#TASOPT.structures.find_minimum_radius_for_seats_per_row","page":"Cabin sizing","title":"TASOPT.structures.find_minimum_radius_for_seats_per_row","text":"find_minimum_radius_for_seats_per_row(seats_per_row, ac_base)\n\nThis function calculates the minimum radius required to have a desired number of seats per row in the main cabin.\n\ndetails: 🔃 Inputs and Outputs\nInputs:seats_per_row::Int64: number of seats per row in main cabin (lower deck if double decker)\nac_base::aircraft: aircraft objectOutputs:R::Float64: minimum radius for desired number of seats per row (m)\n\n\n\n\n\n","category":"function"},{"location":"structures/cabin_sizing/#TASOPT.structures.check_seats_per_row_diff","page":"Cabin sizing","title":"TASOPT.structures.check_seats_per_row_diff","text":"check_seats_per_row_diff(seats_per_row, x, ac)\n\nThis function returns the difference between the desired number of seats per row and the one corresponding to a  given radius\n\ndetails: 🔃 Inputs and Outputs\nInputs:seats_per_row::Float64: desired number of seats per row in main cabin (lower deck if double decker)\nx::Vector{Float64}: vector with one entry containing the fuselage radius (m)\nac::aircraft: aircraft objectOutputs:diff::Float64: difference between desired number of seats per row and that for the input radius\n\n\n\n\n\n","category":"function"},{"location":"examples/payload_range/#Payload-range-diagram","page":"Payload-range diagram","title":"Payload-range diagram","text":"","category":"section"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"Once an aircraft model is satisfactory, its capabilities and performance can be evaluated over a range of mission conditions. For example:","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"(Image: PayloadRangePlot)","category":"page"},{"location":"examples/payload_range/#Using-[PayloadRange()](@ref)","page":"Payload-range diagram","title":"Using PayloadRange()","text":"","category":"section"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"To plot the payload-range diagram of an aircraft model with a fleet of missions, a design mission must be chosen, which will determine the second corner point in the diagram. The design mission should be reflected in the input.toml via the design range and payload weight (e.g., 3500 nmi and 195 pax):","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"[Mission]\n    N_missions = 2 # Number of missions to be modeled (first mission is the design mission)\n    pax = 195       # Number of passengers in each mission\n    range = \"3500.0 nmi\" # Design Range + second mission range\n                            #[\"3000.0 nmi\", \"500.0 nmi\", \"2500.0 nmi\", \"3550.0 nmi\", \"3734.0 nmi\"] # Design Range + second mission range\n    weight_per_pax = \"215.0 lbf\" # Specify weight per passenger - \n                            # includes luggage [lbm or lbf or kg or N] ","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"After the aircraft is sized, PayloadRange() can be called:","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"#Use default model for payload-range diagram\nusing TASOPT\nac = load_default_model() \nsize_aircraft!(ac)\n\nTASOPT.PayloadRange(ac)","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"In this approach, only one mission needs to be specified. TASOPT will copy the parameters from the sizing mission (e.g., takeoff altitude and temperature), and vary the payload and range to produce a payload-range diagram. ","category":"page"},{"location":"examples/payload_range/#Customizing-a-payload-range-diagram","page":"Payload-range diagram","title":"Customizing a payload-range diagram","text":"","category":"section"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"For a more customizable diagram, a second mission may be specified and the following approach can be followed. First, initialize some variables for mission range and payloads:","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"# Make an array of ranges to plot\nRangeArray = ac.parm[imRange] * LinRange(0.1,1.2,Rpts)\n# Store constant values to compare later\nWmax = ac.parg[igWMTO]\nFuelmax = ac.parg[igWfmax]\nWempty = ac.parg[igWMTO] - ac.parg[igWfuel] - ac.parg[igWpay]\n# Arrays for plotting\nRangesToPlot = []\nPayloadToPlot = []\nmaxPay = ac.parm[imWpay ]","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"Then, evaluate the mission points with some logic shortcuts:","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"for Range = RangeArray\n    # Make an array of payloads to plot\n    Payloads = (maxPay) * LinRange(1, 0.1, Ppts)\n    ac.parm[imRange] = Range\n    for mWpay = Payloads\n        println(\"Checking for Range (nmi): \", convertDist(Range, \"m\", \"nmi\"), \" and Pax = \", mWpay/convertForce(Wpax, \"N\", \"lbf\"))\n        ac.parm[imWpay ] = mWpay\n        # Try fly_mission! after setting new range and payload\n        try\n            TASOPT.fly_mission!(ac, 2)\n            # fly_mission! success: store maxPay, break loop\n            mWfuel = ac.parm[imWfuel,2]\n            WTO = Wempty + mWpay + mWfuel\n\n            if WTO > Wmax || mWfuel > Fuelmax || WTO < 0.0 || mWfuel < 0.0 \n                WTO = 0.0\n                mWfuel = 0.0\n                println(\"Max out error!\")\n                if mWpay == 0\n                    println(\"Payload 0 and no convergence found\")\n                    maxPay = 0\n                end\n            else\n                maxPay = mWpay\n                println(\"Converged - moving to next range...\")\n                break\n            end     \n        catch\n            println(\"Not Converged - moving to lower payload...\")      \n        end\n    end\n    append!(RangesToPlot, Range)\n    if OEW\n        append!(PayloadToPlot, maxPay+Wempty)\n    else\n        append!(PayloadToPlot, maxPay)\n    end\nend","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"Plot as desired. Plots.jl is a recommended matplotlib-like library:","category":"page"},{"location":"examples/payload_range/","page":"Payload-range diagram","title":"Payload-range diagram","text":"using Plots\n\n#unit conversions\nx = RangesToPlot ./ (1000 * 1852.0) #to nmi\ny = PayloadToPlot ./ (9.8 * 1000) #to tonnes\n\n# Create the plot\np = plot(x, y,\n    label = \"Payload\",\n    linestyle = :solid, \n    color = :blue,\n    xlabel = \"Range [1000 nmi]\",\n    ylabel = \"Weight [tonnes]\",\n    title = \"Payload Range Plot\",\n    grid = true,\n    dpi = 300,\n    size = (800, 500)\n)\n\n# Save the plot to a file\nsavefig(p, \"./PayloadRangeExample.png\")\n","category":"page"},{"location":"propulsion/hxfun/#hxers","page":"Heat exchangers","title":"Heat exchangers","text":"","category":"section"},{"location":"propulsion/hxfun/","page":"Heat exchangers","title":"Heat exchangers","text":"To study novel aircraft designs that may leverage cryogenic hydrogen, the following heat exchanger models were integrated, along with cryogenic tank and fuel cell models.","category":"page"},{"location":"propulsion/hxfun/#Theory","page":"Heat exchangers","title":"Theory","text":"","category":"section"},{"location":"propulsion/hxfun/","page":"Heat exchangers","title":"Heat exchangers","text":"details: 📖 Theory - Tubular heat exchangers\nEffectiveness–NTU methodThere are many different heat exchanger (HX) topologies. The HX currently implemented in TASOPT consists of staggered tubes in a cross flow; this geometry was selected because it is simple to integrate into the space between two concentric cylinders. The HX is designed using the effectiveness–NTU method, described below [1].  Consider a heat exchanger in which a coolant gas is used to cool or heat gas. The minimum and maximum heat capacity rates are defined asC_mathrmmin = mathrmmin (dotm_c c_pc dotm_p c_pp)C_mathrmmax = mathrmmax (dotm_c c_pc dotm_p c_pp)where dotm is the mass flow rate, c_p is the specific heat at constant pressure, and the subscripts p and c refer to the process-side and coolant streams. The capacity ratio is C_r = fracC_mathrmminC_mathrmmax. A maximum heat transfer rate is defined asdotQ_max = C_mathrmmin (T_ip - T_ic)where T is the absolute temperature. A measure of the HX performance is the effectiveness, varepsilon, defined asvarepsilon = fracdotQdotQ_maxwhere dotQ is the actual heat transfer rate. The effectiveness can range between 0 and 1. A related quantity known as the number of transfer units (NTU) is defined asmathrmNTU = frac1C_mathrmmin R_owhere R_o is the overall thermal resistance. For any heat exchanger geometry, it can be shown that the effectiveness is a function of the NTU and the ratio fracC_mathrmminC_mathrmmax. In the case of a cross flow heat exchanger, this functional relationship between varepsilon and NTU depends on whether there is internal mixing within the stream and on which stream has the minimum capacity rate. In a HX within a jet engine, it is reasonable to assume that the coolant stream has the minimum capacity rate as the fuel-air ratio is small. For tubular HX, the process stream is mixed but the coolant stream is unmixed as the tubes are independent. In this case, the relationship between varepsilon and NTU is[1]varepsilon = frac1C_r 1 - exp(-C_r (1 - exp(-mathrmNTU)))or converselymathrmNTU = -lnleft(1 + fracln(1 - C_rvarepsilon)C_rright)On the other hand, if the coolant stream has the maximum heat capacity rate, the effectiveness is given byvarepsilon = 1 - expleft-frac1C_r (1 - exp(-C_r mathrmNTU))rightand the corresponding NTU ismathrmNTU = -frac1C_r lnleft 1 + C_r ln(1 - varepsilon)rightA notable property of these expressions is that there is a maximum effectiveness varepsilon_mathrmmax  1 as the NTU tends to infinity. In the code, there is a check to see if the desired effectiveness exceeds the maximum possible one, in which case there is no solution. The effectiveness is limited to 95% of varepsilon_mathrmmax to prevent a very large NTU.Once the effectiveness is known, the outlet specific enthalpies can be computed usingh_op = h_ip - fracdotQdotm_ph_oc = h_ic + fracdotQdotm_cwhere h represents the specific enthalpy, and the outlet temperatures can be determined from these.RecirculationIf the coolant is originally in liquid form, it needs to undergo a phase change at some point in the heat exchanger. For cryogenic liquids, such as hydrogen or methane, it is unadvisable to expose air to these cryogenic temperatures as it can result in freezing or liquefaction of some species in air. A possible approach to overcome this is to introduce recirculation in the heat exchanger: this increases the coolant mass flow rate and allows for a higher coolant temperature while still having the same heat transfer. The way recirculation is currently modeled in TASOPT is via a virtual \"mixing chamber\", where the hot recirculating mass flow that comes of of the HX is mixed with the colder coolant (which may be liquid in general) and heats it up to a desired HX inlet temperature,T_ic. Neglecting the kinetic energy in the fluids, conservation of energy requires thatdotm_cinfty (h_cinfty-h_lat) + dotm_r h_oc = (dotm_cinfty+dotm_r)h_icwhere dotm_r is the recirculating mass flow rate and dotm_cinfty is the coolant mass flow rate before mixing with recirculation and, by mass conservation, the mass flow rate that leaves the system. The term h_lat represents a latent heat and may account for vaporization or, in the case of hydrogen, the ortho- to parahydrogen conversion. The specific enthalpies into and out of the HX are related by h_oc = h_ic + fracdotQdotm_cinfty+dotm_rAs the heat transfer rate is given by dotQ = varepsilon C_mathrmmin (T_ip - T_ic), we can distinguish two cases depending on whether the coolant has the minimum or maximum heat capacity rate. If C_mathrmmin=(dotm_cinfty+dotm_r) c_pic,dotm_r = dotm_cinfty frach_ic - h_cinfty + h_latvarepsilon c_pic(T_ip - T_ic)and if C_mathrmmax=(dotm_cinfty+dotm_r) c_pic,dotm_r = dotm_cinftyfracA1-Awhere A = dotm_cinftyfrach_ic -h_cinfty + h_latvarepsilon C_h (T_ip - T_ic)A failure case exists if Ageq 1: in this case, the hot stream does not have enough heat capacity to provide the heat needed to get the coolant to the desired T_ic.Heat exchanger geometry(Image: HXfig)Two HX cross-sections are currently supported: rectangular and concentric cylinders (e.g., for a jet engine core). If the geometry is rectangular, the length of the tubes dictates the width of the rectangle, but if it is concentric, the tubes could have any length greater or equal to the distance between the cylinders as involute tubes could be used. The heat exchanger is assumed to have N_mathrmstages different serial stages, with each stage containing N_mathrmpasses tube rows, each corresponding to a coolant pass. For example, the HX in the figure above with 2 stages and 3 coolant passes has a total of N_L=N_mathrmstagesN_mathrmpasses=6 tube rows. The number of tubes at every row is N_t; this parameter can be calculated from the mass flow rate through the cold side or from the geometry of the stageN_t = frac4 dotm_crho_ciV_ci pi D_ti^2 N_mathrmstages = fracbfracx_tD D_towhere b is length across which the tubes are distributed. If the cross-section is concentric, b=pi D_ci with D_ci being the inner cylinder diameter; if it is rectangular, b = fracA_csl. In this expressions, A_cs=fracdotm_prho_piV_pi is the freestream cross-sectional area. Since the tube inner diameter can be expressed as D_ti = D_to - 2t, this equation can be solved for the tube outer diameterD_to = frac4  K  t + sqrt8  K t + 1 + 12 Kwith K = fracpi b N_mathrmstages rho_ciV_ci4 fracx_tD dotm_c.The total length of the HX is simply L = N_L fracx_lD D_to.Some calculations rely on knowing the tangential pitch between tubes. This pitch may vary in the radial direction as the circumference changes but the tube diameter remains unchanged. In addition to this, the tubes are generally involute, which makes calculating this pitch even more challenging. In the code, a mean tangential pitch x_tm is used to compute parameters such as the pressure drop and the Nusselt number. This mean pitch is calculated asx_tm = fracA_csN_t lwhere l is the length of each involute tube. The mass flow rate per unit area at the minimum free flow area is G = fracdotm_pA_cs - N_t l D_toNote that for this expression to be valid, it is sufficient that x_lDgeq 1. If the general geometry and total hot-side heat transfer area are known (e.g., from the NTU), but the number of coolant passes has not been determined yet, this can be calculated asN_mathrmpasses = fracA_hN_t N_mathrmstages pi D_to lHeat transfer coefficientsThe above analysis relies on being able to determine the overall thermal resistance. In general, the thermal resistance has five components: hot- and cold-side gas resistances, wall resistance, and hot- and cold-side fouling resistances. The gas resistances are the aerodynamic resistances due to the thermal boundary layers, the wall resistance depends on the material conductivity and thickness, and the fouling resistances account for buildup of dirt layers during operation. The product of thermal resistance and heat transfer area (thermal insulance) is in practice easier to computeR_o A_p = frac1h_p + frac1h_c fracA_cA_p + fractk_w + R_fpA_p + R_fcA_c fracA_pA_cwhere h is the the aerodynamic heat transfer coefficient, A is the heat transfer area, t is the wall thickness, k is the thermal conductivity, w denotes the wall, and R_fA is the fouling factor. A list of design fouling factors can be found in [2] and [3].The heat transfer coefficients depend on the gas temperature, which changes as heat is added to the flows. A mean gas temperature, taken as the average between the inlet and outlet temperatures, is used to calculate the gas properties,T_pm = fracT_po - T_pi2T_cm = fracT_co - T_ci2Coolant-side heat transfer coefficientThe flow inside the tubes can be modeled by assuming that it is fully-developed turbulent flow in a smooth pipe. In this case, the 1913 Blasius correlation provides a method to calculate the skin-friction coefficient, C_fC_f = fractau_wfrac12rho_cm V_cm^2 = 00791 mathrmRe_Dc^-14where tau_w is the wall shear stress, rho is the mass density, V is the velocity and the cold-side diameter-based Reynolds number is defined as mathrmRe_Dc=fracV_cmrho_cm D_timu_cm, with D_ti being the tube inner diameter and mu being the viscosity.When the skin-friction coefficient is known, the Colburn j-factor can be calculated using the Reynolds analogyj = mathrmSt mathrmPr^23 = fracC_f2where mathrmSt = frachrho V c_p is the Stanton number and mathrmPr = fracc_p muk is the Prandtl number. Once j is determined, the heat transfer coefficient h_c can be computed from the cold gas properties.Process-side heat transfer coefficientThe flow past a set of staggered tubes is complex. Žkauskas[4] provides simplified correlations that can be used to model the heat transfer properties of these tubes. Generally, the Nusselt number can be expressed asmathrmNu = C_1 C_2 mathrmRe^m mathrmPr^nwhere the Reynolds number is defined as mathrmRe= fracG D_tomu_pm, D_to is the tube outer diameter, and G is the hot-side mass flow rate per unit area at the minimum free-flow area. Hence, this Reynolds number accounts for blockage effects due to the presence of the tubes.The following table shows the value of the parameters C_1, m and n as a function of Reynolds number.Re C_1 m n\n0–40 1.04 0.4 0.36\n40–1000 0.71 0.5 0.36\n1000–2times 10^5 & x_tx_l2 035  (x_t  x_l) ^ 02 0.6 0.36\n1000–2times 10^5 & x_tx_lgeq 2 0.4 0.6 0.36\n2times 10^5 0031  (x_t  x_l) ^ 02 0.8 0.4The parameters in the table can be affected by the distances x_t and x_l, which are the distances between tubes in the tangential and longitudinal directions. Note that the distance x_t used in the calculations is x_tm as the pitch varies in the radial direction. The ratios of this distances to the tube outer diameter, fracx_tD and fracx_tD, are design parameters. The parameter C_2 is a correction that accounts for the number of rows, N_L, and tends to 1 as the number of rows goes to infinity. It can be approximated as C_2 = 1-exp(-N_L^1  sqrt3)if Re1000 and otherwise asC_2 = 1-exp(-sqrt3 N_L^1  sqrt2)Once the Nusselt number is known, the hot-side heat transfer coefficient can be computed as h_p = fracmathrmNu k_pD_to.Pressure dropsThe pressure drop in the hot-side (across the staggered tube bank) can be estimated using the method of Gunter and Shaw[5]. The first necessary parameter is the volumetric hydraulic diameter, defined asD_v = frac4(mathrmNetfreevolume)mathrmFrictionsurface = frac4 L fracdotm_pV_pirho_pi-N_t N_mathrmpasses N_mathrmstages pi D_to^2 lA_pFrom this, the pressure drop across the process side can be computed asDelta p_p = fracG^2 L D_v rho_pm fracf2 left(fracD_vx_tright)^04left(fracx_lx_tright)^06 left(fracmumu_wright)^-014where fracf2 is a friction factor that can be related to the Reynolds number, Re_D_v = fracG D_vmu_pm, as fracf2= 90  Re_D_v for Re_D_v200 and fracf2= 096  Re_D_v^-0145 otherwise. As in the heat transfer coefficient case, note that the distance x_t used in the calculations is x_tm since the pitch varies in the radial direction.The cold-side pressure drop can be calculated from the skin-friction coefficient, ignoring the minor losses due to flow turning at each pass,Delta p_c = frac4 tau_w N_mathrmpasses pi D_ti lpi D_ti^2= frac4 tau_w N_mathrmpasses lD_tiwith tau_w = C_f frac12rho_cm V_cm^2.Correction for temperature changes across thermal boundary layerTemperature changes across the thermal boundary layer in both the coolant and process streams. Identifying the temperature at which to evaluate the properties is not trivial. In the code, the method in Kays and London[1] is used: all properties are evaluated at the freestream temperatures (T_pm and T_cm) and a correction is applied to the Nusselt number and the friction coefficient (f in the process stream and C_f for the coolant). These take the formmathrmNu = mathrmNu_mleft(fracT_wT_mright)^nf = f_mleft(fracT_wT_mright)^mwhere the coefficients are n=00 and m=00 for the process-side properties and n=-05 and m=-01 for the coolant side[1]. The wall temperature is calculated from the overall thermal resistance and the thermal resistance of the coolant side,T_w = T_cm + fracT_pm-T_cmR_o A_pleft(frac1h_c fracA_cA_p + R_fcA_c fracA_pA_cright)","category":"page"},{"location":"propulsion/hxfun/#Structures","page":"Heat exchangers","title":"Structures","text":"","category":"section"},{"location":"propulsion/hxfun/#TASOPT.engine.HX_gas","page":"Heat exchangers","title":"TASOPT.engine.HX_gas","text":"HX_gas\n\nStructure containing the gas properties of the process and coolant streams.\n\ndetails: 💾 Data fields\nInputs:fluid_p::String: process fluid name\nfluid_c::String: coolant fluid name\nalpha_p::Vector{Float64}: process gas composition\nigas_c::Float64: coolant gas index, if coolant is a gas\nmdot_p::Float64: mass flow rate of process gas (kg/s)\nmdot_c::Float64: mass flow rate of coolant gas (kg/s)\nTp_in::Float64: process gas inlet temperature (K)\nTc_in::Float64: coolant gas inlet temperature (K)\npp_in::Float64: process gas inlet pressure (Pa)\npc_in::Float64: coolant gas inlet pressure (Pa)\nMp_in::Float64: process gas inlet Mach number\nMc_in::Float64: coolant gas inlet Mach number\nTp_out::Float64: process gas outlet temperature\nTc_out::Float64: coolant gas outlet temperature\nTw::Float64: wall temperature (K)\nΔh_p::Float64: enthalpy change across HX (J/kg)\nΔp_p::Float64: pressure drop of process gas across heat exchanger (Pa)\nΔp_c::Float64: pressure drop of coolant gas across tubes (Pa)\nPl_p::Float64: power loss due to pressure drop in process stream (W)\nPl_c::Float64: power loss due to pressure drop in coolant stream (W)\nε::Float64: desired heat exchanger effectiveness\nrecircT::Float64: temperature of recirculating flow at HX inlet (K)\nmdot_r::Float64: recirculating flow mass flow rate (kg/s)\nh_lat::Float64: latent heat capacity in freestream coolant liquid (J/kg)\n\n\n\n\n\n","category":"type"},{"location":"propulsion/hxfun/#TASOPT.engine.HX_tubular","page":"Heat exchangers","title":"TASOPT.engine.HX_tubular","text":"HX_tubular\n\nStructure containing the heat exchanger geometric and material properties.\n\ndetails: 💾 Data fields\nInputs:fconc::Bool: flag for concentric geometry (true: concentric ; false: rectangular)\nfrecirc::Bool: flag for recirculation (true: recirculation ; false: no recirculation)\nfshaf::Bool: flag for whether HX contains shaf(true: shaft ; false: no shaft)\nN_t::Float64: number of tubes per row\nn_stages::Float64: number of different coolant stages with different coolant flows\nn_passes::Float64: number of coolant passes\nA_cs::Float64: process side freestream cross-sectional area (m^2)\nl::Float64: length of tubes (m)\nt::Float64: cooling tube wall thickness (m)\ntD_o::Float64: tube outer diameter (m)\nxt_D::Float64: circumferential pitch between tubes at the root over tube outer diameter \nxl_D::Float64: longitudinal pitch between rows over tube outer diameter\nRfp::Float64: process-side fouling factor (m^2 K/W)\nRfc::Float64: coolant-side fouling factor (m^2 K/W)\nD_i::Float64: inner diameter of core (m)\nΔpdes::Float64: design pressure difference between tube and outside (Pa)\nmaxL::Float64: maximum allowable HEX length (m)\n\n\n\n\n\n","category":"type"},{"location":"propulsion/hxfun/#TASOPT.engine.HX_struct","page":"Heat exchangers","title":"TASOPT.engine.HX_struct","text":"HX_struct\n\nStructure containing all the heat exchanger geometry and operational information.\n\ndetails: 💾 Data fields\nInputs:type::String: type of heat exchanger (\"PreC\": precooler; \"InterC\": intercooler; \"Regen\": regenerative; \"TurbC\": turbine cooling)\nHXgeom::HX_tubular: structure containing the HX geometric information\nHXgas_mission::Array{Any}: array containing the gas properties, of type HX_gas for each mission and segment\n\n\n\n\n\n","category":"type"},{"location":"propulsion/hxfun/#Functions","page":"Heat exchangers","title":"Functions","text":"","category":"section"},{"location":"propulsion/hxfun/#Heat-exchanger-sizing-and-off-design-operations","page":"Heat exchangers","title":"Heat exchanger sizing and off-design operations","text":"","category":"section"},{"location":"propulsion/hxfun/#TASOPT.engine.hxsize!","page":"Heat exchangers","title":"TASOPT.engine.hxsize!","text":"hxsize!(HXgas, HXgeom)\n\nSizes a crossflow heat exchanger and calculates the pressure drop. Uses the ε-NTU method to size the heat exchanger from a prescribed ε. For representative fouling factors see Standards of the Tubular Exchanger Manufacturers Association or https://powderprocess.net/Tools_html/Data_Diagrams/Heat_Exchanger_Fouling_Factor.html\n\ndetails: 🔃 Inputs and Outputs\nInputs:HXgas::Struct: structure of type HX_gas with the gas properties\nHXgeom::Struct: structure of type HX_tubular with the HX geometric propertiesOutputs: No direct outputs. Input structures are modified with outlet gas properties and HX design geometry.\n\n\n\n\n\n","category":"function"},{"location":"propulsion/hxfun/#TASOPT.engine.hxoper!","page":"Heat exchangers","title":"TASOPT.engine.hxoper!","text":"hxoper!(HXgas, HXgeom)\n\nEvaluates crossflow heat exchanger performance for off-design operation. Uses the ε-NTU  method to calculate effectiveness from prescribed geometry.       \n\ndetails: 🔃 Inputs and Outputs\nInputs:HXgas::Struct: structure of type HX_gas with the gas properties\nHXgeom::Struct: structure of type HX_tubular with the HX geometric propertiesOutputs: No direct outputs. Input structures are modified with outlet gas properties.\n\n\n\n\n\n","category":"function"},{"location":"propulsion/hxfun/#Optimization","page":"Heat exchangers","title":"Optimization","text":"","category":"section"},{"location":"propulsion/hxfun/#TASOPT.engine.hxoptim!","page":"Heat exchangers","title":"TASOPT.engine.hxoptim!","text":"hxoptim!(HXgas, HXgeom, initial_x)\n\nOptimizes heat exchanger design parameters for a given set of inputs. Uses the NLopt.jl package. The optimization variables are Mc_in, n_stages, xt_D and l. The length of initial_x is the flag to determine how many parameters  to optimize: if it is 4, all parameters are optimized; if it is 3, the tube length l is assumed to be an input and is not  optimized.\n\ndetails: 🔃 Inputs and Outputs\nInputs:HXgas::Struct: structure of type HX_gas with the gas properties\nHXgeom::Struct: structure of type HX_tubular with the HX geometric properties\ninitial_x::Vector{Float64}: vector with the initial guess for the optimizationOutputs: No direct outputs. Input structures are modified with HX design geometry.\n\n\n\n\n\n","category":"function"},{"location":"propulsion/hxfun/#TASOPT.engine.hxobjf","page":"Heat exchangers","title":"TASOPT.engine.hxobjf","text":"  hxobjf(x, HXgas, HXgeom)\n\nObjective function for HX optimization in hxoptim!(). It returns the sum of the power dissipated due to pressure drops in the process and coolant streams.\n\ndetails: 🔃 Inputs and Outputs\nInputs:x::Vector{Float64}: state vector with [100 * Mc_in, l, n_stages, xt_D]\nHXgas::Struct: structure of type HX_gas with the gas properties\nHXgeom::Struct: structure of type HX_tubular with the HX geometric propertiesOutputs:Iobj::Float64: objective function (W)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/hxfun/#Overall-design-and-analysis","page":"Heat exchangers","title":"Overall design and analysis","text":"","category":"section"},{"location":"propulsion/hxfun/#TASOPT.engine.hxdesign!","page":"Heat exchangers","title":"TASOPT.engine.hxdesign!","text":"  hxdesign!(pare, igas, ipdes, HXs_prev)\n\nHeat exchanger design and operation function. It calls hxoptim!() to optimize the heat exchanger at the design point and  then evaluates performance for all missions and points with hxoper!().      \n\ndetails: 🔃 Inputs and Outputs\nInputs:pare::Array{Float64 , 3}: array with engine parameters\nigas::Float64: coolant gas index\nipdes::Float64: index for design mission segment\nHXs_prev::Vector{Any}: vector with heat exchanger data from the previous wsize iteration; elements are HX_struct structures\nrlx::Float64: relaxation factor for pare updateOutputs:HeatExchangers::Vector{Any}: vector with heat exchanger data; elements are HX_struct structures\nAlso modifies pare with the fuel temperature and the HX enthalpy and pressure changes\n\n\n\n\n\n","category":"function"},{"location":"propulsion/hxfun/#Heating-and-pressure-calculations","page":"Heat exchangers","title":"Heating and pressure calculations","text":"","category":"section"},{"location":"propulsion/hxfun/#TASOPT.engine.jcalc_pipe","page":"Heat exchangers","title":"TASOPT.engine.jcalc_pipe","text":"jcalc_pipe(Re_D)\n\nCalculates the Colburn j-factor and skin-friction coefficient for flow inside a circular pipe,  assuming flow is fully developed and turbulent. Uses the 1913 Blasius correlation.\n\ndetails: 🔃 Inputs and Outputs\nInputs:Re_D::Float64: Reynolds number based on pipe diameterOutputs:j::Float64: Colburn j-factor for heat calculations\nCf::Float64: skin-friction coefficient\n\n\n\n\n\n","category":"function"},{"location":"propulsion/hxfun/#TASOPT.engine.Nu_calc_staggered_cyl","page":"Heat exchangers","title":"TASOPT.engine.Nu_calc_staggered_cyl","text":"Nu_calc_staggered_cyl(Re_D, Pr, N_L, xt_D, xl_D)\n\nCalculates the Nusselt number for cross flow on a set of staggered circular cylinders. Based on the model in A. Žkauskas. Heat Transfer from Tubes in Crossflow. Advances in Heat Transfer v.18 (1987).\n\ndetails: 🔃 Inputs and Outputs\nInputs:Re_D::Float64: Reynolds number based on cylinder diameter with velocity at minimum free flow area\nPr::Float64: Prandtl number\nN_L::Float64: number of cylinder rows\nn_stages::Float64: number of different coolant stages with different coolant flows\nxt_D::Float64: circumferential pitch between tubes over tube outer diameter\nxl_D::Float64: longitudinal pitch between rows over tube outer diameterOutputs:Nu::Float64: Nusselt number based on cylinder diameter \n\n\n\n\n\n","category":"function"},{"location":"propulsion/hxfun/#TASOPT.engine.Δp_calc_staggered_cyl","page":"Heat exchangers","title":"TASOPT.engine.Δp_calc_staggered_cyl","text":"Δp_calc_staggered_cyl(Re, G, L, ρ, Dv, tD_o, xt_D, xl_D, μ_μw)\n\nCalculates the pressure drop across a set of staggered cylinders in cross flow. Uses the method of Gunter and Shaw.  A General Correlation of Friction Factors for Various Types of Surfaces in Crossflow. Journal of Fluids Engineering, 1945.\n\ndetails: 🔃 Inputs and Outputs\nInputs:Re::Float64: Reynolds number based on hydraulic diameter and minimum free flow area: Re = Dv G /μ\nG::Float64: mass flow rate divided by minimum free flow area. G = mdot / (A_min), A_min is the minimum free-flow area (kg/s/m^2)\nL::Float64: axial channel length (m)\nρ::Float64: density (kg/m^3)\nDv::Float64: volumetric hydraulic diameter. Dv = 4 * (Net free volume) / (Friction surface)\ntD_o::Float64: cylinder outer diameter (m)\nxt_D::Float64: circumferential pitch between tubes over tube outer diameter\nxl_D::Float64: longitudinal pitch between rows over tube outer diameter\nμ_μw::Float64: ratio of free flow viscosity to wall viscosityOutputs:Δp::Float64: pressure drop across staggered cylinders (Pa)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/hxfun/#Weight-estimation","page":"Heat exchangers","title":"Weight estimation","text":"","category":"section"},{"location":"propulsion/hxfun/#TASOPT.engine.hxweight","page":"Heat exchangers","title":"TASOPT.engine.hxweight","text":"  hxweight(gee, HXgeom, fouter)\n\nCalculates the weight of a heat exchanger with involute tubes.\n\ndetails: 🔃 Inputs and Outputs\nInputs:gee::Float64: gravitational acceleration (m/s^2)\nHXgeom::Struct: structure of type HX_tubular with the HX geometric and material properties\nfouter::Float64: ratio of HX external mass to tube massOutputs:W_hx::Float64: weight of heat exchanger (N)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/hxfun/","page":"Heat exchangers","title":"Heat exchangers","text":"[1]: Kays, W. M., & London, A. L. (1984). Compact heat exchangers.","category":"page"},{"location":"propulsion/hxfun/","page":"Heat exchangers","title":"Heat exchangers","text":"[2]: Standards of the Tubular Exchanger Manufacturers Association","category":"page"},{"location":"propulsion/hxfun/","page":"Heat exchangers","title":"Heat exchangers","text":"[3]: Powder Process","category":"page"},{"location":"propulsion/hxfun/","page":"Heat exchangers","title":"Heat exchangers","text":"[4]: Žkauskas, A. (1987). Heat transfer from tubes in crossflow. In Advances in heat transfer (Vol. 18, pp. 87-159). Elsevier.","category":"page"},{"location":"propulsion/hxfun/","page":"Heat exchangers","title":"Heat exchangers","text":"[5]: Gunter, A. Y., & Shaw, W. A. (1945). A general correlation of friction factors for various types of surfaces in crossflow. Transactions of the American Society of Mechanical Engineers, 67(8), 643-656.","category":"page"},{"location":"structures/fuselage/#fuselage","page":"Fuselage","title":"Fuselage","text":"","category":"section"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"(Image: Fuselage layout)","category":"page"},{"location":"structures/fuselage/#Fuselage-pressure-and-torsion-loads","page":"Fuselage","title":"Fuselage pressure and torsion loads","text":"","category":"section"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"The fuselage is modeled as a side-by-side \"multi-bubble\" pressure vessel with an ellipsoidal nose endcap and a hemispherical tail endcap, which is subjected to pressurization, bending, and torsion loads, as shown in the first two figures. The loaded cylindrical length of the pressure vessel shell is from x_rm shell_1 to x_rm shell_2.  beginaligned l_rm shell =  x_rm shell_2 - x_rm shell_1 endaligned","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"The horizontal-axis moment cal M_rm hscriptstyle (x) distributions on the front and back bending fuselage are assumed to match at location x_rm wing, as shown in the first figure. Theoretically this is the wing's net lift–weight centroid, which varies somewhat depending the fuel fraction in the wings, the wing's profile pitching moment and hence the flap setting, and on the aircraft C_L. For simplicity it will be approximated as the wing's area centroid. Note that for a swept wing the wing box location x_rm wbox will be centered somewhat ahead of x_rm wing, but it will then also impart a pitch-axis moment at its location, so that the front and back cal M_rm hscriptstyle (x) distributions must still match at x_rm wing.","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"The second figure shows the fuselage cross section for the case of a \"double-bubble\", or two tubes. The next figure compares to alternative possible cross sections with three or four tubes, each specified by the number of webs n_rm fweb. The pressure-vessel skin and endcaps have a uniform thickness t_rm skin, while each of the n_rm fweb tension web(s) has an average thickness t_rm fweb. The cross-sectional area of the skin is A_rm skin, and has stiffening stringers which have a \"smeared\" average area A_rm skinf_rm stringrho_rm skinrho_rm bend, specified via the empirical stringer/skin weight fraction f_rm string. The enclosed area S_rm skin enters the torsional stiffness and strength calculations. The fuselage cross section also shows the possibility of added bottom bubbles or fairings, extended downward by the distance Delta R_rm fuse.","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"(Image: Fusetube)","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"The skin and stringers constitute the \"shell\", which has bending inertias I_rm hshell I_rm vshell about the horizontal and vertical axes. The second figure does not show any hoop-stiffening frames which are typically required, and whose weight is a specified fraction f_rm frame of the skin weight. These typically may be offset from the skin inside of the stringers, and hence are assumed to not contribute to the skin's circumferential tensile strength.","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"To address the weight and aerodynamic loads of the tail group on the fuselage, the horizontal and vertical tails, the tailcone, and any rear-mounted engines are treated as one lumped mass and aero force at location x_rm tail, shown in Figure 2.","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"The bending loads on the shell may require the addition of vertical-bending material concentrated on top and bottom of the fuselage shell (typically as skin doublers or additional stringers). The total added cross sectional area is A_rm hbendscriptstyle (x), and the associated added bending inertia is I_rm hbendscriptstyle (x). Corresponding added material on the sides has A_rm vbendscriptstyle (x) and I_rm vbendscriptstyle (x). Because the wing box itself will contribute to the fuselage bending strength, these added areas and bending inertias do not match the cal Mscriptstyle (x) distribution there, but are made linear over the wing box extent, as shown in figure 2.","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"(Image: ntube)","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"details: 📖 Theory - Cross-section relations\nThe fuselage pressure shell has the following geometric  relations and beam quantities. beginaligned  theta_rm fb = arcsin (w_rm fb R_rm fuse)  \n h_rm fb = sqrtR_rm fuse^2 - w_rm fb^2  \n A_rm skin =  left( 2pi + 4n_rm fwebtheta_rm fbright) R_rm fuse t_rm skin  + 2 Delta R_rm fuse t_rm skin  \n A_rm fweb =  n_rm fweb(2 h_rm fb+ Delta R_rm fuse)  t_rm fweb  \n A_rm fuse =  left pi + n_rm fwebleft( 2theta_rm fb+ sin 2 theta_rm fbright)        right R_rm fuse^2  + 2 left R_rm fuse+ n_rm fwebw_rm fbright Delta R_rm fuse  endaligned The skin has some modulus and density  E_rm skin rho_rm skin, while the stringers have some possibly  different values E_rm bend rho_rm bend. The effective  modulus-weighted \"shell\" thickness t_rm shell can then be defined  as follows, assuming that only the skin and stringers contribute to  bending, but not the frames. beginaligned  t_rm shell = frac(E t)_rm skinE_rm skin  = t_rm skin  left( 1 + r_ scriptscriptstyle E f_rm stringfracrho_rm skinrho_rm bend right)  \n rmwhere hspace5ex  r_ scriptscriptstyle E = fracE_rm bendE_rm skin  endaligned This is then convenient for determining the  modulus-weighted horizontal-axis and vertical-axis bending inertias. The  fuselage webs, if any, are assumed to be made of the same material as  the skin. The passenger-access cutouts will not extend all the way to  the skin/web junctions, so that the webs' contributions are included in  the overall shell bending inertia.   beginaligned  I_rm hshell =  frac(EI)_rm hshellE_rm skin   nonumber \n      =    4 int_0^pi2  hspace-2ex  left( R_rm fusesintheta + Delta R_rm fuse2 right)^2    R_rm fuse t_rm shell rm dtheta  nonumber \n + 4 n_rm fweb int_pi2^pi2+theta_rm fb  hspace-2ex  left( R_rm fusesintheta + Delta R_rm fuse2 right)^2    R_rm fuse t_rm shell rm dtheta  + frac23 n_rm fweb(h_rm fb+Delta R_rm fuse2)^3 t_rm fweb  nonumber \n =   left rule-05em0em15em  left  pi + n_rm fweb( 2theta_rm fb+ sin 2 theta_rm fb)        right R_rm fuse^2  right  nonumber 025em     +  8 n_rm fwebcos theta_rm fb (Delta R_rm fuse2)  R_rm fuse  nonumber 025em    left  + left 2pi + 4 n_rm fwebtheta_rm fbright (Delta R_rm fuse2)^2   rule-05em0em15em right R_rm fuse t_rm shell  + frac23 n_rm fweb(h_rm fb+Delta R_rm fuse2)^3 t_rm fweb  \n I_rm vshell =  frac(EI)_rm vshellE_rm skin   nonumber \n  =    4 int_0^pi2 hspace-2ex  left( R_rm fusecostheta + n_rm fwebw_rm fbright)^2   R_rm fuse t_rm shell rm dtheta  nonumber \n  +    4 n_rm fweb int_pi2^pi2+theta_rm fb hspace-2ex  left( R_rm fusecostheta right)^2   R_rm fuse t_rm shell rm dtheta  + sum_k=1^n_k   4 R_rm fuset_rm shelltheta_rm fbw_rm fb^2 (2k - i_k)^2  nonumber \n =  left rule-05em0em15em  left  pi + n_rm fweb(2theta_rm fb- sin 2 theta_rm fb) right R_rm fuse^2  right  nonumber 025em     +  8 cos theta_rm fb n_rm fwebw_rm fb R_rm fuse  nonumber 025em     + left( 2pi + 4theta_rm fbright) (n_rm fwebw_rm fb)^2   nonumber 025em     left  + 4 theta_rm fbw_rm fb^2 sum_k=1^n_k  (2k - i_k)^2  rule-05em0em15em right R_rm fuse t_rm shell  \n n_k  =  rm int(n_rm fweb2)  \n i_k  =  rm mod(n_rm fweb+1    2)   hspace4ex  endaligned It's useful to note that for the particular case of  n_rm fweb=0 w_rm fb=0, together with Delta R_rm fuse= 0,  there is only one circle. The areas and bending inertias then reduce to  those for a single circular cross-section. beginaligned  hspace6ex  A_rm skin =  2 pi R_rm fuse t_rm skin  hspace6ex  (rm if n_rm fweb=0 w_rm fb= 0 Delta R_rm fuse= 0)  \n hspace6ex  S_rm skin =  pi R_rm fuse^2  hspace11ex (rm if n_rm fweb=0 w_rm fb= 0 Delta R_rm fuse= 0)  \n hspace6ex  I_rm hshell= I_rm vshell =  pi R_rm fuse^3  t_rm shell  hspace7ex  (rmif n_rm fweb=0 w_rm fb= 0 Delta R_rm fuse= 0)  endaligned Hence, no generality is lost with this multiple-bubble  cross-section model.","category":"page"},{"location":"structures/fuselage/#Pressure-shell-loads","page":"Fuselage","title":"Pressure shell loads","text":"","category":"section"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"The pressurization load from the Delta p pressure difference produces the following axial and hoop stresses in the fuselage skin, with the assumption that the stringers share the axial loads, but the frames do not share the hoop loads. This assumes a typical aluminum fuselage structure, where the stringers are contiguous and solidly riveted to the skin, but the frames are either offset from the skin or have clearance cutouts for the stringers which interrupt the frames' hoop loads.","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"beginaligned\nsigma_x  =  \nfracDelta p2  fracR_rm fuset_rm shell\n\nsigma_theta  =  \nDelta p  fracR_rm fuset_rm skin\nendaligned","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"An isotropic (metal) fuselage skin thickness t_rm skin and the web thickness t_rm fweb will therefore be sized by the larger sigma_theta value in order to meet an allowable stress sigma_rm skin.  beginaligned t_rm skin =  fracDelta p  R_rm fusesigma_rm skin  labeltfuse \nt_rm fweb =  2  fracDelta p  w_rm fbsigma_rm skin  endaligned  This particular t_rm fweb value is obtained from the requirement of equal circumferential stress in the skin and the web, and tension equilibrium at the 3-point web/skin junction.","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"The volume of the skin material cal V_rm skin is obtained from the cross-sectional skin area, plus the contribution of the ellipsoidal nose endcap and the spherical rear bulkhead. The nose uses Cantrell's approximation for the surface area of an ellipsoid. ","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"beginalign\nS_rm nose simeq left 2pi + 4n_rm fwebtheta_rm fbright R_rm fuse^2 left frac13 + frac23 left( fracl_rm noseR_rm fuse right)^85 right^ 58 nonumber \n hspace5em nonumber\nS_rm bulk simeq left 2pi + 4n_rm fwebtheta_rm fbright R_rm fuse^2 nonumber \n hspace5em nonumber\ncal V_rm cyl = A_rm skin l_rm shell nonumber \ncal V_rm nose = S_rm nose t_rm skin nonumber \ncal V_rm bulk = S_rm bulk t_rm skin nonumber \ncal V_rm fweb = A_rm fweb l_rm shell nonumber \n\nx hspace-04ex cal V_rm cyl = textstyle frac12(x_rm shell_1 + x_rm shell_2)  cal V_rm cyl nonumber \nx hspace-04ex cal V_rm nose = textstyle frac12(x_rm nose + x_rm shell_1)  cal V_rm nose nonumber \nx hspace-04ex cal V_rm bulk = (x_rm shell_2 + textstyle frac12Delta R_rm fuse)  cal V_rm bulk nonumber \nx hspace-04ex cal V_rm fweb = textstyle frac12(x_rm shell_1 + x_rm shell_2)  cal V_rm fweb nonumber\nendalign","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"The total fuselage shell weight then follows by specifying a material density rho_rm skin for the skin and web. The assumed skin-proportional added weights of local reinforcements, stiffeners, and fasteners are represented by the f_rm fadd fraction, and stringers and frames are represented by the f_rm stringf_rm frame fractions. ","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"beginaligned\nW_rm skin = \nrho_rm skin g  \n      (cal V_rm cyl+ cal V_rm nose+ cal V_rm bulk)\n\nW_rm fweb = \nrho_rm skin g   cal V_rm fweb\n\nx hspace-045ex W_rm skin =\nrho_rm skin g  \n      (x hspace-04ex cal V_rm cyl+ x hspace-04ex cal V_rm nose+ x hspace-04ex cal V_rm bulk)\n\nx hspace-045ex W_rm fweb =\nrho_rm skin g   x hspace-04ex cal V_rm fweb\n05em\nW_rm shell = W_rm skin(1+f_rm string+f_rm frame+f_rm fadd) \n + W_rm fweb\n\nx hspace-045ex W_rm shell = x hspace-045ex W_rm skin(1+f_rm string+f_rm frame+f_rm fadd) \n + x hspace-045ex W_rm fweb\nendaligned","category":"page"},{"location":"structures/fuselage/#Fuselage-bending-loads","page":"Fuselage","title":"Fuselage bending loads","text":"","category":"section"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"In addition to the pressurization and torsion loads, the fuselage also sees bending loads from its distributed weight load plus the tail weight and airloads. In the case where the pressurization-sized shell is not sufficient to withstand this, additional bending material area is assumed to be added at the top and bottom (total of A_rm hbendscriptstyle (x)), and also sides of the shell (total of A_rm vbendscriptstyle (x)), as shown in figure 2. If the shell is sufficiently strong, then these areas will be zero.","category":"page"},{"location":"structures/fuselage/#Total-fuselage-weight","page":"Fuselage","title":"Total fuselage weight","text":"","category":"section"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"The total fuselage weight includes the shell with stiffeners, tailcone, floor beams, fixed weight, payload-proportional equipment and material, seats, and the added horizontal and vertical-axis bending material.","category":"page"},{"location":"structures/fuselage/","page":"Fuselage","title":"Fuselage","text":"beginaligned\nW_rm fuse = \nW_rm fix+ \nW_rm apu+ \nW_rm padd+ \nW_rm seat\nnonumber \n +  \nW_rm shell+ \nW_rm cone+\nW_rm window+ \nW_rm insul+ \nW_rm floor\nnonumber \n +\nW_rm hbend+ \nW_rm vbend\n \nx hspace-045ex W_rm fuse = \nx hspace-045ex W_rm fix+ \nx hspace-045ex W_rm apu+ \nx hspace-045ex W_rm padd+\nx hspace-045ex W_rm seat\nnonumber \n + \nx hspace-045ex W_rm shell+ \nx hspace-045ex W_rm cone+\nx hspace-045ex W_rm window+ \nx hspace-045ex W_rm insul+ \nx hspace-045ex W_rm floor\nnonumber \n + \nx hspace-045ex W_rm hbend+ \nx hspace-045ex W_rm vbend\nendaligned","category":"page"},{"location":"structures/fuselage/#TASOPT.structures.fusew!","page":"Fuselage","title":"TASOPT.structures.fusew!","text":"  fusew!(fuse,Nland,Wpay,Weng, nftanks, \n  Waftfuel, Wftank, ltank, xftankaft, tank_placement,deltap,\n  Whtail,Wvtail,rMh,rMv,Lhmax,Lvmax,\n  bv, λv,nvtail,\n  xhtail,xvtail,\n  xwing,xwbox,cbox,\n  xeng)\n\nfusew sizes the fuselage and calculates the component weights and structural properties. It takes inputs related to geometry, fixed weights, material properties, and more to compute the fuselage dimensions, weights, and other parameters.\n\ndetails: 🔃 Inputs and Outputs\nInputs:fuselage::struct: TASOPT.fuselage structure containing layout, internal and external load information\nNland::Float64: load factor for floor beam structural sizing.Cabin and Payload Information:Wpay::Float64: Fixed weight of payload.\ndeltap::Float64: Pressure differential.Engine Parameters:Weng::Float64: Fixed weight of engines.\nxeng::Float64: X location of engines.Fuel Tank Parametersnftanks::Int64: Number of fuel tanks\nWaftfuel::Float64: Fixed weight of aft fuel storage.\nWftank::Float64: Fixed weight of fuel tank.\nltank::Float64: Length of fuel tank.\nxtankaft::Float64: X location of aft fuel storage.\ntank_placement::String: Location of tank in fuselageTail parameters:Whtail::Float64: Weight of horizontal tail components.\nWvtail::Float64: Weight of vertical tail components.\nrMh::Float64: Horizontal tail moment arm.\nrMv::Float64: Vertical tail moment arm.\nLhmax::Float64: Maximum horizontal tail length.\nLvmax::Float64: Maximum vertical tail length.\nbv::Float64: Vertical tail span.\nλv::Float64: Vertical tail taper ratio.\nnvtail::Integer: Number of vertical tail units.\nxhtail::Float64: X location of horizontal tail components.\nxvtail::Float64: X location of vertical tail components.Wing Parametersxwing::Float64: X location of the wing.\nxwbox::Float64: X location of the wing box.\ncbox::Float64: Wing box width.Outputs:   Pressurized cabin volume:cabVol::Float64: Pressurized cabin volume.\n\nSee here or Section 2.2 of the TASOPT Technical Description.\n\n\n\n\n\n","category":"function"},{"location":"structures/wing/#wingtail","page":"Wings and tails","title":"Wings and tails","text":"","category":"section"},{"location":"structures/wing/","page":"Wings and tails","title":"Wings and tails","text":"The structural loads of the surfaces balance the net loads and moments resulting from weight and aerodynamics (tildep) as summarized in the Figure below. The distributions are also modified by point loads (i.e., engines and an optional strut).","category":"page"},{"location":"structures/wing/","page":"Wings and tails","title":"Wings and tails","text":"(Image: )","category":"page"},{"location":"structures/wing/","page":"Wings and tails","title":"Wings and tails","text":"The wing and tail surface stress and weight analyses are performed in the cross-sectional plane, normal to the spanwise axis y_scriptscriptstyle perp running along the wing box. The assumed wing or tail airfoil and structural box cross-section is shown in the figure below. Note that leading edges, fairings, slats, flaps, and spoilers contribute to weight but not to the primary structure.","category":"page"},{"location":"structures/wing/","page":"Wings and tails","title":"Wings and tails","text":"(Image: )","category":"page"},{"location":"structures/wing/","page":"Wings and tails","title":"Wings and tails","text":"using Markdown\nMarkdown.parse_file(joinpath(\"../..\", \"src/structures\",\"theory_wingstruct.md\"))","category":"page"},{"location":"structures/wing/#TASOPT.structures.size_wing_section!-Tuple{Any, Any, Any}","page":"Wings and tails","title":"TASOPT.structures.size_wing_section!","text":"size_wing_section!(section, sweep, sigfac)\n\nCalculates Loads and thicknesses for wing sections\n\ndetails: 🔃 Inputs and Outputs\nInputs:section::TASOPT.structures.Wing.WingSection: Wing Section to be sized.\nsweep::Float64: Wing sweep.\nsigfac::Float64: Stress factor\n\n\n\n\n\n","category":"method"},{"location":"structures/wing/#TASOPT.structures.wing_weights!-NTuple{12, Any}","page":"Wings and tails","title":"TASOPT.structures.wing_weights!","text":"wing_weights!(wing, po, gammat, gammas, \n   Nload, We, neout, dyeout, neinn, dyeinn, sigfac, rhofuel; n_wings=2.0)\n\nCalculates Wing or Tail loads, stresses, weights of individual wing sections. Also returns the material gauges, torsional and bending stiffness. Formerly, get_wing_weights!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:wing::TASOPT.structures.Wing: Wing structure.\npo::Float64: Wing root loading magnitude.\ngammat::Float64: Wing outer section taper ratio.\ngammas::Float64: Wing inner section taper ratio.\nNload::Int: Max vertical load factor for wing bending loads.\nWe::Float64: Weight of the engine.\nneout::Int:  Number of engines mounted outboard of the wing break (strut attachment point).\ndyeout::Float64: Spanwise moment arm for outboard engines, measured from the wing break station.\nneinn::Int: Number of engines mounted inboard of the wing break (strut attachment point).\ndyeinn::Float64: Spanwise moment arm for inboard engines, measured from the wing break station.\nsigfac::Float64: Stress Factor.\nrhofuel::Float64: Density of the fuel.\nn_wings::Int64: Number of total wings (1 for Vtail).\n\nSee Geometry,  Wing/Tail Structures, and Section 2.7  of the TASOPT Technical Description. \n\n\n\n\n\n","category":"method"},{"location":"structures/wing/#TASOPT.structures.calculate_centroid_offset-NTuple{6, Any}","page":"Wings and tails","title":"TASOPT.structures.calculate_centroid_offset","text":"  calculate_centroid_offset(b, bs, bo, λt, λs, sweep)\n\nCalculates area centroid x-offset due to sweep and the mean aerodynamic chord (normalized by root chord, co)\n\ndetails: 🔃 Inputs and Outputs\nInputs:b::Float64: Wingspan\nbs::Float64: Spanwise location of the start of the taper\nbo::Float64: Spanwise location of the root chord\nλt::Float64: Tip chord ratio (tip chord / root chord)\nλs::Float64: Start chord ratio (start chord / root chord).\nsweep::Float64: Sweep angle in degrees.Outputs:dx::Float64: Area centroid x-offset due to sweep\nmacco::Float64: Mean aerodynamic chord normalized by root chord.\n\nSee Geometry or Section 2.5.1  of the TASOPT Technical Description.\n\n\n\n\n\n","category":"method"},{"location":"propulsion/PEMfuelcell/#fuelcells","page":"PEM fuel cells","title":"PEM fuel cells","text":"","category":"section"},{"location":"propulsion/PEMfuelcell/","page":"PEM fuel cells","title":"PEM fuel cells","text":"To study novel aircraft designs that may leverage cryogenic hydrogen, the following fuel cell models were integrated, along with cryogenic tank and heat exchanger models.","category":"page"},{"location":"propulsion/PEMfuelcell/#Theory","page":"PEM fuel cells","title":"Theory","text":"","category":"section"},{"location":"propulsion/PEMfuelcell/","page":"PEM fuel cells","title":"PEM fuel cells","text":"details: 📖 Theory - Proton-exchange membrane fuel cells\nProton-exchange membrane (PEM), also known as polymer electrolyte membrane, fuel cells are electrochemical devices that convert the chemical energy of a fuel to electrical energy through low-temperature oxidation and reduction reactions. Unlike a combustion process in which these processes occur through direct collisions between molecules, the oxidation and reduction reactions are physically separated in fuel cells by a membrane, across which ions produced in the oxidation reaction drift to complete the overall chemical reaction. A diagram of a hydrogen-air fuel cell is shown below. The overall reaction is mathrmH_2 + frac12mathrmO_2 rightarrow mathrmH_2mathrmOand this occurs through two half reactions: an oxidation reactionmathrmH_2 rightarrow 2mathrmH^+ + 2e^-and a reduction reactionfrac12mathrmO_2+2mathrmH^+ + 2e^- rightarrow mathrmH_2mathrmOwhere e^- represents a free electron. In a PEM fuel cell, the oxidation reaction occurs at the anode, with protons drifting across the electrolyte membrane towards the cathode where reduction occurs, while electrons complete an external electric circuit. There are three regions of physical interest in a fuel cell: a bulk flow region, a diffusion layer, and an electrolyte layer. The bulk flow refers to the region outside of the electrodes, which is dominated by advection. The diffusion region is the region inside the porous electrodes, where there cannot be significant advection and molecular motion is governed by diffusion. The electrolyte is the region between the electrodes, where ions drift to close the circuit.(Image: PEMfig)The voltage across a fuel cell is governed by thermodynamics and different loss types[1]V = E_r - eta_mathrmohm - eta_C - eta_Awhere E_r is the thermodynamic reversible voltage, eta_mathrmohm is the ohmic overvoltage due to Joule heating, and eta_A and eta_C are the anode and cathode overvoltages due to activation and concentration losses. The following model is adapted from that in Springer et al.[2]; two versions of this have been implemented: a low-temperature PEMFC model that closely follows the original one in Springer et al.[2], and a high-temperature PEMFC model that is based on it but makes modifications to reflect the different operating temperatures and membrane properties.Reversible voltageThe maximum theoretical energy that can be converted to electrical energy is given by the change in Gibbs free+- energy (Delta G) in this process. Every mole of hydrogen produces nF moles of electrons, where F is the Faraday constant and n=2 is the number of electrons produced for each unit of hydrogen. Therefore, the voltage produced in this reversible reaction is given byE_r = fracDelta hatgnFwhere Delta hatg is the molar specific change in Gibbs free energy. In general, Delta hatg is a function of temperature as well as of reactant pressure. The reversible voltage of a fuel cell can be calculated using the Nernst equation to account for these effects[1],E_r = E_0 + fracDelta hatsnF(T-T_0) - fracRTnFlnleft(fracp_0^32p_mathrmH_2 p_mathrmO_2^12right)where T is the fuel cell temperature, p_0=1atm, T_0=29815K, and p_mathrmH_2 and p_mathrmO_2 denote the partial pressures of oxygen and hydrogen in the reactants. The term E_0 is the reversible voltage at standard conditions, and it is equal to E_0=1229V for liquid water as a product and E_0=1185V for gaseous water. Similarly, the term Delta hats denotes the molar specific entropy change during the reaction, and it is Delta hats=-4434J/(mol K) for gaseous water as a product and Delta hats=-16323J/(mol K) for liquid water.Ohmic lossesAs ions drift through the electrolyte material, they produce ohmic heating as a result of the electrical resistance of the electrolyte. The area-specific resistance (ASR) of the electrolyte can be calculated asmathrmASR = int_0^t_M fracdzsigma(z)where t_M is the electrolyte thickness, sigma is the conductivity of the electrolyte material to ionic motion, and z is a coordinate normal to the electrolyte surface from the anode to the cathode. As the ASR increases with electrolyte thickness, thin electrolytes are preferred. The conductivity depends on the choice of material. A common electrolyte in low-temperature PEM fuel cells is Nafion, which shows excellent ion conduction properties but needs to be constantly hydrated. The conduction properties of Nafion depend on its water content, lambda, defined as the ratio of water molecules to ion conduction sites. An empirical expression for the conductivity of Nafion (in (Omega cm)^-1) as a function of  lambda and temperature is[2]sigma = expleft1268left(frac1303-frac1Tright)right(0005139lambda-000326)A key challenge in modeling the ohmic losses is to identify how lambda changes depending on the operating parameters. It can be shown that the change in lambda in the direction normal to the electrolyte surface is governed by[2] fracdlambdadz = left(n^mathrmSAT_mathrmdragfraclambda11-alpha^*right)fracjM_m2Frho_mathrmdryD_lambdawhere alpha^* is defined as the ratio of water molecule flux to proton flux (in general an unknown), n^mathrmSAT_mathrmdragapprox 25 is the number of water molecules dragged by each proton in fully hydrated Nafion,  rho_mathrmdry=1970kg m^-3 is the density of dry Nafion, M_mapprox 1kg mol^-1 is the Nafion equivalent weight, j is the current density that the fuel cell is operating at, and D_lambda is the diffusivity of water in the Nafion membrane. The parameter D_lambda is a weak function of lambda[2]. Water content in the electrode/Nafion interface changes as a function of water activity in the electrode, defined as a_w=fracx_mathrmH_2Opp_mathrmSAT, where x_mathrmH_2O is the water concentration outside the membrane and p_mathrmSAT is the saturation partial pressure of water at the fuel cell temperature. If a_wleq 1, expected at the anode side, the relationship can be expressed with a polynomial from a data fit[2],lambda = 0043 + 1781 a_w - 3985 a_w^2 + 36 a_w^3and for a_w1, expected at the cathode, the relationship is linear but with a different slope[2],lambda = 14 +14 (a_w-1)As the reaction proceeds, oxygen and hydrogen are consumed and this affects the concentration in the bulk flow. This effect can be captured with a stoichiometric ratio of hydrogen at the anode and another one for oxygen at the cathode, lambda_mathrmH_2 an lambda_mathrmO_2; for example, if lambda_mathrmO_2=1, all the oxygen is consumed in the reaction. To use these relationships, it is necessary to calculate the water and reactant concentrations at the membrane/electrode interface. To do so, it is necessary to first determine the water and hydrogen concentration at station 1 and the water and oxygen concentrations at 3, from a mass balance considering depletion effects. Explicit equations for these concentrations as a function of alpha^* and the stoichiometry ratios are given in [2]. Once these are known, the concentrations at 2 and 3 can be determined from the diffusion of the species (see note below).The key step in this model is to calculate alpha^* by matching the water concentration (or water content) at the cathode/membrane interface produced by two methods. If the water concentration is solved by integrating the diffusion equation from the cathode side, a water content at the interface lambda^prime_3 can be calculated from the water activity. Similarly, the water activity at 3 can be calculated by first integrating the diffusion equation from the anode side to find the water concentration at 2, then calculating the water content at 2 from the activity, and then integrating the equation above for fracdlambdadz across the membrane to find the water content at 3, lambda_3. The correct alpha^* has been found if lambda^prime_3 -lambda_3. A root finding algorithm is used in the code to find the alpha^* that fulfills this condition.Once alpha^* has been determined, it can be used to find the water content profile across the membrane by solving the ODE for lambda (done numerically in the code). Finally, the conductivity can be calculated from the expression above and this can be used to determine ASR.In contrast, polybenzimidazole (PBI) membranes are commonly used in high-temperature PEMFCs. Unlike Nafion, they do not require to be hydrated and they have a negligible water flux across them. A model for how the conductivity of PBI changes with operating conditions is provided in Jio and Li[3],sigma = frac(168mathrmDL^3 - 6324 mathrmDL^2 + 65760 mathrmDL + 8460) b T expleft(-frac-6196mathrmDL + 21650RTright)where mathrmDL is the phosphoric acid doping level, defined as the ratio of phosphoric acid molecules to number of PBI repeat unit (typically of the order of 5), and b is given byb = begincases\n1+(001704T - 4767)mathrmRH_avg  textfor   37315leq Tleq 41315\n1+(01432T - 5689)mathrmRH_avg  textfor  41315  Tleq 45315\n1+(07T - 3092)mathrmRH_avg  textfor  45315  Tleq 47315\nendcaseswhere mathrmRH_avg is the average of the relative humidity in stations 2 and 3, and the relative humidity is simply mathrmRH=fracx_mathrmH_2Opp_mathrmSAT. To use this expression, it is necessary to calculate the water concentration is stations 2 and 3. As in the low-temperature model, this is done by solving the diffusion equations in Springer et al.[2] analytically, with the key difference that there is no water flux across the membrane.The ohmic overvoltage, or ohmic loss, is given byeta_mathrmohm = j mathrmASRWater saturationThere are many models for the saturation partial pressure of water. A possible model valid under 383.15 K is [4]p_mathrmSAT = fracexpleft(34494 - frac492499t + 2371right)(t + 105)^157 where t is the temperature in degrees Celsius and p_mathrmSAT is in pascals. A model for temperatures between 383.15 and 483 K is[3]p_mathrmSAT = 068737  T^3 - 73239  T^2 +263390  T -31919000 where T is in kelvin.DiffusivityThe diffusion of a species in a multi-species gas is complex. The Stefan-Maxwell expression can be used to model the derivative in space of the concentration of species i,fracdx_idz= RT sum_j fracx_i N_j - x_j N_ip D_ijwhere the sum is made over all the species that i can collide with, and N represents the molar flux. Equations for the spatial derivative of concentration can be found in [2]; for this particular model, there are closed-form solutions.This equation requires determining the binary diffusivities of all the species involved. A model for binary diffusivity of species i and j isp D_ij = a left(fracTsqrtT_ci T_cjright)^b (p_ci p_cj)^13 (T_ci T_cj)^512left(frac1M_i + frac1M_jright)^12where the pressures are in atm and the diffusivity is in cm^2/s. For gas pairs involving nonpolar gases, a=2745times10^-4 and b=1823. For pairs involving water and another nonpolar gas, a=3640times10^-4 and b=2334. The parameters T_c and p_c can be found in Table 5.1 in [1].When diffusion is occurring inside a porous material, such as a PEM electrode, the material structure affects the diffusion properties. This can be captured via an effective diffusivity, D^mathrmeff, which is given byD^mathrmeff = D varepsilon ^tauwhere varepsilon is the porosity of the material (a typical value is 0.4), and tau is the tortuosity, which can vary between 1.5 and 10.Cathode overvoltageThe fuel cell also experiences voltage drop due to activation losses, since a voltage is required to provide activation energy for the half reactions, and due to concentration losses, as the maximum current is limited by the rate of diffusion from the bulk flow to the electrodes. These losses are most significant at the cathode side; in this model, anode voltage drops are ignored. The cathode overvoltage can be calculated using the Tafel equation,eta_C = fracRTn_C alpha F ln leftfracjj_0 fracp_Cp_0 x_mathrmO_23effrightwhere n_C=4 is the number of electrons exchanged in the reduction reaction and alpha represents a symmetry parameter, typically 0.3–0.5. The effective oxygen concentration at 3, x_mathrmO_23eff, accounts for the fact that part of the water on the cathode side is actually in liquid phase in low-temperature PEMFCs. For these, it is given byx_mathrmO_23eff = fracx_mathrmO_231-x_liqwhere x_liq = x_mathrmH_2O3 - p_mathrmSAT  p_C is the fraction of water in the cathode that is in liquid phase. In high-temperature PEMFCs, all water is in gaseous phase, so x_mathrmO_23eff =x_mathrmO_23.The exchange current density, j_0, is related to the catalyst properties and effective surface area. A model for it is[5]j_0 = j_0reffracA_effAleft(fracx_mathrmO_23effp_Cp_0right)^gamma expleft-fracE_aRTleft(1-fracTT_0right)rightwhere j_0refsim 10^-9 A/m^2 is the reference exchange current density for a platinum catalyst at T_0 and p_0, fracA_effA is the ratio of effective surface area of the catalyst to geometric area (can be of the order of 1000), gamma is a parameter in the range of 0.5–1.0, and E_a=66 kJ/mol is the activation energy for oxygen reduction on platinum.","category":"page"},{"location":"propulsion/PEMfuelcell/#Functions","page":"PEM fuel cells","title":"Functions","text":"","category":"section"},{"location":"propulsion/PEMfuelcell/#Low-temperature-PEM-model","page":"PEM fuel cells","title":"Low-temperature PEM model","text":"","category":"section"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.LT_PEMFC_voltage","page":"PEM fuel cells","title":"TASOPT.engine.LT_PEMFC_voltage","text":"LT_PEMFC_voltage(u, α_guess::Float64 = 0.25)\n\nA 1-D model of the voltage across a low-temperature PEM fuel cell with a Nafion membrane, based on the model in Springer et al. (1991), which captures the effect of reactant depletion, multispecies diffusion and water transport in the membrane.\n\ndetails: 🔃 Inputs and Outputs\nInputs:u::Struct: structure of type PEMFC_inputs with inputs\nα_guess::Float64: guess for ratio of water flux to proton flux; default is 0.25Outputs:V::Float64: voltage across cell (V)\nα_star::Float64: ratio of water flux to proton flux\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.water_balance","page":"PEM fuel cells","title":"TASOPT.engine.water_balance","text":"water_balance(α_star, u, p)\n\nThis function calculates the difference between the water content at 3 from integration from the anode or cathode sides. This residual should be 0 if α_star is the correct one.\n\ndetails: 🔃 Inputs and Outputs\nInputs:α_star::Float64: ratio of water flux to proton flux\nu::Struct: structure of type PEMFC_inputs with inputs \np::Struct: structure of type PEMFC_params with parameters Outputs:x_end::Vector{Float64}: vector with values of x at z = d\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.Nafion_diffusion","page":"PEM fuel cells","title":"TASOPT.engine.Nafion_diffusion","text":"Nafion_diffusion(T, λ)\n\nThis function estimates the diffusion coefficient of water in Nafion.\n\ndetails: 🔃 Inputs and Outputs\nInputs:T::Float64: fuel cell temperature (K)\nλ::Float64: water content; ratio of water molecules to SO3- sitesOutputs:D_λ::Float64: water diffusion coefficient in Nafion (m^2/s)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.conductivity_Nafion","page":"PEM fuel cells","title":"TASOPT.engine.conductivity_Nafion","text":"conductivity_Nafion(T, λ)\n\nThis function calculates the conductivity of Nafion as a function of water content.\n\ndetails: 🔃 Inputs and Outputs\nInputs:T::Float64: fuel cell temperature (K)\nλ::Float64: water content; ratio of water molecules to SO3- sitesOutputs:σ::Float64: conductivity (Ohm m)^-1\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.λ_calc","page":"PEM fuel cells","title":"TASOPT.engine.λ_calc","text":"λ_calc(a)\n\nThis function calculates the water content at the Nafion/electrode interface based on water activity.\n\ndetails: 🔃 Inputs and Outputs\nInputs:a::Float64: water activityOutputs:λ::Float64: water content; ratio of water molecules to SO3- sites\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.dλ_dz_membrane","page":"PEM fuel cells","title":"TASOPT.engine.dλ_dz_membrane","text":"dλ_dz_membrane(λ, u, p)\n\nThis function evaluates the derivative in space of the water content in the membrane.\n\ndetails: 🔃 Inputs and Outputs\nInputs:λ::Float64: water content; ratio of water molecules to SO3- sites\nu::Struct: structure of type PEMFC_inputs with inputs \np::Struct: structure of type PEMFC_params with parameters Outputs:dλ_dz::Float64: derivative of λ in space\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#High-temperature-PEM-model","page":"PEM fuel cells","title":"High-temperature PEM model","text":"","category":"section"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.HT_PEMFC_voltage","page":"PEM fuel cells","title":"TASOPT.engine.HT_PEMFC_voltage","text":"HT_PEMFC_voltage(u)\n\nA 1-D model of the voltage across a high-temperature PEM fuel cell with a PBI membrane. The code is based on the LT-PEMFC model by Springer et al. (1991), modified to eliminate water transport across the membrane and with conductivity values for PBI.\n\ndetails: 🔃 Inputs and Outputs\nInputs:u::Struct: structure of type PEMFC_inputs with inputsOutputs:V::Float64: voltage across cell (V)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.conductivity_PBI","page":"PEM fuel cells","title":"TASOPT.engine.conductivity_PBI","text":"conductivity_PBI(T, DL, RH)\n\nThis function calculates the conductivity of a PBI membrane as a function of temperature, doping level and humidity. Model from K. Jiao and X. Li (2009). A Three-Dimensional Non-isothermal Model of High Temperature Proton Exchange  Membrane Fuel Cells with Phosphoric Acid Doped Polybenzimidazole Membranes.\n\ndetails: 🔃 Inputs and Outputs\nInputs:T::Float64: fuel cell temperature (K)\nDL::Float64: phosphoric acid doping level\nRH::Float64: average relative humidity across membraneOutputs:σ::Float64: conductivity (Ohm m)^-1\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#Stack-and-design","page":"PEM fuel cells","title":"Stack and design","text":"","category":"section"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.PEMsize","page":"PEM fuel cells","title":"TASOPT.engine.PEMsize","text":"PEMsize(P_des, V_des, u)\n\nDesigns the fuel cell stack for the design point conditions.\n\ndetails: 🔃 Inputs and Outputs\nInputs:P_des::Float64: design stack output power, ideally maximum power in mission (W)\nV_des::Float64: design stack voltage (V)\nu::Struct: structure of type PEMFC_inputs with inputs Outputs:n_cells::Float64: number of cells in stack\nA_cell::Float64: cell surface area (m^2)\nQ::Float64: waste power produced by the fuel cell at design point (W)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.PEMoper","page":"PEM fuel cells","title":"TASOPT.engine.PEMoper","text":"PEMoper(P_stack, n_cells, A_cell, u)\n\nEvaluates fuel cell stack performance in off-design conditions.\n\ndetails: 🔃 Inputs and Outputs\nInputs:P_stack::Float64: stack output power (W)\nn_cells::Float64: number of cells in stack\nA_cell::Float64: cell surface area (m^2)\nu::Struct: structure of type PEMFC_inputs with inputs Outputs:V_stack::Float64: stack voltage (V)\nQ::Float64: waste power produced by the fuel cell (W)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.PEMstackweight","page":"PEM fuel cells","title":"TASOPT.engine.PEMstackweight","text":"PEMstackweight(gee, u, A, n_cells, fouter)\n\nCalculates the weight of a stack of PEM fuel cells.\n\ndetails: 🔃 Inputs and Outputs\nInputs:gee::Float64: gravitational acceleration (m/s^2)\nu::Struct: structure of type PEMFC_inputs with inputs \nn_cells::Float64: number of cells in stack\nA_cell::Float64: cell surface area (m^2)\nfouter::Float64: ratio of stack structural mass (inc. bipolar plates) to membrane and electrode massOutputs:W_stack::Float64: weight of FC stack (N)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#Physics-and-mathematics","page":"PEM fuel cells","title":"Physics and mathematics","text":"","category":"section"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.water_sat_pressure","page":"PEM fuel cells","title":"TASOPT.engine.water_sat_pressure","text":"water_sat_pressure(T)\n\nFunction to calculate the saturation partial pressure of water. It uses different models for temperatures above or below 100 degrees Celsius. \n\ndetails: 🔃 Inputs and Outputs\nInputs:T::Float64: gas temperature (K)Outputs:p_SAT::Float64: saturation pressure (Pa)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.binary_diffusion","page":"PEM fuel cells","title":"TASOPT.engine.binary_diffusion","text":"binary_diffusion(T, p, sps)\n\nThis model estimates the binary diffusion coefficient of a gas species in a water vapor, to be used inside the electrodes. It uses the method of Slattery and Bird (1958) for low pressures.\n\ndetails: 🔃 Inputs and Outputs\nInputs:T::Float64: gas temperature (K)\np::Float64: gas pressure (Pa)\nsps::Vec{String}: gas species vector (\"H2\", \"H2\", \"N2\" or \"O2\")Outputs:D::Float64: diffusion coefficient (m^2/s)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.porous_diffusion","page":"PEM fuel cells","title":"TASOPT.engine.porous_diffusion","text":"porous_diffusion(D, ε, τ)\n\nThis model estimates the effective diffusion coefficient of a gas in a porous environment, such as a PEM electrode.\n\ndetails: 🔃 Inputs and Outputs\nInputs:D::Float64: diffusion coefficient outside porous material (m^2/s)\nε::Float64: porosity of material\nτ::String: tortuosity of materialOutputs:Deff::Float64: effective diffusion coefficient (m^2/s)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.cathode_j0","page":"PEM fuel cells","title":"TASOPT.engine.cathode_j0","text":"cathode_j0(T, p, Aeff_ratio)\n\nThis function calculates the exchange current density of a PEM with a platinum catalyst. \n\ndetails: 🔃 Inputs and Outputs\nInputs:T::Float64: fuel cell temperature (K)\np::Float64: reactant partial pressure (Pa)\nAeff_ratio::Float64: ratio of catalyst surface area to geometric cross-sectional areaOutputs:j0::Float64: exchange current density (A/m^2)\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/#OrdinaryDiffEqLowOrderRK.RK4","page":"PEM fuel cells","title":"OrdinaryDiffEqLowOrderRK.RK4","text":"RK4(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  The canonical Runge-Kutta Order 4 method. Uses a defect control for adaptive stepping using maximum error over the whole interval.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{shampine2005solving,       title={Solving ODEs and DDEs with residual control},       author={Shampine, LF},       journal={Applied Numerical Mathematics},       volume={52},       number={1},       pages={113–127},       year={2005},       publisher={Elsevier}       }\n\n\n\n\n\n","category":"type"},{"location":"propulsion/PEMfuelcell/#TASOPT.engine.solve_diffusion_ODE","page":"PEM fuel cells","title":"TASOPT.engine.solve_diffusion_ODE","text":"solve_diffusion_ODE(M, B, x0, d)\n\nThis function uses eigendecomposition to solve a problem of the form dx/dz = M * x + B\n\ndetails: 🔃 Inputs and Outputs\nInputs:M::Matrix{Float64}: matrix with coefficients\nB::Vector{Float64}: vector with right-hand parameters\nx0::Vector{Float64}: vector with the boundary conditions\nd::Float64: distance at which to evaluate x, z = dOutputs:x_end::Vector{Float64}: vector with values of x at z = d\n\n\n\n\n\n","category":"function"},{"location":"propulsion/PEMfuelcell/","page":"PEM fuel cells","title":"PEM fuel cells","text":"[1]: O'Hayre, Ryan, et al. Fuel cell fundamentals. John Wiley & Sons, 2016.","category":"page"},{"location":"propulsion/PEMfuelcell/","page":"PEM fuel cells","title":"PEM fuel cells","text":"[2]: Springer, Thomas E., T. A. Zawodzinski, and Shimshon Gottesfeld. \"Polymer electrolyte fuel cell model.\" Journal of the electrochemical society 138.8 (1991): 2334.","category":"page"},{"location":"propulsion/PEMfuelcell/","page":"PEM fuel cells","title":"PEM fuel cells","text":"[3]: Jiao, K., and X. Li. \"A Three‐Dimensional Non‐isothermal Model of High Temperature Proton Exchange Membrane Fuel Cells with Phosphoric Acid Doped Polybenzimidazole Membranes.\" Fuel Cells 10.3 (2010): 351-362.","category":"page"},{"location":"propulsion/PEMfuelcell/","page":"PEM fuel cells","title":"PEM fuel cells","text":"[4]: Huang, Jianhua. \"A simple accurate formula for calculating saturation vapor pressure of water and ice.\" Journal of Applied Meteorology and Climatology 57.6 (2018): 1265-1272.","category":"page"},{"location":"propulsion/PEMfuelcell/","page":"PEM fuel cells","title":"PEM fuel cells","text":"[5]: Barbir, Frano. PEM fuel cells: theory and practice. Academic press, 2012.","category":"page"},{"location":"aero/theory_pitching/","page":"-","title":"-","text":"details: 📖 Theory - Surface pitching moment\nThe surface's reference axis is at some specified chordwise fractional location xi_rm ax, as shown in the first figure. The profile pitching moment acts along the span-axis coordinate y_scriptscriptstyle perp, and scales with the normal-plane chord c_scriptscriptstyle perp. These are shown in the first figure, and related to the spanwise and streamwise quantities via the sweep angle.beginaligned\ny_scriptscriptstyle perp =  y   cos Lambda \nlabelyperp \nc_scriptscriptstyle perp =  c  cos Lambda \nlabelcperp \nV_scriptscriptstyle perp =  V_scriptscriptstyle infty cos Lambda \nlabelVperp \nendalignedThe airfoil's pitching moment contribution shown in the figure below isbeginaligned\ndM_y_scriptscriptstyle perp  =  \nfrac12 rho V_scriptscriptstyle perp^2  c_scriptscriptstyle perp^2  c_m   rm dy_scriptscriptstyle perp\n \nc_m scriptstyle (eta) =  left\nbeginarraylcl\n c_m_o    0  eta  eta_o\n05em\ndisplaystyle\n c_m_o + (c_m_s - c_m_o) \n            fraceta - eta_oeta_s-eta_o\n   eta_o  eta  eta_s\n025em\ndisplaystyle\n c_m_s + (c_m_t - c_m_s) \n            fraceta - eta_s1-eta_s\n   eta_s  eta  1\nendarray\nright\nlabelcmeta\nendalignedand including the contribution of the lift load tildep with its moment arm gives the following overall wing pitching moment Delta M_rm wing increment about the axis center location.  beginaligned rm dDelta M_rm wing =   tildep left c_scriptscriptstyle perp left(xi_rm ax-textstyle frac14right)  cosLambda       - (y-y_o) tanLambda right  rm dy  + rm dM_y_scriptscriptstyle perp  cosLambda hspace3em endaligned Integrating this along the whole span then gives the total surface pitching moment about its root axis. beginaligned\nDelta M_rm wing =  \n(p_o  b_o + 2Delta L_o)  c_o  left( xi_rm ax - textstyle frac14right) \nnonumber \n +  \ncos^2  Lambda \nb int_eta_o^1 pscriptstyle (eta) cscriptstyle (eta)left( xi_rm ax - textstyle frac14right) \n rm deta \nnonumber \n - \nfracb2  tanLambda  b int_eta_o^1 pscriptstyle (eta)(eta-eta_o) \n rm deta \nnonumber \n +  2 Delta L_t left\nc_o lambda_t left( xi_rm ax - textstyle frac14right) cos^2Lambda \n-\nfracb2 (1-eta_o)  tanLambda right\nnonumber \n + frac12 rho V_scriptscriptstyle infty^2  cos^4  Lambda  b \nint_eta_o^1  c_m scriptstyle (eta) cscriptstyle (eta)^2  rm deta \n\n\nDelta M_rm wing = \np_o  b  c_o  eta_o \n(1 + f_L_scriptstyle o)  left( xi_rm ax - textstyle frac14right) \nnonumber \n +\np_o  b  c_o left( xi_rm ax - textstyle frac14right) cos^2  Lambda \nfrac13\nleft \nleft( 1 + textstyle frac12left(lambda_s +gamma_sright) + lambda_s gamma_s\n      right)(eta_s - eta_o) \nright\nnonumber \n hspace9em\nleft\n+\nleft( lambda_s gamma_s + \n      textstyle frac12left(lambda_s gamma_t+gamma_slambda_tright)\n    + lambda_t gamma_t\n      right)(1 - eta_s)  right\nnonumber \n -\np_o  b  c_o  fractanLambdaK_o  \nfrac112 left \n      left( 1 + 2gamma_s right) (eta_s - eta_o)^2 \n+  left( gamma_s + 2gamma_tright) (1 - eta_s)^2\n+  3left( gamma_s + gamma_t right) (eta_s - eta_o)(1 - eta_s)\n         right\nnonumber \n +\n2  p_o  b  c_o  f_L_scriptstyle t lambda_t  gamma_t left\nK_o lambda_t left( xi_rm ax - textstyle frac14right) cos^2Lambda \n- textstyle frac12(1-eta_o)  tanLambda right\nnonumber \n + \nfrac12 rho V_scriptscriptstyle infty^2  S  c_o  fraccos^4LambdaK_c \nfrac112\nleft left(\n      c_m_o (3             + 2           lambda_s + lambda_s^2)\n    + c_m_s (3 lambda_s^2 + 2           lambda_s +   1        )\n      right)(eta_s-eta_o)  right\nnonumber \n\nleft\n+     left(\n      c_m_s (3 lambda_s^2 + 2 lambda_s lambda_t + lambda_t^2)\n    + c_m_t (3 lambda_t^2 + 2 lambda_s lambda_t + lambda_s^2)\n      right)(1-eta_s)  \nright\nhspace3em\nlabelDMwing\nendalignedBy using the relation beginaligned\np_o  b  =  frac12 rho V_scriptscriptstyle infty^2  S \nfrac1K_p left( C_L - fracS_rm hS C_L_rm h right)\nendalignedand the equation above it gives the equivalent pitching moment coefficient constant and C_L derivative. beginaligned\nDelta C_M_rm wing equiv\nfracDelta M_rm wingtextstyle frac12rho V_scriptscriptstyle infty^2 S c_o\n =  Delta C_m_0 \n+ fracrm dC_mrm dC_L \nleft( C_L - fracS_rm hS C_L_rm h right)\n\nfracrm dC_mrm dC_L \n = \nfrac1K_p left rule-125ex0ex45ex\neta_o \n(1 + f_L_scriptstyle o)  left( xi_rm ax - textstyle frac14right) \nright\nnonumber \n \n+  left( xi_rm ax - textstyle frac14right) cos^2  Lambda \nfrac13\nleft \nleft( 1 + textstyle frac12left(lambda_s +gamma_sright) + lambda_s gamma_s\n      right)(eta_s - eta_o) \nright\nnonumber \n\nleft\n+\nleft( lambda_s gamma_s + \n      textstyle frac12left(lambda_s gamma_t+gamma_slambda_tright)\n    + lambda_t gamma_t\n      right)(1 - eta_s)  right\nnonumber \n \n-  fractanLambdaK_o \nfrac112 left \n      left( 1 + 2gamma_s right) (eta_s - eta_o)^2 \n+  left( gamma_s + 2gamma_tright) (1 - eta_s)^2 \n        right\nnonumber \n \nleft\n+ 3left( gamma_s + gamma_t right) (eta_s - eta_o)(1 - eta_s)\n      rule-05ex0ex3ex     right\nnonumber \n \nleft\n+  2  f_L_scriptstyle t lambda_t  gamma_t left\nK_o lambda_t left( xi_rm ax - textstyle frac14right) cos^2Lambda \n- textstyle frac12(1-eta_o)  tanLambda right\nrule-125ex0ex45ex  right\n\n\n\nDelta C_m_0 \n = \nfraccos^4 LambdaK_c \nfrac112\nleft left(\n      c_m_o (3             + 2           lambda_s + lambda_s^2)\n    + c_m_s (3 lambda_s^2 + 2           lambda_s +   1        )\n      right)(eta_s-eta_o)  right\nnonumber \n hspace1em\nleft\n+     left(\n      c_m_s (3 lambda_s^2 + 2 lambda_s lambda_t + lambda_t^2)\n    + c_m_t (3 lambda_t^2 + 2 lambda_s lambda_t + lambda_s^2)\n      right)(1-eta_s)  \nright\nhspace3em\nlabelCM0wing\nhspace2em\nendaligned(Image: Wing pitching moment quantities.)","category":"page"},{"location":"examples/loadingrunning/#firstexample","page":"Loading and running","title":"Loading and running a model","text":"","category":"section"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"TASOPT.jl uses TOML files to define aircraft models. You can find example input files at /example/defaults/. The majority of aircraft parameters and assumptions are defined here, and it's a useful resource for understanding the parameters and typical values.","category":"page"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"Start by importing TASOPT.jl and then loading the default aircraft model.","category":"page"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"julia> using TASOPT\njulia> example_ac = load_default_model()\nLoading default aircraft model\nName: Default TASOPT Model;\nWpay = 172.0 kN\nDes. Range  = 5.56e6 km\nCruise Mach = 0.8","category":"page"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"Alternatively, you can load your desired input file (perhaps a modified version of a default file) by using:","category":"page"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"julia> example_ac = read_aircraft_model(\"../input.toml\") # MODIFY <path> appropriately","category":"page"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"example_ac is an instance of an aircraft struct (what Julia calls composite types); it's a thin wrapper for other structs representing aircraft components, and additional \"par\" arrays that store design and performance quantities. Refer to the sections on data structures for an introduction and details.","category":"page"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"You can size this aircraft by running:","category":"page"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"julia> size_aircraft!(example_ac)\nMax payload weight was not set, setting Wpaymax = Wpay\nWfuel initial = 132502.37055588452\niterw             errW            errW1            WMTO           Wfuel          Wftank          Wtesys            Wmot            Wgen         Wtshaft           Wwing            span            area          HTarea           xwbox \n    1  +1.00000000e+00  +1.00000000e+00  6.51600802e+05  1.32502371e+05  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  8.60730957e+04  0.00000000e+00  0.00000000e+00  1.35396163e+01  1.73736000e+01\n    2  +1.00000000e+00  +1.66001430e-02  7.70269325e+05  2.16922911e+05  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.10711244e+05  3.25978109e+01  1.05209631e+02  3.71505481e+01  1.73736000e+01\n ...\n   15  +7.45835713e-09  -7.45835713e-09  7.76336715e+05  2.12378504e+05  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.04209402e+05  3.54371733e+01  1.24335966e+02  4.20539315e+01  1.62730055e+01\n\nTakeoff:\n #        lTO         l1        lBF       dmax\n 1   6474.360   5179.488   8416.667    355.380\n 2   6474.360   5534.868   8485.441      3.718\n 3   6474.360   5538.586   8485.689      0.000","category":"page"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"Once sized, an aircraft's performance can be determined for other missions by modifying or appending to Mission fields within an input.toml and running fly_mission!().","category":"page"},{"location":"examples/loadingrunning/","page":"Loading and running","title":"Loading and running","text":"julia> include(__TASOPTindices__)    #provides vars to access par array parameters (here, imPFEI)\n\njulia> example_ac.parm[imPFEI,:]     #after sizing, the design mission (the first) is evaluated and the mission fuel weight is known\n2-element Vector{Float64}:\n 0.9443825885056822\n 0.0\n\njulia> fly_mission!(example_ac, 2)   #evaluate the second mission\n\njulia> example_ac.parm[imPFEI,:]     #the second mission's fuel weight is known\n2-element Vector{Float64}:\n 0.9443825885056822\n 1.080316809817944","category":"page"},{"location":"aero/moment/#Pitching-moment","page":"Pitching moment","title":"Pitching moment","text":"","category":"section"},{"location":"aero/moment/","page":"Pitching moment","title":"Pitching moment","text":"The pitching moments of lifting surfaces are computed by integration of the wing loading with reference to a prescribable wing axis.","category":"page"},{"location":"aero/moment/","page":"Pitching moment","title":"Pitching moment","text":"using Markdown\nMarkdown.parse_file(joinpath(\"../..\", \"src/aero\",\"theory_pitching.md\"))","category":"page"},{"location":"aero/moment/#TASOPT.aerodynamics.wing_CM-NTuple{15, Any}","page":"Pitching moment","title":"TASOPT.aerodynamics.wing_CM","text":"wing_CM(b,bs,bo, sweep, Xaxis,\n                   λt, λs, γt, γs,\n                   AR, fLo, fLt, cmpo, cmps, cmpt)\n\nCalculates components of wing pitching moment (C_M) about wing root axis:\n\nC_M = C_M0 + C_M1 (C_L - C_Lsurf)\n\nΔC_m surf = ΔC_m 0 + dCₘdCL  (C_L - C_Lh)\n\nFormerly, surfcm().\n\ndetails: 🔃 Inputs and Outputs\nInputs:b::Float64: Span.\nbs::Float64: Outer panel break span.\nbo::Float64: Root (fuselage) span.\nsweep::Float64: Sweep, degrees.-\tXaxis::Float64: Surface axis position.λt::Float64: Outer-panel chord taper ratio  ct/co.\nλs::Float64: Inner-panel chord taper ratio  cs/co.\nγt::Float64: Outer-panel load  taper ratio  pt/po.\nγs::Float64: Inner-panel load  taper ratio  ps/po.\nAR::Float64: Surface aspect ratio.\nfLo::Float64, fLt::Float64 : Wing root and tip load adjustment factors.\ncmpo::Float64,cmps::Float64,cmpt::Float64: Perpendicular sectional lift coefficient at wing root, break (\"snag\"), and tip.Outputs:CM0::Float64: Zero-lift surface pitching moment.\nCM1::Float64: Surface pitching moment including lift contribution.\n\nSee Section 2.6.3 of the TASOPT Technical Desc. See also wing_profiledrag_scaled and wing_profiledrag_direct.\n\n\n\n\n\n","category":"method"},{"location":"aero/theory_airfun_and_splines/","page":"-","title":"-","text":"details: 📖 Theory - Airfoil database lookup\nThe drag databaseThe airfoil drag database (e.g., C.air) store the 2D airfoil section drag (c_dp c_df) and pitching moment (c_m) as a function of:airfoil thickness/chord ratio, tau = fractc,\nsection lift coefficient, c_l, and\nMach number, M.The airtable function builds an airfoil structure that stores the database tau c_l M as well as the derivatives at the knots (as described below) to use for cubic interpolation.Cubic interpolationBelow is a terse description of the cubic interpolation as relevant to the drag interpolation. There are several online resources available for a more in-depth description of the topic.The cubic polynomials are represented as:newcommandimi-1\nnewcommandipi+1\nnewcommandp11 + 1\nnewcommandm11 - 1\nq_i(t) = (1-t)y_mi + ty_i + t(1-t)left((1-t)a_i - tb_iright)where,newcommandimi-1\nnewcommandipi+1\nnewcommandp11 + 1\nnewcommandm11 - 1\nbeginaligned\n\nt = fracx- x_imx_i - x_im\na_i = k_mi(x_i - x_mi) - (y_i - y_mi)\nb_i = k_i(x_i - x_mi)  - (y_i - y_mi)\n\nendalignedand k_i = left fracmathrmd ymathrmd x right_iis the slope at the i^th point in the interpolation array.These slopes (in each direction) are calculated and stored in the airfoil.A structure by the airtable function.For brevity only an example of how these are stored is depicted below, the interested user may directly read airtable to see the matrix structure where the knots are stored. Here is an example of taking a slice of the 3-D array storing c_d_p at a fixed c_l = c_l_i (the data is really a 4-D array with each of the drag components, c_dp c_df, and c_m being stored along the 4^mathrmth dimension),newcommandpder3fracpartial^1 2partial 3^1 \nbeginaligned\nmathbfAc_l_i   = \nbeginbmatrix\n\tleft c_d_pright_tau_1 M_1 left c_d_pright_    tau_1 M_2  cdots  left c_d_pright_tau_1     M_N \n\tleft c_d_pright_tau_1 M_2 cdots cdots      left c_d_pright_tau_2 M_N\n\tvdots  ddots   vdots \n\tleft c_d_pright_tau_N M_1 cdots cdots      left c_d_pright_tau_N M_N\n\t\n \nendbmatrix \n\n\npdermathbfAc_l_i   M  =\nbeginbmatrix\n\tleft pderc_d_pM right_11 cdots  left     pderc_d_pM right_1N \n\tvdots  ddots   vdots \n\tleft pderc_d_pM right_N1 cdots  left     pderc_d_pM right_NN \n \nendbmatrix\t\n\nendalignedSimilarly, the slopes in the tau direction are stored in A_τ and the cross-derivatives are stored in A_M_τ and so on. Evaluating the drag calculationsThe stored slopes are used to evaluate the drag components by first locating the interval to use based on the c_l tau M values in the call to airfun, and then performing the interpolation in each dimension sequentially. For any values outside the provided database, a quadratic drag penalty is added.  ","category":"page"},{"location":"aero/geometry/#geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"aero/geometry/#Wing-or-Tail-Planform","page":"Geometry","title":"Wing or Tail Planform","text":"","category":"section"},{"location":"aero/geometry/","page":"Geometry","title":"Geometry","text":"The wing geometry is comprised of a wingbox with fuselage carry-over, an inner section with prescribed taper ratio up to a wing break or \"snag\", and an outer section with a separately prescribed taper ratio. The geometry is defined relative to a central axis defined by the overall sweep angle, Lambda.","category":"page"},{"location":"aero/geometry/","page":"Geometry","title":"Geometry","text":"The surface geometry relations derived below correspond to the wing. Most of these apply equally to the tails if the wing parameters are simply replaced with the tail counterparts.","category":"page"},{"location":"aero/geometry/","page":"Geometry","title":"Geometry","text":"(Image: Piecewise-linear wing or tail surface planform, with break at $\\eta_s$ .)","category":"page"},{"location":"aero/geometry/","page":"Geometry","title":"Geometry","text":"using Markdown\nMarkdown.parse_file(joinpath(\"../..\", \"src/aero\",\"theory_geometry.md\"))","category":"page"},{"location":"aero/geometry/#TASOPT.aerodynamics.set_wing_geometry!-NTuple{4, Any}","page":"Geometry","title":"TASOPT.aerodynamics.set_wing_geometry!","text":"set_wing_geometry!(W, CL, qinf, wing)\n\nSizes wing area, span, root chord from q, CL, W, AR at given point (taken as start-of-cruise in size_aircraft!).\n\ndetails: 🔃 Inputs and Outputs\nInputs:W::Float64: Aircraft weight.\nCL::Float64: Lift coefficient.\nqinf::Float64: Freestream dynamic head.\nwing::TASOPT.structures.Wing: Wing structure \n\nSee Sections 2.5 and 3.4.1 of the TASOPT Technical Desc.\n\n\n\n\n\n","category":"method"},{"location":"cryo_tank/cryotank/#CryoTank","page":"Homogeneous model","title":"Homogeneous model","text":"","category":"section"},{"location":"cryo_tank/cryotank/","page":"Homogeneous model","title":"Homogeneous model","text":"In a tank containing a boiling liquid, such as a cryogenic liquid that has reached its saturation point, two fluid states exist: a liquid phase and a gas phase (or vapor). In a real tank, there would be some level of stratification leading to temperature differences between the two phases, which exist at the same pressure. This section describes the models used to simulate the evolution in time of the conditions inside a cryogenic tank. It is based on the homogeneous tank model[1][2][3], which treats the fluid inside the tank as a well-mixed saturated mixture at homogeneous temperature and pressure.","category":"page"},{"location":"cryo_tank/cryotank/#Theory","page":"Homogeneous model","title":"Theory","text":"","category":"section"},{"location":"cryo_tank/cryotank/","page":"Homogeneous model","title":"Homogeneous model","text":"details: 📖 Theory - Homogeneous model\nOrdinary-differential equation systemLet us consider a tank that contains a mixture of saturated liquid and gas phases at a saturation pressure p. The tank has a heat rate dotQ into it and a work rate dotW is performed in the tank. The tank also has a mass flow rate dotm out of the tank of a fluid with quality x_out. In general, the tank may also be vented with a venting mass flow rate dotm_vent of fluid with a quality x_vent. From conservation of energy, it can be shown that the derivative in time of the saturation pressure in this homogeneous case is[2]    left( fracdpdtright)_h = fracphiVleftdotQ + dotW - dotm h_vap (x_out + rho ^*) - dotm_vent h_vap (x_vent + rho ^*)rightwhere phi is the energy derivative of the fluid mixture (to be defined later), V is the tank volume, h_vap is the enthalpy of vaporization of the liquid, and rho ^*=fracrho_grho_l-rho_g is the density ratio (l refers to the properties of the liquid phase and g to those of the gaseous phase). The enthalpy of vaporization is simply the enthalpy difference between the gaseous and liquid phases.Experiments suggest that the pressure derivative in a real tank can be significantly greater than that of the homogeneous model due to stratification. Authors have accounted for this with a scaling factor alpha, such that[2][3]    fracdpdt = alpha left( fracdpdtright)_h If the liquid volume fraction (fill fraction) if the tank is beta, the density of the mixture can be expressed as     rho = beta rho_l + (1-beta) rho_gDifferentiating this in time,    fracdrhodt = fracd betadt (rho_l - rho_g) + beta fracdrho_ldpfracdpdt + (1-beta) fracdrho_gdp fracdpdtwhere the liquid- and gas-phase densities are functions of pressure only since the fluid is in saturated conditions. The derivative in time of density in the tank is equal to     fracdrhodt = -fracdotm + dotm_ventVSolving for the rate of change of the fill volume in the tank,    fracdbetadt = frac1rho_l - rho_gleftfracdrhodt - fracdpdt left(beta fracdrho_ldp+(1-beta) fracdrho_gdpright)rightThe evolution in time of properties inside the tank can be modeled by solving the system of ordinary differential equations (ODEs) given by    fracddt mathbfx = mathbff(t mathbfx mathbfu mathbfp)where mathbfx = p beta^T, mathbfu = dotQ(t) dotW(t) dotm(t)^T and mathbfp = V alpha p_vent^T, where p_vent is the pressure at which the tank is vented. These ODEs can be integrated in time from knowledge of the initial conditions, namely the initial pressure and initial tank fill fraction.Energy derivativeThe energy derivative phi is given by[1]    phi = frac1rho left(fracpartial upartial pright)_rhowhere u represents the internal energy of the mixture. The partial derivative left(fracpartial upartial pright)_rho is taken at constant mixture density. The internal energy of the mixture is given by    u = x u_g + (1-x) u_lwhere x represents the quality of the mixture (the mass fraction of the gaseous phase). Differentiating this in pressure at constant mixture density,    left(fracpartial upartial pright)_rho = x fracdu_gdp + (1-x)fracdu_ldp + (u_g - u_l) left(fracpartial xpartial pright)_rhoThe density of the mixture can be related to the quality by[1]   frac1rho = fracxrho_g + frac1-xrho_lDifferentiating in pressure at constant mixture density yields   left(fracpartial xpartial pright)_rho = left(frac11rho_g - 1rho_lright)left(fracxrho_g^2fracdrho_gdp + frac1-xrho_l^2fracdrho_ldpright)which completes the expression for the energy derivative.VentingVenting may be needed when the tank pressure has reached some maximum pressure. The purpose of mass venting from the tank is to prevent the tank pressure from increasing any further. To find the required venting mass flow rate, the equation for fracdpdt can be set to zero whenever the venting pressure p_vent is reached or exceeded, yielding,   dotm_vent = begincases \n   0  pp_vent \n   fracdotQ + dotWh_vap (x_vent + rho^*) - fracx_out + rho^*x_vent + rho ^*dotm pgeq p_vent\n   endcases","category":"page"},{"location":"cryo_tank/cryotank/#Functions","page":"Homogeneous model","title":"Functions","text":"","category":"section"},{"location":"cryo_tank/cryotank/#Thermodynamic-properties","page":"Homogeneous model","title":"Thermodynamic properties","text":"","category":"section"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.gas_properties","page":"Homogeneous model","title":"TASOPT.CryoTank.gas_properties","text":"gas_properties(species::String, p::Float64)\n\nThis function returns the thermodynamic properties of a saturated vapor.\n\ndetails: 🔃 Inputs and Outputs\nInputs:species::String: Species name\np::Float64: pressure (Pa)Outputs:Tsat::Float64: temperature (K)\nρ::Float64: density (kg/m^3)\nρ_p::Float64: derivative of density with pressure (kg/m^3/Pa)\nh::Float64: specific enthalpy (J/kg)\nu::Float64: specific internal energy (J/kg)\nu_p::Float64: derivative of internal energy with pressure (J/kg/Pa)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.liquid_properties","page":"Homogeneous model","title":"TASOPT.CryoTank.liquid_properties","text":"liquid_properties(species::String, p::Float64)\n\nThis function returns the thermodynamic properties of a saturated liquid.\n\ndetails: 🔃 Inputs and Outputs\nInputs:species::String: Species name\np::Float64: pressure (Pa)Outputs:Tsat::Float64: temperature (K)\nρ::Float64: density (kg/m^3)\nρ_p::Float64: derivative of density with pressure (kg/m^3/Pa)\nh::Float64: specific enthalpy (J/kg)\nu::Float64: specific internal energy (J/kg)\nu_p::Float64: derivative of internal energy with pressure (J/kg/Pa)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#Saturated-mixtures","page":"Homogeneous model","title":"Saturated mixtures","text":"","category":"section"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.SaturatedGas","page":"Homogeneous model","title":"TASOPT.CryoTank.SaturatedGas","text":"Structure with thermodynamic parameters for the vapor portion of a saturated mixture.\n\n\n\n\n\n","category":"type"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.SaturatedLiquid","page":"Homogeneous model","title":"TASOPT.CryoTank.SaturatedLiquid","text":"Structure with thermodynamic parameters for the liquid portion of a saturated mixture.\n\n\n\n\n\n","category":"type"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.SaturatedMixture","page":"Homogeneous model","title":"TASOPT.CryoTank.SaturatedMixture","text":"Structure with thermodynamic properties of a saturated mixture.\n\n\n\n\n\n","category":"type"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.update_pβ!","page":"Homogeneous model","title":"TASOPT.CryoTank.update_pβ!","text":"update_pβ!(mixture, p, β)\n\nThis function updates a saturated mixture when there is a change in pressure or liquid fill volume ratio.\n\ndetails: 🔃 Inputs and Outputs\nInputs:mixture::SaturatedMixture: saturated mixture\np::Float64: pressure (Pa)\nβ::Float64: liquid fill ratioOutputs: No direct outputs. The mixture input is modified.\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#Pressure-evolution","page":"Homogeneous model","title":"Pressure evolution","text":"","category":"section"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.dpdt","page":"Homogeneous model","title":"TASOPT.CryoTank.dpdt","text":"dpdt(mixture, Q, W, mdot, xout, V)\n\nThis function returns the time derivatives for the pressure in a cryogenic tank.\n\ndetails: 🔃 Inputs and Outputs\nInputs:mixture::SaturatedMixture: liquid/vapor mixture in tank\nQ::Float64: heat rate (W)\nW::Float64: work rate (W)\nmdot::Float64: imposed mass flow rate out of the tank, e.g., to burn in combustor (kg/s)\nxout::Float64: quality of mass flow rate out of tank\nmdot_vent::Float64: required venting mass flow rate to keep tank pressure constant (kg/s)\nxvent::Float64: quality of mixture that is vented\nV::Float64: tank volume (m^3) \nα::Float64: fudge factor to account for effect of stratificationOutputs:dp_dt::Float64: pressure derivative in time (Pa/s)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.dβdt","page":"Homogeneous model","title":"TASOPT.CryoTank.dβdt","text":"dβdt(mixture, dp_dt, mdot, V)\n\nThis function returns the time derivatives for the liquid fill volume fraction in a cryogenic tank.\n\ndetails: 🔃 Inputs and Outputs\nInputs:mixture::SaturatedMixture: liquid/vapor mixture in tank\ndp_dt::Float64: pressure derivative (Pa/s)\nmdot_tot::Float64: total mass flow rate out of the tank, including venting (kg/s)\nV::Float64: tank volume (m^3) Outputs:dβ_dt::Float64: fill fraction derivative in time (1/s)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.venting_mass_flow","page":"Homogeneous model","title":"TASOPT.CryoTank.venting_mass_flow","text":"venting_mass_flow(mixture, Q, W, mdot, xout, xvent)\n\nThis function returns the mass flow rate that needs to be vented to keep the tank pressure constant.\n\ndetails: 🔃 Inputs and Outputs\nInputs:mixture::SaturatedMixture: liquid/vapor mixture in tank\nQ::Float64: heat rate (W)\nW::Float64: work rate (W)\nmdot::Float64: mass flow rate out of the tank (kg/s)\nxout::Float64: quality of mass flow rate out of tank\nxvent::Float64: quality of the mixture that is ventedOutputs:mdot_vent::Float64: venting mass flow rate (kg/s)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.mdot_boiloff","page":"Homogeneous model","title":"TASOPT.CryoTank.mdot_boiloff","text":"mdot_boiloff(β, dβ_dt, dp_dt, ρl, ρl_p, mdot, V)\n\nThis function returns the rate of mass boiloff in the tank.\n\ndetails: 🔃 Inputs and Outputs\nInputs:mixture::SaturatedMixture: liquid/vapor mixture in tank\ndβ_dt::Float64: fill fraction derivative in time (1/s)\ndp_dt::Float64: pressure derivative (Pa/s)\nmdot_liq::Float64: liquid-phase mass flow rate out of the tank (kg/s)\nV::Float64: tank volume (m^3) Outputs:mdot_boiloff::Float64: rate of liquid mass boiloff (kg/s)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.TankDerivatives","page":"Homogeneous model","title":"TASOPT.CryoTank.TankDerivatives","text":"TankDerivatives(t, y, u, params)\n\nThis function returns the time derivatives for pressure and liquid volume fill fraction in a cryogenic tank.\n\ndetails: 🔃 Inputs and Outputs\nInputs:t::Float64: time (s)\ny::Vector{Float64}: vector with the states; y[1] is pressure, y[2] is fill fraction, y[3] is tank mass, y[4] is total liquid mass extracted, y[5] is the total mass that is vented and y[6] is the total mass that is boiled off.u::Struct: structure with inputs; functions for heat rate, work rate and mass flow rate \nparams::Struct: structure with parameters; including initial tank mixture, tank max pressure and tank volume Outputs:dydt::Vector{Float64}: vector with the state derivatives in time\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#TASOPT-interfacing","page":"Homogeneous model","title":"TASOPT interfacing","text":"","category":"section"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.find_mdot_time","page":"Homogeneous model","title":"TASOPT.CryoTank.find_mdot_time","text":"find_mdot_time(t, parg, para, pare)\n\nThis function outputs the fuel mass flow rate to the engines as a function of time for a TASOPT aircraft  model with fuselage fuel tanks.\n\ndetails: 🔃 Inputs and Outputs\nInputs:t::Float64: time in mission (s)\nparg::Vector{Float64}: vector with aircraft geometric parameters\npara::Array{Float64}: array with aircraft aerodynamic parameters\npare::Array{Float64}: array with aircraft engine parametersOutputs:t::mdot: fuel mass flow rate out of the tank (kg/s)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.calc_Q_points","page":"Homogeneous model","title":"TASOPT.CryoTank.calc_Q_points","text":"calc_Q_points(fuse, fuse_tank, ifuel, parg, para)\n\nThis function calculates the heat transfer rate into the tank at the design mission points.\n\ndetails: 🔃 Inputs and Outputs\nInputs:fuse_tank::FuselageTank: struct with aircraft cryogenic tank parameters\nifuel::Integer: fuel type specification for gas calcs from ac.options\nparg::Vector{Float64}: vector with aircraft geometric parameters\npare::Array{Float64}: array with aircraft engine parametersOutputs:Qs::Vector{Float64}: vector with heat transfer rate at mission points (W)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.find_Q_time_interp","page":"Homogeneous model","title":"TASOPT.CryoTank.find_Q_time_interp","text":"find_Q_time_interp(t, para, Qs)\n\nThis function estimates the heat transfer rate into the tank in a TASOPT model for a given time. It uses precomputed rates at each mission point for speed.\n\ndetails: 🔃 Inputs and Outputs\nInputs:t::Float64: time in mission (s)\npara::Array{Float64}: array with aircraft aerodynamic parameters\nQs::Vector{Float64}: vector with heat transfer rate at mission points (W)Outputs:Q::Float64: heat transfer rate (W)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/#TASOPT.CryoTank.analyze_TASOPT_tank","page":"Homogeneous model","title":"TASOPT.CryoTank.analyze_TASOPT_tank","text":"analyze_TASOPT_tank(ac_orig, t_hold_orig::Float64 = 0.0, t_hold_dest::Float64 = 0.0, N::Int64 = 50)\n\nThis function analyses the evolution in time of a cryogenic tank inside a TASOPT aircraft model.\n\ndetails: 🔃 Inputs and Outputs\nInputs:ac_orig::aicraft: TASOPT aircraft model\nt_hold_orig::Float64: hold at origin (s)\nt_hold_dest::Float64: hold at destination (s)\nim::Int64: mission indexOutputs:ts::Vector{Float64}: vector with times (s)\nps::Vector{Float64}: vector with pressure evolution in time (Pa)\nβs::Vector{Float64}: vector with tank fill fraction evolution in time\nMs::Vector{Float64}: vector with tank fuel mass evolution in time (kg)\nMburns::Vector{Float64}: vector with cumulative mass burnt in engine (kg)\nMboils::Vector{Float64}: vector with cumulative mass that has boiled off (kg)\nmdot_boils::Vector{Float64}: vector with evolution of boiloff mass flow rate in time (kg/s)\nMvents::Vector{Float64}: vector with cumulative mass that has been vented (kg)\nmdots::Vector{Float64}: vector with fuel mass flow rate to engines (kg/s)\nQs::Vector{Float64}: vector with heat rate to tank (W)\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/cryotank/","page":"Homogeneous model","title":"Homogeneous model","text":"[1]: Lin, Chin S., Neil T. Van Dresar, and Mohammad M. Hasan. \"Pressure control analysis of cryogenic storage systems.\" Journal of propulsion and power 20.3 (2004): 480-485.","category":"page"},{"location":"cryo_tank/cryotank/","page":"Homogeneous model","title":"Homogeneous model","text":"[2]: Verstraete, Dries, et al. \"Hydrogen fuel tanks for subsonic transport aircraft.\" International journal of hydrogen energy 35.20 (2010): 11085-11098.","category":"page"},{"location":"cryo_tank/cryotank/","page":"Homogeneous model","title":"Homogeneous model","text":"[3]: Winnefeld, Christopher, et al. \"Modelling and designing cryogenic hydrogen tanks for future aircraft applications.\" Energies 11.1 (2018): 105.","category":"page"},{"location":"cryo_tank/fueltanks/#fueltanks","page":"Thermal and structural models","title":"Thermal and structural models","text":"","category":"section"},{"location":"cryo_tank/fueltanks/","page":"Thermal and structural models","title":"Thermal and structural models","text":"Liquid long-chain hydrocarbon fuel is assumed to be stored in the interior of the wings and no additional tanks are needed. The weight of the fuel is accounted for while sizing the wing structure. See structures.wing_weights!.","category":"page"},{"location":"cryo_tank/fueltanks/","page":"Thermal and structural models","title":"Thermal and structural models","text":"However, alternate fuels such as cryogenic liquid hydrogen require additional storage tanks that are insulated pressure vessels. To study novel aircraft designs that may leverage such fuels, the following cryogenic tank models were integrated, along with heat exchanger and fuel cell models.","category":"page"},{"location":"cryo_tank/fueltanks/#Theory","page":"Thermal and structural models","title":"Theory","text":"","category":"section"},{"location":"cryo_tank/fueltanks/","page":"Thermal and structural models","title":"Thermal and structural models","text":"details: 📖 Theory - Thermal and structural sizing of cryogenic fuel tanks\nThermal designThe fuel tanks in TASOPT are assumed to consist of cylinders with two hemiellipsoidal caps. In general, the cylinders can have a double-bubble shape like the fuselage. To reduce fuel loss during flight as a result of boiling due to heat leakage into the tank (boiloff), the tank requires thermal insulation. Two different insulation architectures are currently supported in TASOPT.jl: an inner vessel covered in foam-based insulation and a double-walled tank with a vacuum layer between the layers. The thermal design and analysis method is similar for both insulation architectures. The tank walls are assumed to be made of an isotropic material with high thermal conductivity. The insulation layer, which does not carry structural loads and has a high thermal resistance. The insulation layer itself may consist of additional sublayers of different materials.(Image: SWfig)As the insulation layer consists of two different geometries across which heat can be transferred (the cylinder and the hemiellipsoids), two slightly different models for thermal resistance must be used. We will first consider heat transfer across a material layer; the vacuum case will be considered later. In the case of heat transfer across a layer between two concentric cylinders, it can be shown from Fourier's law that the thermal resistance, R_cyl, is given by     R_cyl = fraclnleft( fracR_fR_0right) p_r l_cyl kwhere R_0 is the layer's inner radius, R_f = R_0 + t is the outer radius (with t being the layer thickness), l_cyl is the cylinder length, and k is the thermal conductivity of the layer. The parameter p_r is the ratio of the cross-section perimeter to the double-bubble radius; for a circular section, p_r=2pi. In many real materials including insulation foams, the thermal conductivity is a function of temperature. In TASOPT.jl, the mean of the conductivities across the layer is used; it can be shown analytically that this is exact if the conductivity is linear in temperature.For the hemiellipsoids, an approximate solution can be used, given by     R_ell = fract k left(S_f + S_0 - fracS_heR^2 t^2right)where S_f is the surface area of the hemiellipsoid at the final radius, S_0 is the surface area at the initial radius, and fracS_heR^2 is the ratio of hemiellipsoid surface area to radius squared; for example, this ratio is fracS_heR^2=2pi for a hemisphere. The equation above makes use of the fact that there are two hemiellipsoids at both ends of the tank and represents their total resistance. By combining these resistances, the total resistance of an insulation layer can be found using parallel resistance addition,    R_l = fracR_cylR_ell R_cyl + R_ellThe total resistance across the insulation is the serial addition of the resistances across each layer,    R_MLI = sum_i R_l^iIn addition to the insulation resistance, the convective heat transfers from fuel to tank wall and from exterior wall to freestream have to be taken into account. The heat transfer to the freestream can be modeled as having two components: radiation and convection. The heat transfer coefficient from forced convection from the external wall to the freestream can be modeled using the Chilton-Colburn analogy,    h_air = fracc_f2 Pr^23  ρ u c_pwhere c_f is the skin-friction coefficient, Pr is the Prandtl number (Prapprox 071 for air), ρ is the freestream air density, u is the freestream velocity, and c_p is the specific heat of the freestream air at constant pressure. The skin-friction coefficient can be modeled using a flat-plate solution,[1]    c_f = frac002296Re_x^0139where mathrmRe_x is the Reynolds number at the location fo the fuel tank in the fuselage. To account for the effect of compressibility, the gas properties (density and viscosity) can be calculated at a reference temperature, T^star, that can be estimated using [1]    T^star = T_aleft05left(1 + fracT_wT_aright)+016 r left(fracgamma-12right)M^2rightwhere M is the freestream Mach number, T_a is the freestream temperature and T_w is the external wall temperature. The term r represents a recovery factor and r = Pr^13 for turbulent air. Due to the high flow velocity, the temperature that the wall reaches in the adiabatic case (T_aw) is greater than the static air temperature. The adiabatic wall temperature is given by     T_aw = T_a left(1 + r fracgamma -12 M^2right)where gamma is the ratio of specific heats for air.The equivalent resistance due to the freestream is    R_air = frac1 2pi h_air l_cyl R_fusewhere l_cyl is the length of the cylindrical portion of the tank and R_fuse is the fuselage radius. Inside the tank, there is a heat transfer from the bulk of the liquid fluid to the tank via natural convection. The Nusselt number for this heat transfer process can be modeled as [2]    mathrmNu_l = 00605 mathrmRa_l^13where mathrmRa_l is the tank-length based Rayleigh number and is given by    mathrmRa_l = fracg beta (T_w-T_f) l^3 Prnu^2where g is the gravitational acceleration, beta is the fuel's coefficient of thermal expansion, T_w is the temperature at the tank wall, l is the tank length, Pr is the Prandlt number of the liquid fuel, nu is the kinematic viscosity of the fuel, and T_f is the temperaure of the fuel. The thermal resistance due to natural convection is then    R_liq = fraclmathrmNu_l k S_intwhere k is the thermal conductivity of the liquid fuel and S_int is the internal surface area of the tank. The combined thermal resistance is R_eq = R_liq + R_MLI + R_air, such that the total heat transfer rate is dotQ = fracT_aw - T_fR_eq. Once the heat transfer rate is known, the boiloff rate is simply dotm_boil=fracdotQh_v, where h_v is the heat of vaporization of the fuel. A diagram illustrating the different thermal resistances is shown below.(Image: PEMfig)Vacuum insulationThe case when the insulation layer consists of a vacuum has to be modeled separately as a vacuum has zero thermal conductivity. In a vacuum, heat transfer is through a combination of radiation and convection due to residual gas if the vacuum is imperfect. The heat transfer rate due to radiation can be modeled as[3]    dotQ_rad = F_e S_i sigma (T_o^4 - T_i^4)where S is the surface area, T is the temperature, and the subscript i refers to the inner surface and o to the outer surface. The coefficient F_e is an emissivity factor that acts as an ``average'' of the emissivities of the two surfaces and can be modeled as[3]    F_e = frac1varepsilon_i + fracS_iS_oleft(frac1varepsilon_o-1right)The thermal resistance due to radiation is simply R_rad = fracT_o - T_idotQ_rad. In addition, the thermal resistance due to the residual gas can be shown to be given by[3]    R_conv = frac1G p_res S_iwhere p_res is the pressure of the residual air and G is a factor that accounts for the thermodynamic properties of the residual gas,    G = F_a fracgamma + 1gamma -1sqrtfracR8pi Twhere gamma is the gas' ratio of specific heats, R is the mass-specific gas constant and T is the temperature of the gauge used to measure the residual pressure (in the code, this is assumed to be the outer-layer temperature). The accommodation coefficient factor, F_a is given by    F_a = frac1a_i + fracS_iS_oleft(frac1a_o-1right)where a denotes the accommodation coefficient, which is a function of temperature and the residual gas composition. Table 7.14 in Barron[3] provides a set of accommodation coefficients.The total thermal resistance of the vacuum layer is R_l = fracR_rad R_convR_rad + R_conv and this can then be used to calculate the equivalent thermal resistance as described above.Notes on implementationThe thermal resistance for any insulation layer is, in general, a function of the temperature at the edges of the layer. Because of this, determining the heat transfer and the temperature distribution requires solving a non-linear problem. The current implementation of TASOPT uses the non-linear solver in NLsolve.jl to find the temperature at the edge of each insulation layer. The nonlinear solver in NLsolve is used to find these temperatures and the overall heat transfer rate.In the current version of TASOPT, the user can specify whether to use a given thickness and material distribution for the MLI or to size the MLI to achieve a desired boiloff rate. In the latter case, the boiloff rate is an input and the thicknesses of some desired layers of the MLI insulation are changed until the desired boiloff rate is met. The non-linear solver in NLsolve.jl is used to find the change in layer thickness needed to meet this requirement. Structural designInner vesselThe cryogenic fuel is contained within an inner vessel, which is sized for a given pressure difference between the high-pressure interior and the exterior. As the boiling temperature of a liquid is a function of temperature, it is preferable to keep the interior pressure constant. The outer radius of the inner vessel is    R_to = R_fuse - d_fclear - t_MLIwhere d_fclear is the fuselage clearance distance and t_MLI is the total thickness of the MLI. The skin thickness of the cylindrical portion of the tank wall is sized using [3]    t_scyl = frac2 Delta p_des R_to2 sigma_a f_weld + 08 Delta p_deswhere sigma_a is the maximum allowable stress for the wall material, f_weld1 is a factor that accounts for structural weakening due to welding, and Delta p_des is the design tank pressure difference. In the code, the tank is sized for a pressure difference equal to the internal tank pressure, Delta p_des = p_tank. The maximum allowable stress is taken to be one fourth of the ultimate tensile strength of the wall material[3]. The wall thickness of the hemiellipsoidal caps is given by [3]    t_scap = frac2 Delta p_des R_to K 2 sigma_a f_weld + 2 Delta p_des (K- 01)where K=frac16(AR^2+2) is a factor that accounts for the ellipsoidal aspect ratio (AR). Once the wall thicknesses have been determined, the internal tank radius is given by R_ti=R_to-t_scyl. The volume required for the fuel is     V_fuel = fracm_fuelrho_mixwhere rho_mix = f_ullrho_g + (1-f_ull)rho_l is the density of the saturated mixture inside the tank, rho_g and rho_l are the densities of the fuel in saturated gas and liquid phases, and f_ull0 is a factor to account for the fact that the tank must contain some gas volume for ullage. The internal volume of a hemiellipsoidal cap is given by     V_cap =  fracA_csR^2frac2 R_ti^33ARwhere fracA_csR^2 is the ratio of the cross-sectional area to the double bubble radius squared; for a circular section, fracA_csR^2=pi.Therefore, the internal volume of the cylindrical portion of the tank is V_cyl=V_fuel-2V_cap, and the length of the cylindrical portion can then be found to be    l_cyl =  fracV_cylfracA_csR^2 R_ti^2Once this length is known, the masses of the tank and insulation layers can be found from their respective volumes and densities. To support the tank, stiffener rings that go around the tank circumference are needed. It is assumed that the inner vessel contains two of these stiffeners, which are sized following the process below.Outer vesselIf the insulation layer contains a vacuum layer, an additional tank wall is needed to contain the vacuum. Unlike the inner vessel, this outer wall does not fail due to excessive stress, instead, it fails by buckling or collapse[3]. To prevent buckling, stiffener rings can be used to reduce the effective cylindrical length that can collapse. The unsupported cylinder length is    L =  fracl_cylN_stiff -1where N_stiff is the total number of stiffener rings and l_cyl is the length of the cylindrical portion of the outer vessel (note that for geometric similarity, this is larger than that of the inner vessel). The collapsing pressure[3] is taken to be four times the atmospheric pressure, p_c = 4p_a. The thickness for the cylindrical portion of the vessel, t can then be determined by solving[3]    p_c = frac242 E (tD_o)^52 (1 - nu^2)^34  (LD_o - 045sqrttD_o) where E is the Young's modulus of the wall material, nu is its Poisson's ratio, and D_o is the vessel outer diameter. The wall thickness for the hemiellipsoidal heads can be determined using[3]    t = K_1 D_o sqrtfracp_c sqrt3 (1 - nu^2)05 Ewhere K_1 is a geometric factor that depends on the ellipsoid aspect ratio; some factors can be found in Table 7.6 in Barron[3].Once the wall thicknesses have been determined, the weight of the outer vessel components can be found from their volumes and densities. In addition to the walls, the outer vessel requires stiffener rings to prevent collapse. The vessel is assumed to be supported by two main stiffener rings, N_stiffm=2, that carry the weight and prevent collapse, and a number N_stiffa of additional rings that only prevent collapse, such that N_stiff=N_stiffm+N_stiffa. The general layout in a double-walled tank is shown in the figure below.(Image: DWfig)Stiffening ringsThe stiffening rings act as contact points for the tank supports. In the case of the outer vessel in a double-walled tank, they also prevent collapse of the skin. The main stiffening rings carry the weight of the tank, whereas the outer-vessel additional rings simply serve to prevent skin collapse. In general, the required second moment of area for a ring is given by     I = I_load + I_collapsewhere I_load is the second moment of area needed to withstand the weight loads (only applicable to main rings), and I_collapse is needed to prevent skin collapse (only for outer vessel rings). The second moment of area needed to withstand the loads is    I_load = y_max fracM_maxsigma_awhere y_max is the maximum distance from the neutral axis in the beam cross-section, sigma_a is the maximum allowable beam stress, and M_max is the maximum bending moment in the ring circumference, which can be found using Eqs. (7.4)–(7.5) in Barron[3] for the inner vessel and Eqs. (7.13)–(7.15) for the outer vessel. The second moment of area to withstand collapse is     I_collapse = fracp_c D_o^3 L24 EIn the code, the beams are assumed to be I-beams. The flange thickness (t_f) and width (W), as well as the web thickness (t_w), are taken to be those of a standard 100 x 100 beam. The height of the beam is calculated to match the required second moment of area. For this purpose, the second moment of area of the web is ignored, such that the beam has a second moment of area    I  fracW H^2 t_f2 + fract_f^3 W6where H is the distance between the two flange centroids, such that the total beam height is H + t_f. The second moment of area of the web is significant, so ignoring it provides a conservative approximation. This equation is solved for H by equating the approximate beam second moment of area to the required one.The weight of a stiffening ring can then be found as     W_stiff = 2pi R g 2 W t_f + (H - t_f) t_w where R is the vessel radius and g is the gravitational acceleration.Notes on implementationIn the case of the outer vessel (when there is a vacuum layer), there is a tradeoff between stiffener mass and skin thickness, as adding more stiffeners results in a thinner skin. The optimal number of stiffeners that minizimizes the overall outer vessel mass is found using NLopt.jl with a Nelder-Mead algorithm.  ","category":"page"},{"location":"cryo_tank/fueltanks/#TASOPT.CryoTank.tanksize!","page":"Thermal and structural models","title":"TASOPT.CryoTank.tanksize!","text":"    tanksize!(ac, imission)\n\ntanksize sizes a cryogenic fuel tank for a cryogenic-fuel aircraft\n\ndetails: 🔃 Inputs and Outputs\n**Inputs:**\n- `ac::aircraft`: TASOPT aircraft object.\n\n**Outputs:**\nNo direct outputs. Aircraft object gets modified with tank parameters.\n\nSee here.\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/fueltanks/#TASOPT.CryoTank.res_MLI_thick","page":"Thermal and structural models","title":"TASOPT.CryoTank.res_MLI_thick","text":"    res_MLI_thick(x::Vector{Float64}, fuse::Fuselage, fuse_tank::fuselage_tank, z::Float64, Mair::Float64, xftank::Float64, ifuel::Int64)\n\nThis function evaluates the residual vector for a given state containing change in wall thickness, heat transfer rate and  insulation interface temperatures.\n\ndetails: 🔃 Inputs and Outputs\n**Inputs:**\n- `x::Float64`: vector with states\n- `fuse::Fuselage`: fuselage object.\n- `fuse_tank::fuselage_tank`: fuselage tank object.\n- `z::Float64`: flight altitude (m)\n- `Mair::Float64`: external air Mach number\n- `xftank::Float64`: longitudinal coordinate of fuel tank centroid from nose (m)\n- `ifuel::Int64`: fuel index.\n\n**Outputs:**\n- `res::Vector{Float64}`: residuals vector.\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/fueltanks/#TASOPT.CryoTank.size_inner_tank","page":"Thermal and structural models","title":"TASOPT.CryoTank.size_inner_tank","text":"  size_inner_tank(fuse::Fuselage, fuse_tank::fuselage_tank, t_cond::Vector{Float64})\n\nsize_inner_tank calculates the weight of the cryogenic fuel tank for a LH-fueled aircraft.\n\ndetails: 🔃 Inputs and Outputs\nInputs:fuse::Fuselage: fuselage object.\nfuse_tank::fuselage_tank: fuselage tank object.\nt_cond::Float64: Vector with tank isulation layer thickness. Provided separately from fuse_tank as it changes during non-linear solve process.Outputs:Wtank_total::Float64: Total tank weight including fuel (N).\nl_cyl::Float64: Length of the cylindrical portion (m).\ntskin::Float64: Thickness of the tank's skin (m).\nRtank_outer::Float64: Outer radius of the tank (m).\nVfuel::Float64: Volume of fuel (m^3).\nWtank::Float64: Weight of the empty tank (N).\nWfuel_tot::Float64: Total weight of fuel (N).\nWinsul_sum::Float64: Sum of insulation weight (N).\nt_head::Float64: Thickness of the tank's head (m).\nWhead::Float64: Weight of the tank's head (N).\nWcyl::Float64: Weight of the tank's cylinder (N).\nWstiff::Float64: Total stiffener weight (N)\nWinsul::Float64: Weight of insulation (N).\nShead_insul::Float64: Insulated surface area of the head (m^2).\nl_tank::Float64: Total length of the tank (m).\n\nNOTE: Al alloy 2219 has been recommended as tank material (from H2 tank paper in OneNote)\n\nSee here.\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/fueltanks/#TASOPT.CryoTank.size_outer_tank","page":"Thermal and structural models","title":"TASOPT.CryoTank.size_outer_tank","text":"size_outer_tank(fuse::Fuselage, fuse_tank::fuselage_tank, Winnertank::Float64, l_cyl::Float64, Ninterm::Float64)\n\nThis function sizes the outer vessel and calculates the weights of its components.\n\ndetails: 🔃 Inputs and Outputs\nInputs:fuse::Fuselage: fuselage object.\nfuse_tank::fuselage_tank: fuselage tank object.\nWinnertank::Float64: weight of inner vessel and contents (N).\nl_cyl::Float64: length of cylindrical portion of outer vessel (m).\nNinterm::Float64: optimum number of intermediate stiffener rings.Outputs:Wtank::Float64: total weight of outer vessel (N).\nWcyl::Float64: weight of cylindrical portion of outer vessel (N).\nWhead::Float64: weight of one elliptical outer-tank head (N).\nWstiff::Float64: total weight of stiffener material (N).\nS_outer::Float64: surface area of outer vessel (m^2).\nShead::Float64: surface area of one outer vessel head (m^2).\nScyl::Float64: surface area of cylindrical portion of tank (m^2).\nt_cyl::Float64: wall thickness of cylindrical portion of tank (m).\nt_head::Float64: wall thickness of tank head (m). \nl_tank::Float64: Total length of the tank (m).\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/fueltanks/#TASOPT.CryoTank.stiffener_weight","page":"Thermal and structural models","title":"TASOPT.CryoTank.stiffener_weight","text":"  stiffener_weight(tanktype::String, W::Float64, Rtank::Float64, perim::Float64, s_a::Float64, \n  ρstiff::Float64, θ1::Float64, θ2::Float64 = 0.0, Nstiff::Float64 = 2.0, l_cyl::F\n\nThis function calculates the weight of a single stiffener in an inner or outer vessel for a given inner vessel weight.\n\ndetails: 🔃 Inputs and Outputs\nInputs:tanktype::String: type of tank, options are \"inner\" or \"outer\".\nW::Float64: load carried by a stiffener ring (N).\nRtank::Float64: tank radius (m).\nperim::Float64: tank perimeter (m).\ns_a::Float64: maximum allowable stress in stiffener material (Pa).\nρstiff::Float64: stiffener density (kg/m^3).\nθ1::Float64: angular position of bottom tank supports, measured from the bottom of the tank (rad).\nθ2::Float64: angular position of top tank supports, measured from the bottom of the tank (rad). Only used with \"outer\" tank.\nNstiff::Float64: total number of stiffeners on outer vessel. Only used with \"outer\" tank.\nl_cyl::Float64: length of cylindrical portion of tank (m). Only used with \"outer\" tank.\nE::Float64: Young's modulus of stiffener material (Pa). Only used with \"outer\" tank.Outputs:Wstiff::Float64: weight of a stiffener ring (N).\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/fueltanks/#TASOPT.CryoTank.optimize_outer_tank","page":"Thermal and structural models","title":"TASOPT.CryoTank.optimize_outer_tank","text":"optimize_outer_tank(fuse::Fuselage, fuse_tank::fuselage_tank, Winnertank, l_cyl, θ1, θ2)\n\nThis function optimizes the number of intermediate stiffener rings to minimize the weight of an outer vessel.\n\ndetails: 🔃 Inputs and Outputs\nInputs:fuse::Fuselage: fuselage object.\nfuse_tank::fuselage_tank: fuselage tank object.\nWinnertank::Float64: weight of inner vessel and contents (N).\nl_cyl::Float64: length of cylindrical portion of outer vessel (m).Outputs:Ninterm::Float64: optimum number of intermediate stiffener rings.\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/fueltanks/#TASOPT.CryoTank.tankWthermal","page":"Thermal and structural models","title":"TASOPT.CryoTank.tankWthermal","text":"  tankWthermal(fuse::Fuselage, fuse_tank::fuselage_tank, z::Float64, Mair::Float64, xftank::Float64, ifuel::Int64)\n\ntankWthermal calculates the heat rate to a cryogenic tank for a given insulation thickness.\n\nThis function does not size the thermal insulation layers but rather calculates the heat rate to the tank,  for a given insulation thickness\n\ndetails: 🔃 Inputs and Outputs\nInputs:fuse::Fuselage: fuselage object.\nfuse_tank::fuselage_tank: fuselage tank object.\nz::Float64: flight altitude (m)\nMair::Float64: external air Mach number\nxftank::Float64: longitudinal coordinate of fuel tank centroid from nose (m)\nifuel::Int64: fuel index.Outputs:Q::Float64: Heat transfer rate into the tank (W).\n\nSee here.\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/fueltanks/#TASOPT.CryoTank.residuals_Q","page":"Thermal and structural models","title":"TASOPT.CryoTank.residuals_Q","text":"  residuals_Q(x, p)\n\nThis function calculates the residual for a non-linear solver. The states are the heat transfer rate (optional),  the tank wall temperature, and the temperatures at the interfaces of each insulation layers.\n\ndetails: 🔃 Inputs and Outputs\nInputs:x::Vector{Float64}: vector with unknowns.\np::Struct: structure of type thermal_params.\nmode::String: mode to find residual, options are \"Qknown\" and \"Qunknown\"Outputs:F::Vector{Float64}: vector with residuals.\n\n\n\n\n\n","category":"function"},{"location":"cryo_tank/fueltanks/","page":"Thermal and structural models","title":"Thermal and structural models","text":"[1]: Anderson, John. Fundamentals of Aerodynamics (SI units). McGraw Hill, 2011.","category":"page"},{"location":"cryo_tank/fueltanks/","page":"Thermal and structural models","title":"Thermal and structural models","text":"[2]: Hochstein, J., H-C. Ji, and J. Aydelott. \"Effect of subcooling on the on-orbit pressurization rate of cryogenic propellant tankage.\" 4th Thermophysics and Heat Transfer Conference. 1986.","category":"page"},{"location":"cryo_tank/fueltanks/","page":"Thermal and structural models","title":"Thermal and structural models","text":"[3]: Barron, Randall F. \"Cryogenic systems.\" Monographs on cryogenics (1985).","category":"page"},{"location":"aero/drag/#Drag","page":"Drag","title":"Drag","text":"","category":"section"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"The key drag contributions are assumed to come from the fuselage, wing and tail surfaces, and the lift-induced drag calculated at the Trefftz plane. Wave drag is not explicitly modelled.","category":"page"},{"location":"aero/drag/#axi","page":"Drag","title":"Axisymmetric fuselage drag","text":"","category":"section"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"The fuselage profile drag is determined by a quasi-axisymmetric coupled viscous-inviscid calculation. See Simplified Viscous/Inviscid Analysis for Nearly-Axisymmetric Bodies by M. Drela.","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"This method does not require any wetted area approximations or fineness-ratio correlations, but does require the geometry to be specified in the form of a cross-sectional area distribution Ascriptstyle (x) and a perimeter distribution b_0scriptstyle (x), shown in the Figure below. For a round cross-section these are, of course, related. To allow treating more general fuselage cross-sections, they are assumed to be specified separately. The cross section sizes and shapes can vary along the body, provided the variation is reasonably smooth.","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"(Image: ADfuse)","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"using Markdown\nMarkdown.parse_file(joinpath(\"../..\", \"src/aero\",\"theory_fuse_profile_drag.md\"))","category":"page"},{"location":"aero/drag/#TASOPT.aerodynamics._axisymm_flow-NTuple{16, Any}","page":"Drag","title":"TASOPT.aerodynamics._axisymm_flow","text":"_axisymm_flow(xnose, xend, xblend1, xblend2, Amax, \n      anose, btail, iclose,\n      Mach, nc, nldim,\n        xl, zl, sl, dyl, ql)\n\nCalculates compressible potential flow about a quasi-axisymmetric body,  using a simple piecewise-constant source line. Formerly, axisol!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:xnose::Float64: X (axial) location of nose point. \nxend::Float64: X location of tail point.\nxblend1::Float64: X location of nose-section blend point.\nxblend2::Float64: X location of tail-section blend point.\nAmax::Float64: Maximum cross-sectional area.\nanose::Float64: Nose-section shape exponent.\nbtail::Float64: Tail-section shape exponent.\niclose::Integer: If 0, tail tapers to a point, otherwise to an edge.\nMach::Float64: Freestream Mach number for Prandtl-Glauert.\nnc::Integer: Number of control points to be used.\nnldim::Integer: Max dimension of passed arrays.Outputs:nl::Integer: Number of output surface and wake points.\nilte::Integer: Index of TE point.\nxl::Array{Float64}: X (axial) locations of surface segment endpoints.\nzl::Array{Float64}: Z (vertical) locations of surface segment endpoints.\nsl::Array{Float64}: Arc lengths along surface and wake.\ndyl::Array{Float64}: Half-width of edge-type tail section.\nql::Array{Float64}: Velocities V/V_inf along surface and wake.\n\nSee theory above or Section 3 of Simplified Viscous/Inviscid Analysis for Nearly-Axisymmetric Bodies.  See also fuselage_drag!.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/#TASOPT.aerodynamics._BL_station_system-NTuple{65, Any}","page":"Drag","title":"TASOPT.aerodynamics._BL_station_system","text":"_BL_station_system(is_selfsimilar, is_laminar, is_wake, solves_direct, Mach, uinv, hksep,\n      x, b, rn, th, ds, ue,\n      h , h_th, h_ds,\n      hk, hk_th, hk_ds, hk_ue,\n      hc, hc_th, hc_ds, hc_ue,\n      hs, hs_th, hs_ds, hs_ue,\n      cf, cf_th, cf_ds, cf_ue,\n      di, di_th, di_ds, di_ue,\n      xm,bm,rnm,thm,dsm,uem, \n      hm , hm_thm, hm_dsm,\n      hkm, hkm_thm, hkm_dsm, hkm_uem,\n      hcm, hcm_thm, hcm_dsm, hcm_uem,\n      hsm, hsm_thm, hsm_dsm, hsm_uem,\n      cfm, cfm_thm, cfm_dsm, cfm_uem,\n      dim, dim_thm, dim_dsm, dim_uem)\n\nComputes Jacobian matrices for BL solution at an axial station. Called repeatedly by _axisymm_BL. Formerly, blsys!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:is_selfsimilar::Bool: Self-similar BL profile flag.\nis_laminar::Bool: Laminar flow flag.\nis_wake::Bool: In wake? Flag.\nsolves_direct::Bool: Direct solution flag, with prescribed inviscid velocity u_e = u_mathrminv\nMach::Float64: Mach number for compressibility.\nuinv::Float64: Inviscid velocity.\nx::Float64: Arc length.\nb::Float64: Lateral width of BL.\nrn::Float64: drdn, = 0 for 2D.\nth::Float64: Momentum thickness.\nds::Float64: Displacement thickness.\nue::Float64: Edge velocity.\nh::Float64: Shape parameter.\nhk::Float64: Kinematic shape parameter.\nhc::Float64: density shape parameter (Whitfield).\nhs::Float64: kinetic energy shape parameter.\ncf::Float64: Skin friction factor.\ndi::Float64: Dissipation factor.m denotes the previous point (minus one) in the upstream.   _z denotes partial derivative with respect to z (z = th, ds, ue).Outputs:aa::Array{Float64, 3, 3}: Jacobian matrix (wrt current point vars).\nbb::Array{Float64, 3, 3}: Jacobian matrix (wrt previous point vars).\nrr::Array{Float64, 3}: Residual.\n\nSee Section 4 of Simplified Viscous/Inviscid Analysis for Nearly-Axisymmetric Bodies.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/#TASOPT.aerodynamics._axisymm_BL-NTuple{10, Any}","page":"Drag","title":"TASOPT.aerodynamics._axisymm_BL","text":"_axisymm_BL(ndim, n,ite, xi, bi, rni, uinv, Reyn, Mach, fexcr)\n\nAxisymmetric boundary layer + wake calculation routine. Uses specified inviscid velocity, corrects for viscous displacement to allow calculation of separated flow. Formerly, blax!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:ndim::Integer: physical array dimension.\nn::Integer: number of boundary layer + wake points.\nite::Integer: index of trailing edge point, start of wake.\nxi::Array{Float64}: arc length array (BL coordinate).\nbi::Array{Float64}: lateral width of BL at surface (i.e., body perimeter). b_i = 0 for wake, 1 for 2D.\nrni::Array{Float64}: drdn to account for near-axisymmetric bodies, 0 for 2D.\nuinv::Array{Float64}: inviscid velocity, u_inv.\nReyn::Float64: Reynolds number,  rho_ref u_ref l_ref  mu_ref.\nMach::Float64: Mach number,  M = u_ref  a_ref.\nfexcr::Float64: excrescence multiplier applied to wall c_f, 1 for smooth wall.Assumed units for all quantities:l_ref: same unit as used for input xi,bi.\nu_ref: freestream velocity.\na_ref: freestream speed of sound.\nrho_ref: freestream density.\nmu_ref: freestream viscosity.Outputs:uei::Array{Float64}:  edge velocity, (u_ei = u_invi + {displacement correction}).\ndsi::Array{Float64}:  displacement thickness (delta^*).\nthi::Array{Float64}:  momentum thickness     (theta).\ntsi::Array{Float64}:  kinetic energy thickness (theta^*).\ndci::Array{Float64}:  density flux thickness   (delta^**).\ncfi::Array{Float64}:  skin friction coefficient, normalized with local rho, u (c_fi).\ncdi::Array{Float64}:  dissipation coefficient  , normalized with local rho,u (c_mathcalDi).\ncti::Array{Float64}:  max shear-stress coefficient, normalized with local rho,u (c_ti).\nhki::Array{Float64}:  kinematic shape parameter (H_Ki).\nphi::Array{Float64}:  integrated dissipation (Phi).Other outputs of interest can be computed as follows.   These are in units of l_ref, rho_ref, u_refbeffi: Effective perimeter,  b_effi = b_i  +  2 pi delta^* drdn.\nrhi: Edge density, rho_i = (1 + frac(gamma-1)2M^2 (10-u_ei^2))^frac1(gamma-1).\nmdef: Total mass defect, rho_i u_ei delta^* b_eff.\nPdef: Total momentum defect, rho_i u_ei^2 theta b_eff.\nEdef: Total kinetic energy defect, frac12 rho_i u_ei^3 theta^* b_eff.\ntauwb: Wall shear force/span, fractau_wb = frac12 u_ei^2 c_fi b_eff.\nDiss: Dissipation integral, rho_i u_ei^3 c_mathcalDi b_effi.Body profile drag D_p is the far-downstream momentum defect P_infty,   best obtained by applying Squire-Young to the last wake point, i = n :P_end = rho_i u_ei^2 theta b_eff\nH_end = delta^*theta\nH_infty = 1 + (gamma-1) M^2\nH_avg = frac12 (H_end + H_inf)\nP_inf = P_end u_ei^H_avg  =  D_p\n\nSee Section 4 of Simplified Viscous/Inviscid Analysis for Nearly-Axisymmetric Bodies. See also _BL_station_system and _BL_station_vars.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/#TASOPT.aerodynamics._BL_station_vars-NTuple{10, Any}","page":"Drag","title":"TASOPT.aerodynamics._BL_station_vars","text":"_BL_station_vars(is_selfsimilar, is_laminar, is_wake, Reyn, Mach, fexcr, x, θ, δs, ue)\n\nReturns the boundary layer variables needed for solution. Formerly, blvar!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:is_selfsimilar::Bool: Self-similar BL profile flag.\nis_laminar::Bool: Laminar flow flag.\nis_wake::Bool: In wake flag.\nReyn::Float64: Reynolds number.\nMach::Float64: Mach number for compressibility.\nfexcr::Float64: Excrescence factor.Outputs:h::Float64 : Shape parameter.\nhk::Float64: Kinematic shape parameter.\nhc::Float64: Density shape parameter (Whitfield).\nhs::Float64: Kinetic energy shape parameter.\ncf::Float64: Skin friction factor.\ncd::Float64: Dissipation factor and their derivatives.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/#TASOPT.aerodynamics.fuselage_drag!-NTuple{4, Any}","page":"Drag","title":"TASOPT.aerodynamics.fuselage_drag!","text":"fuselage_drag!(fuse, parg, para, ip)\n\nCalculates surface velocities, boundary layer, wake  for a quasi-axisymmetric body in compressible flow. Formerly, fusebl!().\n\nA compressible source line represents the potential flow. An integral BL formulation with lateral divergence represents the surface BL and wake. An added-source distribution represents the viscous displacement influence on the potential flow. The body shape is defined by its area and perimeter distributions A(x),  b0(x), which are defined by the various geometric parameters in parg. \n\ndetails: 🔃 Inputs and Outputs\nInputs:fuse::Fuselage: Fuselage model object.\nparg::AbstractArray{Float64}: Vector of aircraft model geometry parameters.\npara::AbstractArray{Float64}: Vector of aircraft model aerodynamic parameters.\nparm::AbstractArray{Float64}: Vector of aircraft model mission parameters.\nip::Integer: Index of flight point in par arrays.Outputs:No explicit outputs. Computed drag values are saved to para of aircraft model.\n\nSee Simplified Viscous/Inviscid Analysis for Nearly-Axisymmetric Bodies. See also _axisymm_BL and _axisymm_flow.\n\ncompat: Future Changes\nIn an upcoming revision, an aircraft struct and auxiliary indices will be passed in lieu of pre-sliced par arrays.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"","category":"page"},{"location":"aero/drag/#trefftz","page":"Drag","title":"Trefftz plane drag calculation","text":"","category":"section"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"Trefftz plane analysis computes the induced drag from lifting surfaces. The lift distributions are propagated downstream, accounting for streamline contraction from fuselage thickness variation as shown in the Figure below. ","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"(Image: ) Two shaded streamtubes are shown. Wake center radius y_o is nonzero due to the fuselage viscous wake displacement area.","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"The vorticity in the wake is numerically integrated at collocation points to determine the overall induced drag.","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"(Image: T)","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"Trefftz Plane vortices ii+1 ldots and collocation points i+12 used for velocity, impulse, and kinetic energy calculations. Left/right symmetry is exploited.  ","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"using Markdown\nMarkdown.parse_file(joinpath(\"../..\", \"src/aero\",\"theory_trefftz_plane.md\"))","category":"page"},{"location":"aero/drag/#TASOPT.aerodynamics.induced_drag!-Tuple{Any, Any, Any}","page":"Drag","title":"TASOPT.aerodynamics.induced_drag!","text":"  induced_drag!(para, wing, htail)\n\nComputes the induced drag via the Trefftz plane. Calls _trefftz_analysis. Formerly, cditrp!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:para::AbstractArray{Float64}: Array of aircraft model aerodynamic parameters.\nwing::TASOPT.Wing: Wing Structure.\nhtail::TASOPT.Tail: Htail Structure.Outputs:No explicit outputs. Computed induced drag value and span efficiency are saved to para of aircraft model.\n\ncompat: Future Changes\nIn an upcoming revision, an aircraft struct and auxiliary indices will be passed in lieu of pre-sliced par arrays.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/#TASOPT.aerodynamics._trefftz_analysis-NTuple{32, Any}","page":"Drag","title":"TASOPT.aerodynamics._trefftz_analysis","text":"_trefftz_analysis(nsurf, npout, npinn, npimg, \n      Sref, bref, b, bs, bo, bop, \n      zcent, po, gammat, gammas, \n      fLo,ktip, specifies_CL, CLsurfsp)\n\nTrefftz plane routine for the induced drag computation of nsurf number of surfaces. Formerly, trefftz1().\n\ndetails: 🔃 Inputs and Outputs\nInputs:nsurf::Integer: Number of surfaces (typically wing and horizontal tail).\nnpout::Integer: Number of spanwise intervals (outer panel).\nnpinn::Integer:  \"     \"       (inner panel).\nnpimg::Integer:  \"     \"       (image inside fuselage).\nb::Float64: Span.\nbs::Float64: Wing-break span.\nbo::Float64: Wing-root span.\nbop::Float64: Span of wing-root streamline in Trefftz plane\nzcent::Vector{Float64}: Vertical position at centerline for each surface.\ngammat::Vector{Float64}, gammas::Vector{Float64}`: Wing lift distribution \"taper\" ratios for outer and inner wing sections, respectively.\nfLo: wing root load adjustment factors (currently not implemented).\nktip::Float64: wing tip load adjustment factors.\nspecifies_CL::Bool: Flag for specified lift calculation (scales vorticities to achieve CLsurfsp before computing induced drag).\nCLsurfsp::Vector{Float64}: Prescribed surface lift coefficient.Outputs: -CLsurf::Vector{Float64}: Lift coefficients for each surface.  -CL::Float64: Sum of lift coefficients of all surfaces. -CD::Float64: Sum of induced drag coefficients of all surfaces. -spanef::Float64: Span efficiency of combined surfaces (= (CL^2  (π*AR))CD).\n\nSee theory above or Sections 2.14.7 and 3.8.1 of the TASOPT Technical Desc.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"","category":"page"},{"location":"aero/drag/#Wing-and-tail-surfaces","page":"Drag","title":"Wing and tail surfaces","text":"","category":"section"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"Lifting surface drag is determined via wing_profiledrag_scaled (when constant airfoil section cdf and cdp are already determined), and wing_profiledrag_direct (when an explicit modelling and integration is desired). Airfoil performance is accessed via a lookup of precomputed airfoil data, airfun.","category":"page"},{"location":"aero/drag/#TASOPT.aerodynamics.wing_profiledrag_direct-NTuple{13, Any}","page":"Drag","title":"TASOPT.aerodynamics.wing_profiledrag_direct","text":"  wing_profiledrag_direct(wing, γt, γs,\n        Mach, CL, CLhtail, \n        Reco, aRexp, kSuns, fexcd,\n        fduo, fdus, fdut)\n\nCalculates wing or tail surface profile CD by calculating the performance of wing segments explicitly via airfoil data (found in [./src/air/C.air] and accessed by [airfun], [airtable]). Called by aircraft_drag! if computes_wing_direct flag set to true. Formerly, surfcd2().\n\ndetails: 🔃 Inputs and Outputs\nInputs:Wing::TASOPT.Wing: Wing Structure.\nγt::Float64: Outer-panel load  taper ratio  pt/po.\nγs::Float64: Inner-panel load  taper ratio  ps/po.\nMach::Float64: Mach number.\nCL::Float64: Wing CL.\nCLhtail::Float64: Htail CL.\nReco::Float64: Reynolds number for co.\naRexp::Float64: Re-scaling exponent.\nkSuns::Float64: Shock-unsweep area constant.\nfexcd::Float64: Excrescence cd scaling factor.\nfduo::Float64, fdus::Float64, fdut::Float64: Velocity-change fractions at wing root, break (\"snag\"), and tip due to fuselage flow.Outputs:clpo::Float64,clps::Float64,clpt::Float64: Perpendicular sectional lift coefficient at wing root, break (\"snag\"), and tip.\nCDfwing::Float64: Friction profile cd in perp. plane.\nCDpwing::Float64: Pressure profile cd in perp. plane.\nCDwing::Float64: Overall profile CD.\nCDover::Float64: Fuselage added CD due to lift carryover.\n\nSee Sections 2.14.3 and 3.8.3 of TASOPT Technical Desc. See also aircraft_drag!, wing_profiledrag_scaled, [wing_CM], and [airfun].\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/#TASOPT.aerodynamics.wing_profiledrag_scaled-NTuple{15, Any}","page":"Drag","title":"TASOPT.aerodynamics.wing_profiledrag_scaled","text":"wing_profiledrag_scaled(S, \nb, bs, bo, \nλt, λs, sweep, \nco, cdf, cdp, \nReco, Reref, \naRexp, kSuns, fCDcen)\n\nComputes wing or tail surface profile CD from pre-computed chord quantities and corrections. Called by aircraft_drag! if computes_wing_direct flag set to false. Formerly, surfcd().\n\ndetails: 🔃 Inputs and Outputs\nInputs:S::Float64: reference area.\nb::Float64: span.\nbs::Float64: outer panel break span.\nbo::Float64: wing-root (fuselage) span.\nλt::Float64: outer-panel taper ratio  ctco.\nλs::Float64: inner-panel taper ratio  csco.\nsweep::Float64: wing sweep, degrees.\nco::Float64: wing root chord.\ncdf::Float64: friction profile cd.\ncdp::Float64: pressure profile cd.\nReco::Float64: Reynolds number for co.\nReref::Float64: reference Reynolds number for cd scaling.\naRexp::Float64: Re-scaling exponent.\nkSuns::Float64: shock-unsweep area constant.\nfCDcen::Float64 : related to fraction of wing BLI (see Eqns. 619 - 621).Outputs:CDsurf: overall profile CD.\nCDover: fuselage added CD due to lift carryover.\n\nSee Sections 2.14.3 and 3.8.3 of the TASOPT Technical Desc.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/#Airfoil-section-data","page":"Drag","title":"Airfoil section data","text":"","category":"section"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"The wing airfoil performance is represented by a parameterized transonic airfoil family spanning a range of thicknesses, whose performance is determined by 2D viscous/inviscid CFD calculation for a range of lift coefficients and Mach numbers. Together with suitable sweep corrections, this gives reliable profile+wave drag of the wing in cruise and high climb and high descent.","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"The pressure and friction drag coefficients for the wing are obtained from the 2D drag database via cubic interpolation. For the databases provided, each airfoil has been designed (by Mark Drela) for a well-defined transonic drag rise, so that the database returns c_d_f and c_d_p values representative of the best transonic airfoil technology.","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"Specifically, the perpendicular-plane friction and pressure drag coefficients are then obtained from the  database having the form ","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"beginaligned\nc_d_f  =  \nf_rm w_excr \nbarc_d_f(c_ell_scriptscriptstyle perpM_scriptscriptstyle perp textstyle fractc ) \n             left( fracRe_cRe_rm ref right)^ a_scriptscriptstyle Re \nc_d_p  =  \nf_rm w_excr \nbarc_d_p(c_ell_scriptscriptstyle perpM_scriptscriptstyle perp textstyle fractc ) \n             left( fracRe_cRe_rm ref right)^ a_scriptscriptstyle Re \nmathrmwhere \nhspace5ex\nM_scriptscriptstyle perp =  M_scriptscriptstyle infty cos Lambda \ntextstyle fractc  =  barh \nRe_c =  fracrho_scriptscriptstyle inftyV_scriptscriptstyle inftycmu_scriptscriptstyle infty \na_scriptscriptstyle Re simeq  -015\nendaligned","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"and f_rm w_excr geq 1 is an empirical specified factor to account for wing excrescence drag sources, and Re_rm ref is a reference Reynolds number at which the database functions barc_d_f barc_d_p were computed. The chord Reynolds number Re_c could of course be treated as an additional parameter in the database, but at a considerable increase in the size of the database and the computational effort needed to construct it. The value of the Re-scaling exponent a_scriptscriptstyle Resimeq -015 is appropriate for fully-turbulent flow. See the theory 📖 block below for more details.","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"using Markdown\nMarkdown.parse_file(joinpath(\"../..\", \"src/aero\",\"theory_airfun_and_splines.md\"))","category":"page"},{"location":"aero/drag/#TASOPT.aerodynamics.airtable-Tuple{Any}","page":"Drag","title":"TASOPT.aerodynamics.airtable","text":"airtable(fname)\n\nReads airfoil file and outputs the matrix and splines as an airfoil.\n\nThe airfoil data is stored as a function of three variables, typically Mach number mathrmMa, lift coefficient c_l, and thickness to chord ratio tau.\n\ncdf(Ma, cl, τ), cdp(Ma, cl, τ), cm(Ma, cl, τ)\n\ndetails: 🔃 Inputs and Outputs\nInputs:fname::String: Path to file.Outputs:airf::TASOPT.aerodynamics.airfoil: struct with airfoil performance characteristics.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/#TASOPT.aerodynamics.airfun-Tuple{Any, Any, Any, TASOPT.aerodynamics.airfoil}","page":"Drag","title":"TASOPT.aerodynamics.airfun","text":"airfun(cl, τ, Mach, air::airfoil)\n\nLooks up airfoil performance data at specified conditions, as precomputed and found in ./src/airfoil_data/.\n\ndetails: 🔃 Inputs and Outputs\nInputs:      cl::Float64: Airfoil section lift coefficient.\nτ::Float64: Airfoil section thickness-to-chord ratio.\nMach::Float64: Mach number.\nair::TASOPT.aerodynamics.airfoil: airfoil structure with performance data.Outputs:cdf::Float64: Airfoil section skin friction drag.\ncdp::Float64: Airfoil section pressure drag.\ncdw::Float64: Airfoil section wave drag (unused and assumed 0 here; placeholder left for future implementation).\ncm::Float64: Airfoil section pitching moment.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"","category":"page"},{"location":"aero/drag/#Total-drag-calculation","page":"Drag","title":"Total drag calculation","text":"","category":"section"},{"location":"aero/drag/#TASOPT.aerodynamics.aircraft_drag!-NTuple{4, Any}","page":"Drag","title":"TASOPT.aerodynamics.aircraft_drag!","text":"aircraftdrag!(ac, imission, ip, computeswing_direct)\n\nCalculates aircraft CD components for operating point, ipoint. If computes_wing_direct is true, computes wing cdf,cdp from airfoil database # iairf, otherwise uses default values in para array.  Called by _mission_iteration!(), size_aircraft!, and takeoff!. Formerly, cdsum!().\n\nThe total drag is computed by\n\nC_D = C_D i + C_Dfuse + C_Dwing + C_Dover + C_Dhtail + C_Dvtail + C_Dstrut + C_Dnace + Delta C_DBLIf + Delta C_DBLIw\n\nwhere:\n\nC_Di (CDi) is the total induced drag including the wing and tail,\nC_Dfuse (CDfuse) is the fuselage profile drage computed by solving a boundary layer integral equation,\nC_Dwing (CDwing) is the wing profile drag (viscous + pressure) computed using airfoil data obtained from CFD,\nC_Dover (CDover) is the fuselage added CD due to lift carryover,\nC_Dhtail (CDhtail) is the horizontal tail profile drag computed in a similar manner with CDwing,\nC_Dvtail (CDvtail) is the vertical tail profile drag computed in a similar manner with CDwing,\nC_Dstrut (CDstrut) is the strut profile drag, \nC_Dnace (CDnace) is the nacelle profile drag,\nDelta C_DBLIf (dCDBLIf) is related to the boundary layer ingestion on the fuselage,\nand Delta C_DBLIw (dCDBLIw) is related to the boundary layer ingestion on the wing.\n\ndetails: 🔃 Inputs and Outputs\n\n\nInputs:       - ac::aircraft: aircraft data storage object       - imission::Int64: mission index       - computes_wing_direct::Bool: Flag if drag should be computed with wing_profiledrag_direct (true) or if para values should be used (false).\n\n  **Outputs:**\n  - No explicit outputs. Computed drag values are saved to `para` of `aircraft` model.\n\nSee Section 2.14 of the TASOPT Technical Desc. See also fuselage_drag!, wing_profiledrag_direct, wing_profiledrag_scaled, cfturb, and induced_drag!.\n\n\n\n\n\n","category":"method"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"","category":"page"},{"location":"aero/drag/#Other-utilities","page":"Drag","title":"Other utilities","text":"","category":"section"},{"location":"aero/drag/#TASOPT.aerodynamics.cfturb","page":"Drag","title":"TASOPT.aerodynamics.cfturb","text":"  cfturb(Re)\n\nReturns the total C_f for turbulent flat plate (one side) as a function of mathrmRe_l\n\nC_f turb = frac0523(log(006mathrmRe))^2 \n\n\n\n\n\n","category":"function"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"For example, the turbulent flat plate C_f for a Re of 10e6 can be calculated as follows:","category":"page"},{"location":"aero/drag/","page":"Drag","title":"Drag","text":"Re = 10e6\ncfturb(Re)","category":"page"},{"location":"misc/dreladocs/#dreladocs","page":"Original Drela docs","title":"Original Drela docs","text":"","category":"section"},{"location":"misc/dreladocs/","page":"Original Drela docs","title":"Original Drela docs","text":"Obtained from Mark Drela's TASOPT site where all documents and Fortran code can be found.","category":"page"},{"location":"misc/dreladocs/","page":"Original Drela docs","title":"Original Drela docs","text":"#Copy files from source to build\ncp(\"../../drela_TASOPT_2p16/\", \"../assets/drela_TASOPT_2p16\");\nnothing #needs to either return nothing or a .md","category":"page"},{"location":"misc/dreladocs/","page":"Original Drela docs","title":"Original Drela docs","text":"TASOPT Technical Description\nSimplified Viscous/Inviscid Analysis for Nearly-Axisymmetric Bodies\nFilm Cooling Flow Loss Model\nTurbofan Sizing and Analysis with Variable cp(T)\nThermally-Perfect Gas Calculations\nBalanced Field Length Calculation\nTurbofan Weight Model from Historical Data","category":"page"},{"location":"misc/dreladocs/","page":"Original Drela docs","title":"Original Drela docs","text":"","category":"page"},{"location":"misc/dreladocs/#flowchart","page":"Original Drela docs","title":"TASOPT Flowchart","text":"","category":"section"},{"location":"misc/dreladocs/","page":"Original Drela docs","title":"Original Drela docs","text":"For an attempt to make graphical sense of the aircraft-sizing workflow, see here.","category":"page"},{"location":"misc/fordevs/#fordevs","page":"Notes for devs","title":"Notes for devs","text":"","category":"section"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"info: Info\nTASOPT.jl is very much a WIP. Get at us on github with ideas, contributions, and bugs, but search the issues first.   Thanks! 🙂","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"tip: Tips\nRefer to the data structures to see where input file parameters end up.\nLook out for !!! compat admonishments marking where things will likely change in the future.\nAny remaining references to NPSS are currently non-functional. We're working on replacing detailed (but efficient) engine performance modelling.","category":"page"},{"location":"misc/fordevs/#Benchmarks","page":"Notes for devs","title":"Benchmarks","text":"","category":"section"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Examples of aircraft-sizing benchmarking and profiling files are provided in test/benchmark_sizing.jl. These can be run after making changes to the code to check if there has been a speed-up or slow-down.\nSome individual functions are additionally benchmarked in test/benchmark_elements.jl.\nDevelopers can similarly create other benchmarks for new features, models, and functions.","category":"page"},{"location":"misc/fordevs/#perftips","page":"Notes for devs","title":"Performance tips","text":"","category":"section"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Below are a few performance tips based on lessons learnt during TASOPT.jl development. The Julia docs has a section on performance that you can find here, so the goal is not to repeat everything but expand on sections that are rather terse in there. Two key things to keep in mind to get fast Julia code are:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Writing type stable code for which the compiler can generate performant code.\nReducing unnecessary allocations.","category":"page"},{"location":"misc/fordevs/#Reducing-allocations-and-profiling","page":"Notes for devs","title":"Reducing allocations and profiling","text":"","category":"section"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"The test/benchmark_elements.jl file shows some examples of using BenchmarkTools.jl to benchmark functions in Julia. ","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Sometimes you need more than just the number of allocations from benchmarking to actually go eliminate or reduce the allocations. Where the allocations are being made can be non-obvious in some cases. Coverage.jl is a useful package for getting a better sense of where in your code the allocations are coming from.","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Specifically you want to follow the steps here. Reproduced here for convenience:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"details: How to track down allocations\nStart julia with tracking allocations enabled:julia --track-allocation=userThen run all the commands you want to profile (this is to ensure they compile first), then clear the memory allocation tracking by running Profile.clear_malloc_data(); run your commands again and then quit julia. For example:using TASOPT, Profile\njulia> Re = 10e6\n1.0e7\n\njulia> TASOPT.aerodynamics.cfturb(Re)\n0.002954557862895432\n\njulia> Profile.clear_malloc_data()\n\njulia> TASOPT.aerodynamics.cfturb(Re)\n0.002954557862895432\n\njulia> exit()Then look at the directory where these files live (i.e., the source code) and you should see some additional files with annotations showing where the allocations were made. You can do all the above steps without needing Coverage.jl. Where Coverage.jl becomes useful is to analyze large parts of the code by doing:using Coverage\nanalyze_malloc(dirnames)  # could be \".\" for the current directory, or \"src\", etc.","category":"page"},{"location":"misc/fordevs/#Custom-types-and-type-inference","page":"Notes for devs","title":"Custom types and type inference","text":"","category":"section"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"While defining new types (i.e., structs) you need to think about type inference and how the compiler can or cannot learn the types of the downstream calculations. See this section here in the Julia manual that has some examples. I'll list a more TASOPT.jl relevant example here to emphasize the point. ","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Let's take the airfoil example. Consider an airfoil database as follows:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"struct airfoil\n\tRe::AbstractFloat\n\tMa::AbstractVector{Float64}\n\tcl::AbstractVector{Float64}\n\tthickness::AbstractVector{Float64}\nend\n\n# Create an instance\nair_unstable = airfoil(10e6, Ma_array, cl_array, toc_array)","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"For the above structure the Julia compiler will not be able to generate high performance code. This is fundamentally because the type of air.Re cannot be determined by the type of a. For example the compiler can't know from the type of a if cl_array was a Vector{Float64} or not and won't be able to create type stable code.","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"julia> typeof(a.cl), typeof(a.cl) <: AbstractVector{Float64}, typeof(a.cl) <: Vector{Float64}\n(LinRange{Float64, Int64}, true, false)","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"We can do better by declaring the struct in such a way that the type of cl is inferred from the type of the wrapper object. Like,","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"struct airfoil{T<:AbstractFloat, V<:AbstractVector{Float64}}\n\tRe::T\n\tMa::V\n\tcl::V\n\tthickness::V\nend\n\n# Create an instance\nair_stable = airfoil(10e6, Ma_array, cl_array, toc_array)","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Now if Ma_array, cl_array, and toc_array were all of type Vector{Float64} then we'd end up with something like this:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"julia> typeof(a_stable)\nairfoil{Float64, Vector{Float64}}","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"But if they were  <:AbstractRange you'd get:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"julia> typeof(a_stable)\nairfoil{Float64, LinRange{Float64, Int64}}","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"In this case given the type, not the value, of a the compiler can correctly infer  the type of a.cl, and generate appropriate code. ","category":"page"},{"location":"misc/fordevs/#Type-instability-from-using-variables-in-parent-scopes","page":"Notes for devs","title":"Type instability from using variables in parent scopes","text":"","category":"section"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Here let's look at a common pattern that can be tempting to write and what the performance penalty is.","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"ia = 3\nfunction do_something1(A)\n    a = A[ia]\n    if a == 0.0\n        return 1.0\n    else\n        return 2.0\n    end\nend","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Consider the code above - it takes in some Array, loads a particular value and then compares it and does something to it. ","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"julia> A = rand(3,3)\n3×3 Matrix{Float64}:\n 0.355865  0.81659    0.529105\n 0.210353  0.978487   0.671198\n 0.734191  0.0497119  0.72487\n \njulia> @code_warntype do_something1(A)\nMethodInstance for do_something1(::Matrix{Float64})\n  from do_something1(A) @ Main REPL[6]:1\nArguments\n  #self#::Core.Const(Main.do_something1)\n  A::Matrix{Float64}\nLocals\n  a::Any\nBody::Float64\n1 ─      (a = Base.getindex(A, Main.ia))\n│   %2 = Main.:(==)::Core.Const(==)\n│   %3 = a::Any\n│   %4 = (%2)(%3, 0.0)::Any\n└──      goto #3 if not %4\n2 ─      return 1.0\n3 ─      return 2.0","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"The compiler can't determine the type of a from the arguments alone (even though it correctly identifies that the input argument type is Matrix{Float64}). This is because the type of ia is not specified.","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"You can fix that by doing something like this:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"const ia2 = 3\nfunction do_something2(A)\n    a = A[ia2]\n    if a == 0.0\n        return 1.0\n    else\n        return 2.0\n    end\nend\n\nia3::Int = 3\nfunction do_something3(A)\n    a = A[ia3]\n    if a == 0.0\n        return 1.0\n    else\n        return 2.0\n    end\nend","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Both of the above now return type stable code:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"julia> @code_warntype do_something2(A)\nMethodInstance for do_something2(::Matrix{Float64})\n  from do_something2(A) @ Main REPL[3]:1\nArguments\n  #self#::Core.Const(Main.do_something2)\n  A::Matrix{Float64}\nLocals\n  a::Float64\nBody::Float64\n1 ─      (a = Base.getindex(A, Main.ia2))\n│   %2 = Main.:(==)::Core.Const(==)\n│   %3 = a::Float64\n│   %4 = (%2)(%3, 0.0)::Bool\n└──      goto #3 if not %4\n2 ─      return 1.0\n3 ─      return 2.0\n\njulia> @code_warntype do_something3(A)\nMethodInstance for do_something3(::Matrix{Float64})\n  from do_something3(A) @ Main REPL[11]:1\nArguments\n  #self#::Core.Const(Main.do_something3)\n  A::Matrix{Float64}\nLocals\n  a::Float64\nBody::Float64\n1 ─      (a = Base.getindex(A, Main.ia3))\n│   %2 = a::Float64\n│   %3 = (%2 == 0.0)::Bool\n└──      goto #3 if not %3\n2 ─      return 1.0\n3 ─      return 2.0","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"The relevant sections in the performance docs are here.","category":"page"},{"location":"misc/fordevs/#Static-arrays-and-performance","page":"Notes for devs","title":"Static arrays and performance","text":"","category":"section"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"StaticArrays is a package that provides functionality for statically sized (i.e., the size is determined from the type, doesn't have to be immutable) arrays.","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Consider the Weight types defined in TASOPT.","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"@kwdef struct Weight <: AbstractLoad\n\t\"\"\"Weight [N]\"\"\"\n\tW::Float64\n\t\"\"\"Location {x,y,z} [m]\"\"\"\n\tr::SVector{3, Float64} = SA[0.0,0.0,0.0]\n\t\"\"\"Coordinate Frame\"\"\"\n\tframe::Frame = WORLD\n\nend","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Then extending Base.+ and adding a new function to do center of mass calculations:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"import Base.+\n\nfunction +(W1::T, W2::T) where T<:Weight\n\ttotal_W = W1.W + W2.W\n\tWeight(total_W, (W1.r*W1.W + W2.r*W2.W)/total_W)\nend # function +\n\n\"\"\"\n    center_of_weight(W_array::AbstractArray{Weight})\n\nCalculates the coordinates of the center of mass/weight and returns a `Weight`\ntype of the equivalent weight and at the center of mass.\n\"\"\"\nfunction center_of_weight(W_array::AbstractArray{Weight})\n    total_weight = 0.0\n    r̄ = SVector{3,Float64}(zeros(3))\n    for weight in W_array\n        total_weight += weight.W\n        r̄ = r̄ + weight.W * weight.r\n    end\n    return Weight(W = total_weight, r = r̄./total_weight)\nend\n","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"Now let's look at performance:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"julia> Ws = [W1, W2, W3, W4] #Assume these are already defined\n4-element Vector{Weight}:\n Weight(10.0, [0.0, 0.0, 0.0], Frame(0, [0.0, 0.0, 0.0]))\n Weight(10.0, [10.0, 0.0, 0.0], Frame(0, [0.0, 0.0, 0.0]))\n Weight(10.0, [10.0, 10.0, 0.0], Frame(0, [0.0, 0.0, 0.0]))\n Weight(10.0, [0.0, 10.0, 0.0], Frame(0, [0.0, 0.0, 0.0]))\n\njulia> center_of_weight(Ws)\nWeight(40.0, [5.0, 5.0, 0.0], Frame(0, [0.0, 0.0, 0.0]))\n\njulia> sum(Ws)\nWeight(40.0, [5.0, 5.0, 0.0], Frame(0, [0.0, 0.0, 0.0]))\n\njulia> @benchmark center_of_weight($Ws)\nBenchmarkTools.Trial: 10000 samples with 997 evaluations.\n Range (min … max):  19.475 ns … 571.464 ns  ┊ GC (min … max): 0.00% … 92.64%\n Time  (median):     20.186 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   21.935 ns ±  18.992 ns  ┊ GC (mean ± σ):  3.39% ±  3.80%\n\n  ▃▃▇█▆▃▂▃▄▂▁▁ ▁▁▁▁▁▁ ▂▂▁▁▁▁▂▂▂▁ ▁                             ▂\n  █████████████████████████████████▇█▇▇█▇▆▇▇▇▆▇▆▇▆█▆▇▇▆▅▅▅▆▆▁▅ █\n  19.5 ns       Histogram: log(frequency) by time      31.5 ns <\n\n Memory estimate: 80 bytes, allocs estimate: 1.\n\njulia> @benchmark sum($Ws)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  7.458 ns … 21.667 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     7.708 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   7.791 ns ±  0.836 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n    █▁▃                                                       \n  ▂▄███▄▃▂▂▂▂▁▁▁▁▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▂▂▂▂▂▂▂▂▂ ▂\n 7.46 ns        Histogram: frequency by time        11.5 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"By extending Base.+ we got the sum function for free cause it just knows how to add things together. But you see that the static array approach seems to take much longer, that's because the static array definition here isn't done correctly. This is an easy to make mistake, look at the following comparison: ","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"function center_of_weight(W_array::AbstractArray{Weight})\n    total_weight = 0.0\n    r̄ = SVector{3}([0.0, 0.0, 0.0])\n    for weight in W_array\n        total_weight += weight.W\n        r̄ = r̄ + weight.W * weight.r\n    end\n    return Weight(W = total_weight, r = r̄./total_weight)\nend\njulia> @benchmark center_of_weight($Ws)\nBenchmarkTools.Trial: 10000 samples with 998 evaluations.\n Range (min … max):  17.995 ns … 541.165 ns  ┊ GC (min … max): 0.00% … 94.78%\n Time  (median):     18.745 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   19.894 ns ±  19.000 ns  ┊ GC (mean ± σ):  3.84% ±  3.87%\n\n  ▄▆▆▅▇██▇▄▂                    ▁▃▃▃▂▂▁▁                       ▂\n  ███████████▇▆▆▅▆▅▃▅▁▅▅▅▅▅▇█▇██████████▇█▇▇▆▆▆▆▆▄▅▄▅▄▅▃▅▅▄▄▅▇ █\n  18 ns         Histogram: log(frequency) by time      25.8 ns <\n\n Memory estimate: 80 bytes, allocs estimate: 1.","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"VERSUS:","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"function center_of_weight(W_array::AbstractArray{Weight})\n    total_weight = 0.0\n    r̄ = SVector{3}(0.0, 0.0, 0.0)\n    for weight in W_array\n        total_weight += weight.W\n        r̄ = r̄ + weight.W * weight.r\n    end\n    return Weight(W = total_weight, r = r̄./total_weight)\nend\n\n\njulia> @benchmark center_of_weight($Ws)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  3.917 ns … 17.292 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     4.000 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   4.046 ns ±  0.431 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n          ▃       █       ▆       ▁        ▃       ▁         ▁\n  ▃▁▁▁▁▁▁▁█▁▁▁▁▁▁▁█▁▁▁▁▁▁▁█▁▁▁▁▁▁▁██▁▁▁▁▁▁▁█▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▆ █\n  3.92 ns      Histogram: log(frequency) by time     4.21 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n","category":"page"},{"location":"misc/fordevs/","page":"Notes for devs","title":"Notes for devs","text":"All that really changed was the little square brackets! SVector{3}(0.0, 0.0, 0.0) vs SVector{3}([0.0, 0.0, 0.0]) The latter results in 1 allocation, which, for such a small calculation, is a significant increase in the time required!","category":"page"},{"location":"#TASOPT.jl-Documentation","page":"Home","title":"TASOPT.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TASOPT.jl is a multi-disciplinary aircraft design and optimization code implemented in Julia based on TASOPT by Mark Drela.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It can currently model tube-and-wing aircraft using 2D viscous-inviscid CFD to calculate aerodynamic performance, simple beam bending theory to size the wings, and thermodynamic cycle modeling to calculate engine performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"New modelling capabilities are actively being developed. Please be sure to refer to the full documentation and dev notes before financing a new airframe development project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are several workflows that are possible to use TASOPT.jl. We outline here the most common few.","category":"page"},{"location":"#Simple-install","page":"Home","title":"Simple install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The easiest way to run TASOPT.jl would be to add the package using the julia package manager using the github repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can do this by starting a Julia session and then activating the package manager by typing ] and then entering:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add git@github.com:MIT-LAE/TASOPT.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can then import TASOPT as you would with any Julia package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TASOPT","category":"page"},{"location":"#Local-development","page":"Home","title":"Local development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are going to develop the source code of TASOPT.jl you might benefit from a local clone of the git repository which can then fit into a workflow using Revise.jl for example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Step 1: Clone the git repo locally","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone git@github.mit.edu:LAE/TAESOPT.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Step 2: cd to the folder where TASOPT is cloned","category":"page"},{"location":"","page":"Home","title":"Home","text":"Step 3: Use Pkg to install/ develop the package","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> dev .","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should now be able to import TASOPT from within any Julia script in your base environment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We'd suggest starting with the examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nIf you are using Revise.jl be sure to first import Revise before importing TASOPTusing Revise\nusing TASOPT","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Units-and-Non-Dimensionals","page":"Home","title":"Units and Non-Dimensionals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All dimensional quantities are treated internally as SI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Refer to /example/defaults/default_input.toml for the input file's conversion capability and formatting. It's also useful for typical values and explaining inputs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Non-dimensionalization follows the Drela conventions (see TASOPT Technical Description).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates # hide\nprintln(\"Documentation built $(Dates.now()) with Julia $(VERSION)\") # hide","category":"page"},{"location":"aero/lift/#Lift","page":"Lift","title":"Lift","text":"","category":"section"},{"location":"aero/lift/","page":"Lift","title":"Lift","text":"Surface lift distributions tildep are defined in terms of a baseline piecewise-linear distribution pscriptstyle (eta) defined like the chord planform, but with its own taper ratios gamma_s and gamma_t. ","category":"page"},{"location":"aero/lift/","page":"Lift","title":"Lift","text":"(Image: ) Piecewise-linear aerodynamic load tildep scriptstyle (eta), with modifications at center and tip.","category":"page"},{"location":"aero/lift/","page":"Lift","title":"Lift","text":"The segments are integrated to compute the lift contribution to the wing root load, p_o, as required by structural computations. The sectional lift distribution is treated as an input to induced drag and surface drag computations.","category":"page"},{"location":"aero/lift/","page":"Lift","title":"Lift","text":"using Markdown\nMarkdown.parse_file(joinpath(\"../..\", \"src/aero\",\"theory_lifting.md\"))","category":"page"},{"location":"aero/lift/#TASOPT.aerodynamics.wing_loading-NTuple{6, Any}","page":"Lift","title":"TASOPT.aerodynamics.wing_loading","text":"wing_loading(wing, rclt, rcls, N, W, Lhtail)\n\nComputes wing root (\"center\") loading p_o to balance the net load. Formerly, wingpo().\n\nN*W - L_h tail \times 2*p(η) dy + 2ΔL₀ + 2ΔLₜ = N*W - (L_htail)\n\ndetails: 🔃 Inputs and Outputs\nInputs:wing::TASOPT.structures.wing: Wing structure.\nrclt::Float64: tip  /root cl ratio (clt/clo)\nrcls::Float64: break/root cl ratio (cls/clo)\nN::Float64: Max vertical load factor for wing bending loads\nW::Float64: Aircraft Weight\nLhtail::Float64: Worst-case (most negative) tail lift expected in the critical sizing caseOutputs:po::Float64: Wing root loading magnitude.\n\nSee Section 2.6.2 of the TASOPT Technical Desc.\n\n\n\n\n\n","category":"method"},{"location":"aero/lift/#TASOPT.aerodynamics.tail_loading!-Tuple{Any, Any, Any}","page":"Lift","title":"TASOPT.aerodynamics.tail_loading!","text":"tail_loading!(tail,S,qne; t_fac = 1.0)\n\nCalculates stabilizer span, root chord, and root loading based on the  never-exceed dynamic pressure, maximum CL, sweep, and aspect ratio. Formerly, tailpo!().\n\ndetails: 🔃 Inputs and Outputs\nInputs:tail::TASOPT.structures.tail: Tail structure.\nS::Float64: Stabilizer area.\nqne::Float64: Never-exceed dynamic pressure.\nt_fac::Float64: Tail Factor (1 for Htail/Wing, 2 for Vtail).Outputs:po::Float64: Stabilizer root loading.\nb::Float64: Stabilizer wingspan.\n\nSee Geometry or Section 2.3.2 and 2.9.6 of the TASOPT Technical Description.\n\n\n\n\n\n","category":"method"},{"location":"aero/lift/#TASOPT.aerodynamics.wing_section_cls-NTuple{8, Any}","page":"Lift","title":"TASOPT.aerodynamics.wing_section_cls","text":"wing_section_cls(wing, gammat, gammas,\n        CL, CLhtail,\n        fduo, fdus, fdut)\n\nCalculates section cl at  eta = ηo,ηs,1. Formerly, wingcl().\n\ndetails: 🔃 Inputs and Outputs\nInputs:Wing::TASOPT.Wing: Wing Structure\nγt::Float64, γs::Float64: Wing lift distribution \"taper\" ratios for outer and inner wing sections, respectively.\nCL::Float64, CLhtail::Float64: Overall lift coefficient of wing and horizontal tail, respectively.\nduo::Float64, dus::Float64, dut::Float64: Velocity-change fractions at wing root, break (\"snag\"), and tip due to fuselage flow.Outputs:clo::Float64, cls::Float64, clt::Float64: Section lift coefficient at root, wing break (\"snag\"), and tip.\n\nSee Sections 2.5 and 2.6 of the TASOPT Technical Desc. Called by aircraft_drag!.\n\n\n\n\n\n","category":"method"}]
}
